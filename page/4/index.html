<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Go over the mountain, and they will hear your story.">
<meta property="og:type" content="website">
<meta property="og:title" content="Ordinary Road">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Ordinary Road">
<meta property="og:description" content="Go over the mountain, and they will hear your story.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ordinary Road">
<meta name="twitter:description" content="Go over the mountain, and they will hear your story.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/">





  <title>Ordinary Road</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ordinary Road</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/12/【Java编程思想】四：操作符/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crayon Cxy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ordinary Road">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/12/【Java编程思想】四：操作符/" itemprop="url">【Java编程思想】四：操作符</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-12T10:30:31+08:00">
                2018-11-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/12/【Java编程思想】四：操作符/" class="leancloud_visitors" data-flag-title="【Java编程思想】四：操作符">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、更简单的打印语句"><a href="#一、更简单的打印语句" class="headerlink" title="一、更简单的打印语句"></a>一、更简单的打印语句</h1><p>&ensp;&ensp;&ensp;&ensp;在第二章中使用了一个打印语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Hello World"</span>);</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;结合static的静态包用法，如果这个语句在多个地方进行调用，那么可以将这个语句写成静态方法，然后通过导入静态包的形式使用静态方法：</p>
<p>test包下的Printer类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		System.out.println(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>practice包下的TestStatic类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.chenxyt.java.test.Printer.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		print(<span class="string">"This is TestStatic"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、使用Java操作符"><a href="#二、使用Java操作符" class="headerlink" title="二、使用Java操作符"></a>二、使用Java操作符</h1><p>&ensp;&ensp;&ensp;&ensp;Java与其他语言一样，支持加号，正号，减号，负号，乘除号等操作符，同时“=”，“==”和“！=”不光可以操作基本操作类型，还可以操作所有的对象。此外，String类支持“+”和“+=”。</p>
<h1 id="三、优先级"><a href="#三、优先级" class="headerlink" title="三、优先级"></a>三、优先级</h1><p>&ensp;&ensp;&ensp;&ensp;当一个表达式中存在多个操作符时，操作符的优先级就尤为重要了，它决定了程序运算操作执行的先后顺序。Java中的计算顺序与其它语言的基本相同，先计算乘除，再计算加减，有括号的先计算括号里边的。System.out.println()语句中包含“+”的操作符号，简单的只是进行字符串的连接，复杂一点的就是当编译器发现“+”前边是一个String类型，会尝试将“+”后面的内容转换成String类型。</p>
<h1 id="四、赋值"><a href="#四、赋值" class="headerlink" title="四、赋值"></a>四、赋值</h1><p>&ensp;&ensp;&ensp;&ensp;赋值操作使用的是“=”操作符，将“=”右边的值赋给左边，右值可以是任意的常数、变量或者是表达式，只有它能生成一个值即可，而左值必须是一个明确的已命名的变量，就是必须要有个物理空间来进行存储。比如，可以将一个常数赋给变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>但是却不能将一个变量赋值给一个常数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>=a;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;对于基本的数据类型，赋值操作没有引用的涉及，只是单纯的将一个值赋值给另一个值。例如a=b，当b再次被修改时，a不会受到影响，因为a与b相互独立。但是对于对对象的赋值来说，情况却大大不同，因为我们对对象的操作是操作了对象的引用，所以当一个对象赋值给另一个对象时，实际上是拷贝了引用到左值，也就是比如c和d是指向两个不同对象的引用，当c=d时，实际发生的情况是c和d都指向了原本只有d指向的对象。而c被赋值之后，原来的引用丢失了，它曾经所指向的不再被引用的对象被垃圾回收器回收了。如下例子创建了两个不同的对象，进行赋值操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tank</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> level;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Tank tk1 = <span class="keyword">new</span> Tank();</span><br><span class="line">		Tank tk2 = <span class="keyword">new</span> Tank();</span><br><span class="line">		tk1.level = <span class="number">2</span>;</span><br><span class="line">		tk2.level = <span class="number">3</span>;</span><br><span class="line">		System.out.println(<span class="string">"tk1.level = "</span> + tk1.level + <span class="string">"---tk2.level = "</span> + tk2.level);</span><br><span class="line">		tk1=tk2;</span><br><span class="line">		System.out.println(<span class="string">"tk1.level = "</span> + tk1.level + <span class="string">"---tk2.level = "</span> + tk2.level);</span><br><span class="line">		tk2.level=<span class="number">5</span>;</span><br><span class="line">		System.out.println(<span class="string">"tk1.level = "</span> + tk1.level + <span class="string">"---tk2.level = "</span> + tk2.level);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="[Java编程思想]四：操作符/png1.png" alt="png1"></p>
<p>&ensp;&ensp;&ensp;&ensp;tk1和tk2分别是两个独立的对象，它们内部有level属性，赋值之前两个对象的属性值不同，赋值操作完成之后两个对象的属性值相同，当再次更改对象tk2的level值时，预期的理想情况是不会影响tk1的值，但实际结果并非如此，tk1与tk2对象的属性相同，这与前面的分析结果相同。<br>&ensp;&ensp;&ensp;&ensp;Java中这种针对对象的特殊现象叫做“<strong>别名现象</strong>”，如果想避免这种现象的话，可以使用如下操作，赋值操作针对属性而不是对象的引用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tk1.level=tk2.level</span><br></pre></td></tr></table></figure>
<p>这样操作就可以保持两个对象本身相互独立。</p>
<p>&ensp;&ensp;&ensp;&ensp;在调用方法传参的时候也是会产生“别名问题”，如下例子，调用方法copy之后，理想的是只改变了方法内的值，实际上是改变了方法之外对象的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tank</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> level;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(Tank tk3)</span></span>&#123;</span><br><span class="line">		tk3.level = <span class="number">9</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Tank tk1 = <span class="keyword">new</span> Tank();</span><br><span class="line">		tk1.level = <span class="number">2</span>;</span><br><span class="line">		System.out.println(<span class="string">"tk1.level = "</span> + tk1.level);</span><br><span class="line">		copy(tk1);</span><br><span class="line">		System.out.println(<span class="string">"tk1.level = "</span> + tk1.level);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果，方法外部tk1对象的值被修改了</p>
<p><img src="[Java编程思想]四：操作符/png2.png" alt="png2"></p>
<h1 id="五、算术操作符"><a href="#五、算术操作符" class="headerlink" title="五、算术操作符"></a>五、算术操作符</h1><p>&ensp;&ensp;&ensp;&ensp;Java中的算术操作符与其它语言基本类似，有加号（+）、减号（-）、乘号（*）、取整（/）、取余（%），同时也具有简化运算符的功能如要将x加4之后再赋值给x，则可以写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x+=<span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<h1 id="六、自动递增递减"><a href="#六、自动递增递减" class="headerlink" title="六、自动递增递减"></a>六、自动递增递减</h1><p>&ensp;&ensp;&ensp;&ensp;Java中的递增递减操作与其它语言基本类似，递增符合（++），递减符合（–），操作目的是快速使一个整数加1或者减1如a++等同于a=a+1，这两种符号分别有两种使用方式称为“前缀式”和“后缀式”，前缀式意味着符号在变量前边，后缀式意味着符号在变量后边。二者的区别，对于前缀式是先做运算再取值，如a=1，b=++a，此时a跟b的值都是2，而后缀式则是先取值再做运算，如a=1，b=a++，此时b的值为1，a的值为2</p>
<h1 id="七、关系操作符"><a href="#七、关系操作符" class="headerlink" title="七、关系操作符"></a>七、关系操作符</h1><p>&ensp;&ensp;&ensp;&ensp;关系操作符生成的是一个boolean（布尔）结果，它们计算操作数之间的关系，如果关系为真则结果为true，如果关系为假则结果为false。关系操作符号包括小于（＜）、大于（＞）、小于等于（＜=）、大于等于（＞＝）、等于（==）以及不等于（！=）。等于和不等于适用于所有的基本数据类型，而其它的操作符不适用于boolean类型，因为它们的值为true或者false，比较大小没有意义。<br>操作符“==”和“！=”同样适用于操作对象，但是与基本操作类型相比有一些不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Integer itg1 = <span class="keyword">new</span> Integer(<span class="number">22</span>);</span><br><span class="line">		Integer itg2 = <span class="keyword">new</span> Integer(<span class="number">22</span>);</span><br><span class="line">		System.out.println(itg1==itg2);</span><br><span class="line">		System.out.println(itg1!=itg2);</span><br><span class="line">		<span class="keyword">int</span> int1 = <span class="number">22</span>;</span><br><span class="line">		<span class="keyword">int</span> int2 = <span class="number">22</span>;</span><br><span class="line">		System.out.println(int1==int2);</span><br><span class="line">		System.out.println(int1!=int2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上创建了两个Integer对象和两个int基本数据类型值，分别做“==”和“！=”判断，结果如下：</p>
<p><img src="[Java编程思想]四：操作符/png3.png" alt="png3"></p>
<p>&ensp;&ensp;&ensp;&ensp;从结果可见，两个对象是“！=”，而两个int基本数据类型值是“==”，这是为什么呢？因为对于对象来说，“==”和“！=”比较的是对象的引用，虽然这两个对象的值相同，但是他们对象的引用并不是一个，也就是他们在内存中有两个不同的存储位置，所以不相同。所以要想比较对象的值是否相同，我们可以使用对象的equals（）方法来进行比较，它是Object类的一个通用方法，第一章中说到过所有类的父类都是Object，因此任何类的对象都可以调用这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Integer itg1 = <span class="keyword">new</span> Integer(<span class="number">22</span>);</span><br><span class="line">		Integer itg2 = <span class="keyword">new</span> Integer(<span class="number">22</span>);</span><br><span class="line">		System.out.println(itg1.equals(itg2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="[Java编程思想]四：操作符/png4.png" alt="png4"></p>
<p>&ensp;&ensp;&ensp;&ensp;新的问题来了，我们看如下示例，我们自定义了一个新的类，创建了两个对象进行比较：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Oper</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Oper op1 = <span class="keyword">new</span> Oper();</span><br><span class="line">		Oper op2 = <span class="keyword">new</span> Oper();</span><br><span class="line">		op1.i=<span class="number">2</span>;</span><br><span class="line">		op2.i=<span class="number">2</span>;</span><br><span class="line">		System.out.println(op1.equals(op2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="[Java编程思想]四：操作符/png5.png" alt="png5"></p>
<p>&ensp;&ensp;&ensp;&ensp;结果仍然为fasle！这是为什么呢？这是因为Object类中equals（）方法实际上是比较两个引用是否相同，就是它与“==”的本质效果是一样的，但是在第一个示例中的Integer类中，Java覆盖了这个方法，方法内容判断两个对象的类型是否相同以及值是否相同即可。而我们自己创建的Oper类并没有覆盖这个方法，所以沿用的还是Object类的方法。常见的String类也是覆盖了equals（）方法，效果与Integer类的对象相同。</p>
<h1 id="八、逻辑操作符"><a href="#八、逻辑操作符" class="headerlink" title="八、逻辑操作符"></a>八、逻辑操作符</h1><p>&ensp;&ensp;&ensp;&ensp;Java中的逻辑操作符与其它语言基本类似，包括与（&amp;&amp;）、或（||）、非（！），不同的是Java中的逻辑操作符只能应用与布尔值之间或者是表达式结果为布尔值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">		System.out.println((a&gt;b)&amp;&amp;(b&gt;c));</span><br><span class="line">		System.out.println((a&gt;b)||(b&lt;c));</span><br><span class="line">		System.out.println(!(a&lt;b));		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="[Java编程思想]四：操作符/png6.png" alt="png6"></p>
<p>&ensp;&ensp;&ensp;&ensp;逻辑运算满足如下关系，“&amp;&amp;”逻辑与运算符必须两边同时为真则结果为真，否则为假。“||”逻辑或运算符只要有一边为真则结果为真，“！”非运算符取对应值的对立面，即非真则假。对于逻辑与和逻辑或运算还有个名词叫做<strong>短路</strong>，即当两个算式做逻辑与运算时，如果左边第一个算式为假，则显然这个逻辑表达式最后的结果一定为假，那么就没有必要进行下边的表达式计算，直接结束运算，这个过程称作短路。</p>
<h1 id="九、直接常量"><a href="#九、直接常量" class="headerlink" title="九、直接常量"></a>九、直接常量</h1><p>&ensp;&ensp;&ensp;&ensp;Java中同样可以使用例如“π”这种常量表示。</p>
<h1 id="十、按位操作符"><a href="#十、按位操作符" class="headerlink" title="十、按位操作符"></a>十、按位操作符</h1><p>&ensp;&ensp;&ensp;&ensp;Java中的按位操作符与其他语言基本相似，有按位与（&amp;）、按位或（|）、按位异或（^）和按位非（~）操作符。它们针对基本数据类型的一个比特位（bit）进行运算。运算规则如下，&amp;操作符必须同时为1才为1，|操作符只有同时为0时才为0，^操作符只要有一个为1就为1，~是单目运算符，取反，若值为1则结果为0，反之为1。按位操作符除了~还可以与“=”合起来使用，如&amp;=或者|=、^=。<br>对于布尔值，同样可以进行按位与、按位或和按位异或运算，但是不能进行按位非运算，并且他们不会被短路，不管第一个表达式结果是什么，都会继续运算下去。</p>
<h1 id="十一、移位操作符"><a href="#十一、移位操作符" class="headerlink" title="十一、移位操作符"></a>十一、移位操作符</h1><p>&ensp;&ensp;&ensp;&ensp;移位操作符操作的也是二进制的“位”，移位操作符只能用来处理整数类型。移位操作也是二元操作符，一共有三种，左移操作符（&lt;&lt;），右移操作符（&gt;&gt;），无符号右移操作符（&gt;&gt;&gt;），左移操作符是操作符左边的数向左移动操作符右边指定的位数，<strong>低位补0</strong>，右移操作符是操作符左边的数向右移动操作符右边指定的位数，其中<strong>正数高位补0，负数高位补1</strong>。无符号右移操作符是Java独有的一种，<strong>即不管正数还是负数，右移之后高位都补0</strong>。关于移位操作有两点说明，一是高位指的是左边的位，二是对于int类型，最大长度为32位，对于long类型最大长度为64位。移位示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">6297</span>;</span><br><span class="line">		<span class="keyword">int</span> b = -<span class="number">6297</span>;</span><br><span class="line">		System.out.println(Integer.toBinaryString(a));</span><br><span class="line">		System.out.println(Integer.toBinaryString(b));</span><br><span class="line">		System.out.println(Integer.toBinaryString(a&gt;&gt;<span class="number">5</span>));</span><br><span class="line">		System.out.println(Integer.toBinaryString(a&lt;&lt;<span class="number">5</span>));</span><br><span class="line">		System.out.println(Integer.toBinaryString(a&gt;&gt;&gt;<span class="number">5</span>));</span><br><span class="line">		System.out.println(Integer.toBinaryString(b&gt;&gt;<span class="number">5</span>));</span><br><span class="line">		System.out.println(Integer.toBinaryString(b&lt;&lt;<span class="number">5</span>));</span><br><span class="line">		System.out.println(Integer.toBinaryString(b&gt;&gt;&gt;<span class="number">5</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;我们以int类型6297为例，分别对正6297和负6297做三种位移操作，结果如下：</p>
<p><img src="[Java编程思想]四：操作符/png7.png" alt="png7"></p>
<p>满足前边所说，左移低位补0，右移正数高位补0，低位补1，因为高位0没有实际意义，所以没有写出。同时，因为数据类型为int类型，所以最大长度为32位，超出的部分被截断了。</p>
<p>&ensp;&ensp;&ensp;&ensp;如果对char、short、byte类型的数值进行移位处理，那么他们会被先转成int类型，并且得到的结果也只是int类型。只有数值右端对的低5位才会有用，这样可以防止移位得到超过int类型的最大位数。比如说5&lt;&lt;34，因为最多能移32位，所以要把34转成二进制，然后取低5位，34转换成2进制是100010，取低5位就是00010，也就是5&lt;&lt;34实际上就是5&lt;&lt;2=10100=20。同样的对于long类型，long的最大长度为64位，所以数值的低6位有效。移位运算符同时也支持“&lt;&lt;=”等运算操作。</p>
<h1 id="十二、三元操作符IF-ELSE"><a href="#十二、三元操作符IF-ELSE" class="headerlink" title="十二、三元操作符IF-ELSE"></a>十二、三元操作符IF-ELSE</h1><p>&ensp;&ensp;&ensp;&ensp;三元操作符也称条件操作符，它有三个操作符。表达形式如下：<br>boolean-exp？value1：value2；<br>boolean-exp是一个布尔表达值，如果值为真，则返回value1的值，如果值为假，则返回value2的值。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">int</span> b = a&gt;<span class="number">10</span>?a*<span class="number">100</span>:a*<span class="number">10</span>;</span><br><span class="line">		System.out.println(<span class="string">"b===="</span>+ b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="[Java编程思想]四：操作符/png8.png" alt="png8"></p>
<p>因为a&lt;10，所以布尔表达式的值为假，所以取value2也就是a*10的值。</p>
<h1 id="十三、字符串操作符-和"><a href="#十三、字符串操作符-和" class="headerlink" title="十三、字符串操作符+和+="></a>十三、字符串操作符+和+=</h1><p>&ensp;&ensp;&ensp;&ensp;Java中可以使用+和+=连接String类型，并且当操作符左边你的数为String时，Java会试图将操作符右边的类型转换成String。</p>
<h1 id="十四、使用操作符常犯的错误"><a href="#十四、使用操作符常犯的错误" class="headerlink" title="十四、使用操作符常犯的错误"></a>十四、使用操作符常犯的错误</h1><p>&ensp;&ensp;&ensp;&ensp;注意“=”和“==”的区别，以及逻辑运算符如（&amp;&amp;）和位运算符（&amp;）的区别和前自增“++i”和后自增“i++”的区别。注意“==”和“equals（）”的使用，注意别名现象。</p>
<h1 id="十五、类型转换操作符"><a href="#十五、类型转换操作符" class="headerlink" title="十五、类型转换操作符"></a>十五、类型转换操作符</h1><p>&ensp;&ensp;&ensp;&ensp;Java中有跟其它语言相同的转换方式，（类型）值形式，也可以使用基本类型的包装器的转换方法进行转换。</p>
<h1 id="十六、Java没有size-of"><a href="#十六、Java没有size-of" class="headerlink" title="十六、Java没有size of"></a>十六、Java没有size of</h1><p>&ensp;&ensp;&ensp;&ensp;C语言中使用size of来获取程序占用的内存字节大小，目的是确定平台的移植操作，Java中没有这个方法，也就是不需要获取这个值，因为Java在不同的平台下基本数据类型具有相同的大小，可以便捷的移植。</p>
<h1 id="十七、总结"><a href="#十七、总结" class="headerlink" title="十七、总结"></a>十七、总结</h1><p>&ensp;&ensp;&ensp;&ensp;操作符在各个语言中基本通用，熟练掌握自增自减、逻辑运算、位运算以及移位操作即可，理解“==”和“equals()”的原理，理解别名现象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/【Java编程思想】三：static关键字的四种用法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crayon Cxy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ordinary Road">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/【Java编程思想】三：static关键字的四种用法/" itemprop="url">【Java编程思想】static关键字的四种用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-09T15:16:46+08:00">
                2018-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/09/【Java编程思想】三：static关键字的四种用法/" class="leancloud_visitors" data-flag-title="【Java编程思想】static关键字的四种用法">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&ensp;&ensp;&ensp;&ensp;上一章说到了static关键字，static是Java中很重要的一个关键字，在一些场景下可以达到优化程序的效果。本文学习它的不同使用场景。在此之前先了解一下变量的类型。Java中变量分为两种，按作用域分为成员变量和局部变量。成员变量是在类中声明的，不属于任何方法，当前类中有效。局部变量是声明在方法中的，出了当前方法即超出作用域。接下来正文说一下static关键字的四中使用场景：</p>
<h1 id="一、修饰成员变量"><a href="#一、修饰成员变量" class="headerlink" title="一、修饰成员变量"></a>一、修饰成员变量</h1><p>&ensp;&ensp;&ensp;&ensp;static最常用的作用就是修饰成员变量，被static修饰的成员变量也叫做类变量。它与普通成员变量的区别是，它在内存中只有一份拷贝，Java虚拟机只为其分配一次内存。通俗的讲就是，这个变量，不管被多少人使用，他们使用的都是同一个变量，彼此的修改会有影响。可以通过类名.变量的形式进行访问。而普通的成员变量则是没实例化一个对象就产生一个拷贝，虚拟机为每一个变量拷贝都分配了内存。所以类变量的用处一般在于进行变量共享的时候。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Name:"</span> + name + <span class="string">"---Age:"</span> + age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TestStatic ts1 = <span class="keyword">new</span> TestStatic();</span><br><span class="line">		TestStatic ts2 = <span class="keyword">new</span> TestStatic();</span><br><span class="line">		ts1.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">		ts1.age = <span class="number">22</span>;</span><br><span class="line">		ts2.name = <span class="string">"lisi"</span>;</span><br><span class="line">		ts2.age = <span class="number">33</span>;</span><br><span class="line">		ts1.print();</span><br><span class="line">		ts2.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是普通的成员变量的例子，ts1和ts2对于变量name和age分别拥有自己的副本，互相不影响，所以赋值之后，他们能得到他们期望的值。</p>
<p><img src="[Java编程思想]三：static关键字的四种用法/png1.png" alt="png1"></p>
<p>接下来将成员变量age修改为类变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Name:"</span> + name + <span class="string">"---Age:"</span> + age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TestStatic ts1 = <span class="keyword">new</span> TestStatic();</span><br><span class="line">		TestStatic ts2 = <span class="keyword">new</span> TestStatic();</span><br><span class="line">		ts1.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">		ts1.age = <span class="number">22</span>;</span><br><span class="line">		ts2.name = <span class="string">"lisi"</span>;</span><br><span class="line">		ts2.age = <span class="number">33</span>;</span><br><span class="line">		ts1.print();</span><br><span class="line">		ts2.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时由于age变成了类变量，因此ts1和ts2共用了一个变量副本，先赋值的会被后赋值的覆盖掉。</p>
<p><img src="[Java编程思想]三：static关键字的四种用法/png2.png" alt="png2"></p>
<p>此外第二个示例代码中，静态成员变量使用了对象.变量的方式进行调用，这里编译器会给出警告，使用类名.方法之后警告就会解除。</p>
<p><img src="[Java编程思想]三：static关键字的四种用法/png3.png" alt="png3"></p>
<h1 id="二、修饰成员方法"><a href="#二、修饰成员方法" class="headerlink" title="二、修饰成员方法"></a>二、修饰成员方法</h1><p>&ensp;&ensp;&ensp;&ensp;static另一个作用是修饰类中的方法，其目的是可以通过类名.方法的形式调用方法，而避免频繁的创建对象。同时对于存储空间来说也只有一个，不同对象调用的是同一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Name:"</span> + name + <span class="string">"---Age:"</span> + age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TestStatic ts1 = <span class="keyword">new</span> TestStatic();</span><br><span class="line">		TestStatic ts2 = <span class="keyword">new</span> TestStatic();</span><br><span class="line">		ts1.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">		ts1.age = <span class="number">22</span>;</span><br><span class="line">		ts2.name = <span class="string">"lisi"</span>;</span><br><span class="line">		TestStatic.age = <span class="number">33</span>;</span><br><span class="line">		TestStatic.print();</span><br><span class="line">		TestStatic.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将之前代码中的print方法改为使用static修饰之后，这个方法就可以不用对象.方法的形式调用了。</p>
<h1 id="三、修饰代码块"><a href="#三、修饰代码块" class="headerlink" title="三、修饰代码块"></a>三、修饰代码块</h1><p>&ensp;&ensp;&ensp;&ensp;我们先看一下对象的初始化过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Load</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Load</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		System.out.println(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span></span>&#123;</span><br><span class="line">	Load ld1 = <span class="keyword">new</span> Load(<span class="string">"普通变量1"</span>);</span><br><span class="line">	Load ld2 = <span class="keyword">new</span> Load(<span class="string">"普通变量2"</span>);</span><br><span class="line">	<span class="keyword">static</span> Load ld3 = <span class="keyword">new</span> Load(<span class="string">"静态变量3"</span>);</span><br><span class="line">	<span class="keyword">static</span> Load ld4 = <span class="keyword">new</span> Load(<span class="string">"静态变量4"</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TestStatic</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		System.out.println(msg);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TestStatic ts = <span class="keyword">new</span> TestStatic(<span class="string">"TestStatic 初始化"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;在类TestStatic中，我们初始化了两个普通成员变量和两个静态成员变量，并在main函数开始的时候初始化了TestStatic对象。结果如下：</p>
<p><img src="[Java编程思想]三：static关键字的四种用法/png4.png" alt="png4"></p>
<p>&ensp;&ensp;&ensp;&ensp;静态成员变量最先被初始化，并且按照执行的先后顺序进行初始化。其次初始化的是成员变量，最后初始化的是构造方法。所以在创建一个对象的时候，最先被初始化的是静态成员变量。</p>
<p>&ensp;&ensp;&ensp;&ensp;在看另外一个调用了静态方法的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Load</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Load</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		System.out.println(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span></span>&#123;</span><br><span class="line">	Load ld1 = <span class="keyword">new</span> Load(<span class="string">"普通变量1"</span>);</span><br><span class="line">	Load ld2 = <span class="keyword">new</span> Load(<span class="string">"普通变量2"</span>);</span><br><span class="line">	<span class="keyword">static</span> Load ld3 = <span class="keyword">new</span> Load(<span class="string">"静态变量3"</span>);</span><br><span class="line">	<span class="keyword">static</span> Load ld4 = <span class="keyword">new</span> Load(<span class="string">"静态变量4"</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TestStatic</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		System.out.println(msg);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"静态方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TestStatic.staticFunc();</span><br><span class="line">		System.out.println(<span class="string">"@@@@@@@@@"</span>);</span><br><span class="line">		TestStatic ts = <span class="keyword">new</span> TestStatic(<span class="string">"TestStatic 初始化"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 我们在创建对象之前先调用了静态方法，结果如下:</p>
<p><img src="[Java编程思想]三：static关键字的四种用法/png5.png" alt="png5"></p>
<p>&ensp;&ensp;&ensp;&ensp;我们可以看到，静态成员的初始化发生在创建对象之前，确切的说是在调用静态方法之前就已经被初始化了。并且，当我们创建对象的时候，原本被初始化过的静态成员变量跟静态方法没有再次被初始化。</p>
<p>&ensp;&ensp;&ensp;&ensp;这时我们的static的作用就是，修饰一段都需要被修饰为static的域。被static修饰的代码域，域中所有的内容都被当成static变量，且优先初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Load</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Load</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		System.out.println(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span></span>&#123;</span><br><span class="line">	Load ld1 = <span class="keyword">new</span> Load(<span class="string">"普通变量1"</span>);</span><br><span class="line">	Load ld2 = <span class="keyword">new</span> Load(<span class="string">"普通变量2"</span>);</span><br><span class="line">	<span class="keyword">static</span> Load ld3;</span><br><span class="line">	<span class="keyword">static</span> Load ld4;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		ld3 = <span class="keyword">new</span> Load(<span class="string">"静态变量3"</span>);</span><br><span class="line">		ld4 = <span class="keyword">new</span> Load(<span class="string">"静态变量4"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TestStatic</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		System.out.println(msg);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"静态方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TestStatic.staticFunc();</span><br><span class="line">		System.out.println(<span class="string">"@@@@@@@@@"</span>);</span><br><span class="line">		TestStatic ts = <span class="keyword">new</span> TestStatic(<span class="string">"TestStatic 初始化"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改之前的代码将静态成员变量放在由static修饰的域中，结果如下：</p>
<p><img src="[Java编程思想]三：static关键字的四种用法/png6.png" alt="png6"></p>
<p>与分开修饰结果相同。</p>
<h1 id="四、静态导入"><a href="#四、静态导入" class="headerlink" title="四、静态导入"></a>四、静态导入</h1><p>&ensp;&ensp;&ensp;&ensp;前边三种都是比较常用的场景，还有一种不是太常用，是JDK1.5之后新加入的功能，导入一个带有静态方法的包，并将包修饰为static，从而在当前类中直接调用修饰的静态方法，就好像是自己的方法一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.chenxyt.java.test;</span><br><span class="line">public class Printer &#123;</span><br><span class="line">	public static void print(String msg)&#123;</span><br><span class="line">		System.out.println(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后另一个包中使用import static导入这个类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.chenxyt.java.practice;</span><br><span class="line">import static com.chenxyt.java.test.Printer.*;</span><br><span class="line">public class TestStatic&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		print(&quot;This is TestStatic&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="[Java编程思想]三：static关键字的四种用法/png7.png" alt="png7"></p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>&ensp;&ensp;&ensp;&ensp;static是Java语言中的一个很重要的关键字，主要用途有三个方面修饰成员变量，修饰成员方法以及修饰代码块。使用static修饰的成员变量在类加载的时候就已经被初始化了，它属于类变量，不属于某个对象，所有该类的实例化对象拥有同一个静态成员变量副本，常用的用途可以用它来做计数器。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/【Java编程思想】二：一切都是对象/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crayon Cxy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ordinary Road">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/【Java编程思想】二：一切都是对象/" itemprop="url">【Java编程思想】一切都是对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-09T10:49:08+08:00">
                2018-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/09/【Java编程思想】二：一切都是对象/" class="leancloud_visitors" data-flag-title="【Java编程思想】一切都是对象">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、用引用操作对象"><a href="#一、用引用操作对象" class="headerlink" title="一、用引用操作对象"></a>一、用引用操作对象</h1><p>&ensp;&ensp;&ensp;&ensp;在Java中，一切都是对象，但是操作对象的标识符是对象的一个“引用”，这一关系可以理解为电视机与遥控器的关系。我们通过遥控器控制电视机，我们在房间里不管在哪都可以使用遥控器操作电视机。同时，遥控器又可以独立存在，即引用可以独立存在，有如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;上一行代码仅仅是创建了一个引用，而并非是一个对象。如果此时我们向s发送消息的话，将报出运行时异常的错误。因为前文讲到Java中消息的传递是建立在对象之间来完成的。因此我们需要在建立引用的时候对其进行初始化，使其指向一个对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"abc"</span>；</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;这里使用了Java语言的特性，字符串可以使用引号引起来用来进行初始化操作。</p>
<h1 id="二、必须由你创建所有的对象"><a href="#二、必须由你创建所有的对象" class="headerlink" title="二、必须由你创建所有的对象"></a>二、必须由你创建所有的对象</h1><p>&ensp;&ensp;&ensp;&ensp;我们创建了一个操作对象的引用，通常希望它与一个对象相关联，以便我们可以进行消息的传递，完成业务功能。Java语言中使用new关键字来完成这个操作，它的含义是“给我创建一个对象与我的引用关联”。所以上述代码可以改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String（abc<span class="string">"）;</span></span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;它表示为给我一个String类型的对象，并且初始化为“abc”。</p>
<p>&ensp;&ensp;&ensp;&ensp;当我们创建好对象时，他们是怎么样进行内存分配的呢？程序在计算机中有如下五个地方可以分配内存：</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.寄存器：</strong>这是最快的存储区，他在处理器的内部，并且数量非常有限。因此它是根据需求进行分配，你基本不能自己控制他的分配。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.堆栈：</strong>位于通用（RAM）随机存储器中，通过堆栈指针的移动进行内存分配，速度仅次于寄存器。在堆栈中分配内存空间的项，Java系统必须明确知道其声明周期，以便更好地进行指针的移动。这也从一定程度上进行了限制，因此Java中，对象的引用存在堆栈中，但是对象并不存在堆栈中。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.堆：</strong>一种同样存放在RAM的内存池，存放Java中所有的对象，且不需要知道其声明周期。是Java程序中主要的内存分配区域，只需要new关键字即可获得内存，但这种效率要比在堆栈上低很多。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.常量存储：</strong>常量池通常存在程序代码内部，这样使得他们永远不会被改变。在部分嵌入式系统中，常量本身会与其它部分分离，这种情况通常将常量存在（ROM）只读存储器中。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>5.非RAM存储：</strong>数据可以完全脱离程序存储在外部，从而不受程序的控制。比如文件流对象和持久化对象，文件流通常发给另外一台机器，而持久化对象则通常是存储在硬盘中。</p>
<p>&ensp;&ensp;&ensp;&ensp;Java中有一种特殊的类型称作是基本类型，通常情况下，new将对象存储在堆里，当创建一个简单的小的对象时，显得不是很有效，因此Java采用跟C或者C++相同的方式，不用new创建变量，而创建一个并非是引用的自动变量，这个变量直接存储值，并将其存储在堆栈中。与其他语言不同的是，Java中所有的基本类型的大小在各个平台都相同，这使得Java程序有更好的跨平台移植性。</p>
<p><img src="[Java编程思想]二：一切都是对象/png1.png" alt="png1"></p>
<p>&ensp;&ensp;&ensp;&ensp;所有的数值类型都有正负号，所以Java中不存在无符号类型。基本类型具有包装器类，使得可以在堆中创建一个非基本对象，用来表示对应的基本类型。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = ‘x’；</span><br><span class="line">Character ch = <span class="keyword">new</span> Character（c）；</span><br></pre></td></tr></table></figure>
<p>也可以这样用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Character ch = <span class="keyword">new</span> Character（‘x’）；</span><br></pre></td></tr></table></figure>
<p>Java SE5的自动包装功能可以自动的将基本类型转换为包装器类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Character ch = ‘x’；</span><br></pre></td></tr></table></figure>
<p>也可以反向转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char c = ch；</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;Java中还提供了两个用于高精度计算的类：BigInteger和BigDecimal，他们大体属于“包装器类”，但是他们没有对应的基本类型，不过可以通过方法调用的方式与int 和 float进行交互操作。BigInteger支持任意精度的整数，BigDecimal支持任意精度的浮点数。</p>
<p>&ensp;&ensp;&ensp;&ensp;Java与其他语言一样都提供了数组的功能，不同的是，Java语言保证了数组的安全性，会确保数组被初始化才使用，不会出现其他语言中的访问没有被初始化的内存区域。当创建了一个数组对象时，实际上就创建了一个引用数组，并且每个引用会自动初始化一个特定的值，该值拥有自己的关键字null，一旦Java看到了null，就知道这个引用还有指向对象，也就是没有被初始化。这个过程称为下标检查。</p>
<h1 id="三、永远不需要销毁对象"><a href="#三、永远不需要销毁对象" class="headerlink" title="三、永远不需要销毁对象"></a>三、永远不需要销毁对象</h1><p>&ensp;&ensp;&ensp;&ensp;Java语言与其它语言一样都有作用域的概念，作用域决定了定义在其内部的变量的可见性和生命周期。作用域使用一对花括号表示。这里需要注意的是，Java对象与其它基本类型不同，它可以存活于作用域外部，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">"x"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;引用s在作用域结束时就已经失去了意义，但是String对象仍然存活，只是我们暂时无法使用它。因为它的唯一引用已经超出了范围。后面会讲程序的执行过程，如何传递和复制引用。Java中只要你需要，对象会一直存在，Java与其它语言不同的是自带了垃圾回收机制，会自动识别不需要的对象进行回收以达到释放内存的目的。因此你无需担心忘了释放对象的内存。</p>
<h1 id="四、创建新的数据类型：类"><a href="#四、创建新的数据类型：类" class="headerlink" title="四、创建新的数据类型：类"></a>四、创建新的数据类型：类</h1><p>&ensp;&ensp;&ensp;&ensp;前文说到，同一种对象的集合我们称作是类，类表示所有由它实例化的对象都有相同的基本属性。Java中使用class关键字创建类，class后跟类的名字。这里不存在类似先有鸡还是先有蛋的问题，对象是一系列集合中的一个具体实例，也就是对象是一个类的具体实例化，因此在创建对象之前，一定先存在了这个对象所属的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Students</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如上我们定义了一个新的类，它是一个空类，没有属性也没有方法，所以还不能传递消息。但是我们可以用它实例化一个对象了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Students student = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;类中有两种数据类型，一种是字段属性，另一种是方法。字段用来表示这个类的一些属性，方法用来表示这个类的一些行为，可以做哪些事情。每个对象都有存储字段的空间，并且类内部的普通属性的字段不可以共享。我们定义如下字段属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Students&#123;</span><br><span class="line">    int i;</span><br><span class="line">    double j;</span><br><span class="line">    boolean k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;定义好了字段属性之后就可以创建一个对象，并通过对象引用操作对象内的字段属性，使用对象引用“.”方法的形式为对象内的字段属性赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Students student = <span class="keyword">new</span> Students();</span><br><span class="line">student.i=<span class="number">1</span>;</span><br><span class="line">student.j=<span class="number">1.1</span>;</span><br><span class="line">student.k=<span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;Java会为类中的基本类型成员提供一个默认的初始值，以确保可以有效的初始化，防止程序运行出错。如果这个初始值不符合业务要求，那么需要开发者自行初始化。如果不是类中的基本类型数据变量，那么它的初始值就是随机的。</p>
<p><img src="[Java编程思想]二：一切都是对象/png2.png" alt="png2"></p>
<h1 id="五、方法、参数和返回值"><a href="#五、方法、参数和返回值" class="headerlink" title="五、方法、参数和返回值"></a>五、方法、参数和返回值</h1><p>&ensp;&ensp;&ensp;&ensp;Java类中的方法决定了能做哪些事情，传递哪些消息。方法的组成包括：名称、参数、返回值和方法体，其基本形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">methodName</span><span class="params">(Arg arg)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*Method Body*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中ReturuType是方法返回给调用方的返回值类型，methodName是方法名，Arg是参数类型，arg是参数，注释中的是方法要做的事情。</p>
<p>&ensp;&ensp;&ensp;&ensp;Java中对象的调用同样是通过对象引用“.”方法名来完成的。并且要保证这个对象可以执行这个方法，否则编译器会提示错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objectName.methodName(arg,arg1,arg2);</span><br><span class="line">ReturnType x = obejctName.methodName(arg,arg1,arg2);</span><br></pre></td></tr></table></figure>
<p>如上分别是有返回值和无返回值的调用方式。</p>
<h1 id="六、构建一个Java程序"><a href="#六、构建一个Java程序" class="headerlink" title="六、构建一个Java程序"></a>六、构建一个Java程序</h1><p>&ensp;&ensp;&ensp;&ensp;Java中为了解决命名冲突的问题，采用了分包的形式。将相同类型，或者相同作用，相同业务场景的类放在一个包中，不同的包彼此隔离，并且不同包中可以出现同名的类。使用import关键字导入相关的包即可访问对应包中的类，若导入后出现同名的类，则需要指明对应类的包名。通常情况下，我们必须创建一个类的实例对象来访问类中的属性和方法，而有一种特殊的情况，就是当被static修饰的属性和方法时，不需要对象进行访问。直接使用类名.属性/方法的形式进行访问。也就是说，这个属性和方法属于这个类了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;现在即使我们创建两个对象，对于属性i仍然只有一个值，也就是说这个被static修饰了的域变成了一个公共的属性。不同对象之间共享同一个变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TestStatic ts1 = <span class="keyword">new</span> TestStatic();</span><br><span class="line">TestStatic ts2 = <span class="keyword">new</span> TestStatic();</span><br></pre></td></tr></table></figure>
<p>关于static关键字的作用，下一章详细学习。</p>
<h1 id="七、你的第一个Java程序"><a href="#七、你的第一个Java程序" class="headerlink" title="七、你的第一个Java程序"></a>七、你的第一个Java程序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*</span><br><span class="line">public class HelloWorld&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello World&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;import是导入java.util工具包下的所有类,HelloWorld是类名，类名需要与文件名相同，main方法是程序的入口，虽然这里没有用到参数列表，但是对于main函数来说这是必须的。使用开发工具如Eclipse运行程序即可看到控制台打印“HelloWorld”</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/08/【Java编程思想】一：对象导论/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crayon Cxy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ordinary Road">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/08/【Java编程思想】一：对象导论/" itemprop="url">【Java编程思想】对象导论</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-08T14:21:09+08:00">
                2018-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/08/【Java编程思想】一：对象导论/" class="leancloud_visitors" data-flag-title="【Java编程思想】对象导论">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、抽象过程"><a href="#一、抽象过程" class="headerlink" title="一、抽象过程"></a>一、抽象过程</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>1.万物皆为对象：</strong>理论上来说，我们可以抽取待解决问题中任何一个概念化的构件，将其描述成为程序中的一个对象。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.程序是对象的集合，它们通过发送消息来告知彼此需要做的事：</strong>通俗来讲，程序是一系列对象的集合体，程序之间的通信可以细分到对象与对象之间的通信，要想进行通信就需要发送消息。从程序的角度来说，消息传递这个过程可以理解为一个方法的调用与执行。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.每个对象都可以由其它对象组成：</strong>换句话说，对象之间可以进行组合，形成新的具有具体意义的对象。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.每个对象拥有其自己的类型：</strong>类型用来区分不同对象的特征，比如正方形有四条边，三角形有三条边，边的条数就可以用来区分二者。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>5.某一特定类型的所有对象，都可以接收同样的消息：</strong>也就是说，具有相同类型的一系列对象，它们具有的行为是相同的，因此它们可以接收/处理相同的消息。</p>
<p>&ensp;&ensp;&ensp;&ensp;对象具有行为、状态和标识，每一个对象都可以拥有内部数据和方法，数据用来表示对象的状态，方法用来产生特定的行为，每个对象有唯一的标识与其它对象区分。拥有相同类型的对象的集合称作类，也就是说我们创建的每一个对象，都来自一个类。</p>
<h1 id="二、每个对象都有一个接口"><a href="#二、每个对象都有一个接口" class="headerlink" title="二、每个对象都有一个接口"></a>二、每个对象都有一个接口</h1><p>&ensp;&ensp;&ensp;&ensp;对象之间进行消息传递时是通过接口来完成的，一个对象的接口暴露给另一个对象，接口对应内部的一个具体实现，具体实现表示特定的方法行为。</p>
<h1 id="三、每个对象都提供服务"><a href="#三、每个对象都提供服务" class="headerlink" title="三、每个对象都提供服务"></a>三、每个对象都提供服务</h1><p>&ensp;&ensp;&ensp;&ensp;我们拆分、抽取的每一个对象，都是具有实际业务意义的，它们都应该能够传递具体的消息，从而提供特定的服务。</p>
<h1 id="四、被隐藏的具体实现"><a href="#四、被隐藏的具体实现" class="headerlink" title="四、被隐藏的具体实现"></a>四、被隐藏的具体实现</h1><p>&ensp;&ensp;&ensp;&ensp;很多时候，我们将开发者分为两种，类创建者和客户端开发人员，所谓类创建者，可以理解为对象集合的构建者，客户端开发人员负责使用他们所创建的对象。有些时候，为了避免客户端开发者恶意修改类的功能，或者为了类在不断升级的过程中，能够更好地实现向下兼容，我们需要对客户端开发人员屏蔽一些他们用不到的且很关键的代码。这个屏蔽的过程叫做访问控制。</p>
<p>&ensp;&ensp;&ensp;&ensp;Java中提供了三个级别的访问控制，分别为public、protected、private。public顾名思义就是所有人可见。private就是只有类的创建者可见。protected介于二者之间，在由基类派生出的派生类中，可以访问派生类中被protected修饰的域，而不能访问private域，其它与private相同。具体的访问控制后文继续学习。</p>
<h1 id="五、复用具体实现"><a href="#五、复用具体实现" class="headerlink" title="五、复用具体实现"></a>五、复用具体实现</h1><p>&ensp;&ensp;&ensp;&ensp;有些时候我们需要使用一个现有的类完成特定的功能，但是又不能完成全部功能，那么我们就可以创建一个新的类，在这个类中引入先前的类的对象，并将其声明为private域，这样的话我们就可以使用这个对象的方法来完成一部分功能，然后在新类中创建新的属性和方法，并且在外人看来它就是一个新的类。这种“has-a”的关系我们称为组合。</p>
<h1 id="六、继承"><a href="#六、继承" class="headerlink" title="六、继承"></a>六、继承</h1><p>&ensp;&ensp;&ensp;&ensp;当我们创建一个类时，如果另一个新类与这个类功能相似，我们仍然需要创建这个新类。解决这个问题的办法就是继承。继承虽然也是一个新类，但是这个类是由基类（俗称父类）衍生的导出类（俗称子类）。子类拥有父类所有非private的对象、属性、接口，此外可以根据不同的需要增加不同的功能。父类可以有很多个子类，它包含了子类的所有公共部分。如“几何形”是父类，每一个几何形都具有尺寸、颜色、位置等，同时每一个几何形都可以被绘制、擦除和移动。在此基础上可以导出它的子类“三角形”、“平行四边形”等，他们拥有父类的属性、方法之外还有自己独特的属性，例如有的形状可以被翻转等。<br>​    子类不光继承了父类的属性，同时也继承了父类的方法，也就是说所有发给父类的消息，都可以发给子类。子类对接口的实现方法可以不改变，即访问子类的接口实际是与访问父类相同，当然也可以自己“覆盖”父类接口的方法，也就是说我和父类使用相同的接口，但是我们做不同的事情。同时如前边所说，子类也可以自己新增方法来满足自己的需求。前者不改变或者覆盖接口的方法，这种我们称作是“is-a”的关系，因为子类与父类本质的类型没有发生变化。而后边这种我们称作是“is-like-a”，因为在子类中增加了新的方法，所以这种相同的关系并不完全。</p>
<h1 id="七、伴随多态的可互换对象"><a href="#七、伴随多态的可互换对象" class="headerlink" title="七、伴随多态的可互换对象"></a>七、伴随多态的可互换对象</h1><p>&ensp;&ensp;&ensp;&ensp;我们说子类继承父类，同时继承了父类的方法，也就是说发给父类的消息同时能够发给子类。那么当我们把子类对象看成泛化的基类对象时，如果有个方法是让泛化的父类操作自己，那么编译器在编译时不知道该执行哪段代码的。一个非面向对象程序的函数调用是前期绑定，函数要执行的代码在程序运行之前就已经确定了，然而在面向对象中，直到程序执行我们才知道哪段代码被执行了。所以为了解决消息执行哪段代码的问题，Java使用了后期绑定的概念，使用一小段特殊的代码来代替非面向对象中所说的绝对地址调用，这段代码使用在对象中存储的信息来计算方法的地址。比如有个父类Shape和子类Circle、子类Triangle，父类中有如下方法    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Shape shape)</span></span>&#123;</span><br><span class="line">    shape.erase();</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">    shape.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法可以与任意Shape类型的对象交互，如果程序中有它的子类调用了该方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Circle circle = <span class="keyword">new</span> Circle();</span><br><span class="line">Triangle triangle = <span class="keyword">new</span> Triangle();</span><br><span class="line">cicle.doSomething();</span><br><span class="line">triangle.doSomething();</span><br></pre></td></tr></table></figure>
<h1 id="八、单根继承结构"><a href="#八、单根继承结构" class="headerlink" title="八、单根继承结构"></a>八、单根继承结构</h1><p>&ensp;&ensp;&ensp;&ensp;在Java语言中，所有的类都是Object类的子类，拥有着Object类的基本方法。这种单根继承结构有很大的好处，比如在垃圾回收中可以避免由于不知道对象的类型而无处下手，因为他们都可以使用Object类的方法，并且所有对象都可以很容易的在堆上创建。</p>
<h1 id="九、容器"><a href="#九、容器" class="headerlink" title="九、容器"></a>九、容器</h1><p>&ensp;&ensp;&ensp;&ensp;有时候我们并不知道处理一个问题需要多少个对象，或者他们需要存活多久，那么我们就不知道该怎么样存储这些对象。Java语言中创建了一种对象类型，叫做容器（也叫集合）。这种新的对象类型内部有对其他对象的引用，当你需要的时候你可以很容易的扩充容器的空间来容纳对象。Java中提供了多种容器类型，如List（用于存储序列）、Map（也被称为关联数组，用来建立对象的关联）、Set（每种对象类型只持有一个）。因为容器中存储了其他对象的引用，所以根据单根继承结构，容器中的对象类型都是Obejct类型，这样很方便其他对象类型进行转型。但是从Object类型转到其它特定类型（称作向下转型）很容易发生错误，所以Java SE5之后引入了泛型的概念，参数传递使用一对&lt;&gt;，&lt;&gt;内部可以传递任意类型的对象，这便解决了向下转型带来的安全隐患。</p>
<h1 id="十、对象的创建和生命周期"><a href="#十、对象的创建和生命周期" class="headerlink" title="十、对象的创建和生命周期"></a>十、对象的创建和生命周期</h1><p>&ensp;&ensp;&ensp;&ensp;对象的创建主要有两种，一种是在编程时由程序员控制，将对象置于栈中或者是静态区域，这种的好处是知道对象的大小、生命周期。同时也限制了对象的灵活性。另一种是通过new在内存堆中动态的创建对象，这种方式的好处是灵活，需要的时候直接在内存中创建即可，实现了存储空间的动态管理。Java中完全采用了动态内存的分配方式。</p>
<p>&ensp;&ensp;&ensp;&ensp;对于生命周期，栈上的生命周期，编译器可以知道它什么时候销毁，并自动回收。而在堆上创建的对象，必须由程序员自己指定回收时间，如果没有指定则会造成内存泄漏。Java中提供了垃圾回收机制，可以自动的回收在堆上创建的对象。    </p>
<h1 id="十一、异常处理：处理错误"><a href="#十一、异常处理：处理错误" class="headerlink" title="十一、异常处理：处理错误"></a>十一、异常处理：处理错误</h1><p>&ensp;&ensp;&ensp;&ensp;Java内置了异常处理机制，相当于一条与正确执行并行的路线，当程序发生异常时会执行异常的代码。同时，允许程序在异常中进行处理并返回到正确的结果中去。</p>
<h1 id="十二、并发编程"><a href="#十二、并发编程" class="headerlink" title="十二、并发编程"></a>十二、并发编程</h1><p>&ensp;&ensp;&ensp;&ensp;Java与其他语言一样，提供多线程的并发编程方式，提高程序运行效率。</p>
<h1 id="十三、Java与Internet"><a href="#十三、Java与Internet" class="headerlink" title="十三、Java与Internet"></a>十三、Java与Internet</h1><p>&ensp;&ensp;&ensp;&ensp;Java不仅可以编写客户端程序，还可以编写网络Web应用程序。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Crayon Cxy</p>
              <p class="site-description motion-element" itemprop="description">Go over the mountain, and they will hear your story.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.diosfun.com/" title="六脉神间" target="_blank">六脉神间</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/chenxyt" title="My CSDN" target="_blank">My CSDN</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Crayon Cxy</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("5L2kF0V7XFDR6a7wmWFyGC3Q-gzGzoHsz", "Cy1yzcQbLJV7TGUDEmRnvC9A");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
