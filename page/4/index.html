<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Go over the mountain, and they will hear your story.">
<meta property="og:type" content="website">
<meta property="og:title" content="Ordinary Road">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Ordinary Road">
<meta property="og:description" content="Go over the mountain, and they will hear your story.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ordinary Road">
<meta name="twitter:description" content="Go over the mountain, and they will hear your story.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/">





  <title>Ordinary Road</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ordinary Road</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/13/【Java编程思想】七：访问权限控制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crayon Cxy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ordinary Road">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/13/【Java编程思想】七：访问权限控制/" itemprop="url">【Java编程思想】七：访问权限控制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-13T14:06:48+08:00">
                2018-11-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/13/【Java编程思想】七：访问权限控制/" class="leancloud_visitors" data-flag-title="【Java编程思想】七：访问权限控制">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> &ensp;&ensp;&ensp;&ensp;一个优秀的程序员是通过不断的重构代码让自己的程序变得更加易用、可读和完善的。在重构修改的过程中，如果是一个类库编写人员，那么怎么样保证自己修改的部分不会影响到客户端编写人员（即使用这个类库的程序员）呢？同时也要避免他们对自己类库内部的程序进行改动。Java中提供了访问权限控制的概念，提供了三种不同级别的访问控制，访问开放程度由高到低依次为“public”、“protected”“private”，这样就能区分哪些内容是可用的，哪些内容是不可用的，从而将变动的事物与不变的事物区分开来。那么如何将所有的构建捆绑到一个内聚的类库单元中呢？Java提供了package加以控制，而访问权限控制的作用会因为类库是否在一个相同的package还是不同的package受到影响。</p>
<h1 id="一、包：库单元"><a href="#一、包：库单元" class="headerlink" title="一、包：库单元"></a>一、包：库单元</h1><p>&ensp;&ensp;&ensp;&ensp;包内包含一组类，它们在单一的名字空间下被组织在了一起。声明一个类所属的包使用package关键字，同时在另一个包中的类要访问其它包中的类使用import关键字导入要使用的包。这种方式可以在一定程度上避免重名的问题，因为包的名字要避免重名，而不同包内的类是可以根据具体的需求命相同的名字。包有效的将不同类的内容进行了隔离，同时也可以相互联系。<br>如下是com.chenxyt.java.test包中的Printer类，类中定义了一个print方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		System.out.println(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在另一个包com.chenxyt.java.practice中的PackageTest类，类中使用print方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> com.chenxyt.java.test.Printer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Printer printer = <span class="keyword">new</span> Printer();</span><br><span class="line">		printer.print(<span class="string">"This is Package Test"</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2018/11/13/【Java编程思想】七：访问权限控制/png1.png" alt="png1"></p>
<p>看一下程序的目录结构:</p>
<p><img src="/2018/11/13/【Java编程思想】七：访问权限控制/png2.png" alt="png2"></p>
<h1 id="二、Java访问权限修饰词"><a href="#二、Java访问权限修饰词" class="headerlink" title="二、Java访问权限修饰词"></a>二、Java访问权限修饰词</h1><p>&ensp;&ensp;&ensp;&ensp;public：所有可见，被public修饰的内容在同一个包中的所有类都可见。同时Java提供默认的访问权限，即不被任何修饰符修饰的内容默认为public权限。</p>
<p>&ensp;&ensp;&ensp;&ensp;private：私有可见，只有该类可见，该类的对象都不可见。如果一个类的构造函数被声明为private，那么就不能通过这个类的构造函数来进行初始化对象。</p>
<p>&ensp;&ensp;&ensp;&ensp;protected:受保护的可见，与private不同，除了只有自己的类可见之外，该类的继承者也可见被修饰的域。除此之外还可以被当前包的类访问，但是其它包的类不可以访问，即便是使用了import的关键字</p>
<p>访问权限控制对程序结构控制的重要手段。</p>
<h1 id="三、接口和实现"><a href="#三、接口和实现" class="headerlink" title="三、接口和实现"></a>三、接口和实现</h1><p>&ensp;&ensp;&ensp;&ensp;这里没有详细的介绍Java中的接口跟实现，主要是基于访问权限控制来说的。一般的类开发者，为了方便他人使用，会在具体方法实现外部建立一层接口，只提供接口给外部开发人员调用，而不提供具体实现的方法。</p>
<h1 id="四、类的访问权限"><a href="#四、类的访问权限" class="headerlink" title="四、类的访问权限"></a>四、类的访问权限</h1><p>&ensp;&ensp;&ensp;&ensp;在Java中，访问权限控制也可以确定包中的哪些类可以被访问，也就是说可以用来修饰类，一个文件中最多只能有一个使用public修饰的类。如果希望客户端程序员使用该类，并可以创建对象，那么就可以将该类修饰为public。并且被修饰为public的类必须要与该文件的名字完全相同</p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>&ensp;&ensp;&ensp;&ensp;本章主要学习的是Java中的三种访问权限，熟练的掌握public、private和protected三种类型的概念以及应用场景将能更好的提高程序的健壮性和稳定性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/13/【Java编程思想】六：初始化与清理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crayon Cxy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ordinary Road">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/13/【Java编程思想】六：初始化与清理/" itemprop="url">【Java编程思想】六：初始化与清理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-13T10:53:40+08:00">
                2018-11-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/13/【Java编程思想】六：初始化与清理/" class="leancloud_visitors" data-flag-title="【Java编程思想】六：初始化与清理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、用构造器确保初始化"><a href="#一、用构造器确保初始化" class="headerlink" title="一、用构造器确保初始化"></a>一、用构造器确保初始化</h1><p>&ensp;&ensp;&ensp;&ensp;Java中通过提供构造器，确保每个类的对象都可以得到初始化，构造器的形式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">className（）&#123;</span><br><span class="line">    <span class="comment">//---</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;在类的内部定义的一个与类名相同的方法，该方法没有返回值，没有返回值并不是返回void，而是真正的无返回值。该方法在对象创建时会自动执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorTest</span></span>&#123;</span><br><span class="line">	ConstructorTest()&#123;</span><br><span class="line">		System.out.println(<span class="string">"Constructor Begin"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">			ConstructorTest ct = <span class="keyword">new</span> ConstructorTest();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="/2018/11/13/【Java编程思想】六：初始化与清理/png1.png" alt="png1"></p>
<p>可以看见程序在初始化对象的时候自动执行了构造方法。</p>
<p>&ensp;&ensp;&ensp;&ensp;上面是无参的构造方法，还可以显示的编写有参的构造方法，给类的成员变量赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorTest</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	ConstructorTest(<span class="keyword">int</span> i)&#123;</span><br><span class="line">		age=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">			ConstructorTest ct = <span class="keyword">new</span> ConstructorTest(i);</span><br><span class="line">			System.out.println(<span class="string">"Age="</span> + ct.age);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/13/【Java编程思想】六：初始化与清理/png2.png" alt="png2"></p>
<p>&ensp;&ensp;&ensp;&ensp;如果类中只有唯一的一个带参数的构造器，那么默认的无参构造器将不可用。</p>
<h1 id="二、方法重载"><a href="#二、方法重载" class="headerlink" title="二、方法重载"></a>二、方法重载</h1><p>&ensp;&ensp;&ensp;&ensp;如果我们需求多种多样，既需要无参构造器，又需要有参构造器，我们可不可以把这两个方法都写出来呢？答案是肯定的，对于这种方法名相同，方法参数不同的写法，称作是重载。方法重载不仅支持构造器重载，也支持普通方法重载：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorTest</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	ConstructorTest()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	ConstructorTest(<span class="keyword">int</span> i)&#123;</span><br><span class="line">		age=i;</span><br><span class="line">	&#125;</span><br><span class="line">	ConstructorTest(String j)&#123;</span><br><span class="line">		name=j;</span><br><span class="line">	&#125;</span><br><span class="line">	ConstructorTest(<span class="keyword">int</span> i,String j)&#123;</span><br><span class="line">		age=i;</span><br><span class="line">		name=j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ConstructorTest ct1 = <span class="keyword">new</span> ConstructorTest();</span><br><span class="line">		ConstructorTest ct2 = <span class="keyword">new</span> ConstructorTest(<span class="number">22</span>);</span><br><span class="line">		ConstructorTest ct3 = <span class="keyword">new</span> ConstructorTest(<span class="string">"张三"</span>);</span><br><span class="line">		ConstructorTest ct4 = <span class="keyword">new</span> ConstructorTest(<span class="number">23</span>,<span class="string">"李四"</span>);</span><br><span class="line">		System.out.println(<span class="string">"ct1 age="</span> + ct1.age + <span class="string">"---name="</span> + ct1.name);</span><br><span class="line">		System.out.println(<span class="string">"ct2 age="</span> + ct2.age + <span class="string">"---name="</span> + ct2.name);</span><br><span class="line">		System.out.println(<span class="string">"ct3 age="</span> + ct3.age + <span class="string">"---name="</span> + ct3.name);</span><br><span class="line">		System.out.println(<span class="string">"ct4 age="</span> + ct4.age + <span class="string">"---name="</span> + ct4.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="/2018/11/13/【Java编程思想】六：初始化与清理/png3.png" alt="png3"></p>
<p>&ensp;&ensp;&ensp;&ensp;四个不同的构造函数初始化了四个不同的对象，可以从打印结果看出，没有初始化的值int类型为0，String类型为null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"int 类型打印"</span> + i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String j)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"String 类型打印"</span> + j);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ConstructorTest.print(<span class="number">22</span>);</span><br><span class="line">		ConstructorTest.print(<span class="string">"张三"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;普通方法的重载最明显的使用就是println（）方法，我们要保证打印任何内容都使用println（）方法，而不是打印int类型用一个方法printint（），然后打印String类型用一个方法printString（），这时候方法重载是最好的办法。</p>
<p><img src="/2018/11/13/【Java编程思想】六：初始化与清理/png4.png" alt="png4"></p>
<p>如上结果显示了两个重载方法的不同结果。</p>
<p>&ensp;&ensp;&ensp;&ensp;重载方法中如果传入了低类型的参数，那么如果找不到合适的方法，会被隐式的提升成高类型的数据。如果传入了高类型的参数，如果不进行类型转换，那么编译器会报错。Java中区分重载方法的依据是参数类型和参数个数，参数顺序区分会造成程序易读性较差，在一些情况下，也可以使用返回值区分，当然前提是如果你关心方法的返回值。</p>
<h1 id="三、缺省构造器"><a href="#三、缺省构造器" class="headerlink" title="三、缺省构造器"></a>三、缺省构造器</h1><p>&ensp;&ensp;&ensp;&ensp;如前文所述，默认的构造器，就是没有形参的构造器，作为一个类的缺省构造器。如果程序员没有显示的在代码中创建一个构造器，那么Java会自动帮你创建一个无参构造器来完成初始化。当然如果程序员显示的创建了构造函数，那么Java就不会给你创建缺省构造器了</p>
<h1 id="四、this关键字"><a href="#四、this关键字" class="headerlink" title="四、this关键字"></a>四、this关键字</h1><p>&ensp;&ensp;&ensp;&ensp;this关键字也是Java中尤为重要的一个关键字，主要有三个作用：</p>
<p>&ensp;&ensp;&ensp;&ensp;1.表示当前对象的引用，并返回当前对象，用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ThisTest <span class="title">doFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThisTest tt = <span class="keyword">new</span> ThisTest().doFunc();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doFunc（）方法返回的是一个ThisTest类型的值，所以此处使用return this，返回了该类型对象的引用。</p>
<p>&ensp;&ensp;&ensp;&ensp;2.表示类的成员变量，在有的构造函数中，形参与成员变量使用同一个字符串，这时候可以用this来区分，带有this的表示成员变量，用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisTest</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String arg;</span><br><span class="line">	ThisTest(String arg)&#123;</span><br><span class="line">		<span class="keyword">this</span>.arg = arg;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThisTest tt = <span class="keyword">new</span> ThisTest(<span class="string">"嘻嘻"</span>);</span><br><span class="line">		System.out.println(tt.arg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/13/【Java编程思想】六：初始化与清理/png5.png" alt="png5"></p>
<p>此处this.arg表明了这个变量是成员变量，与构造方法的形参做了区分。</p>
<p>&ensp;&ensp;&ensp;&ensp;3.可以在构造器中调用另一个构造器，使用this带参数代替构造器的方法名，用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisTest</span></span>&#123;</span><br><span class="line">	ThisTest(<span class="keyword">int</span> i,String j)&#123;</span><br><span class="line">		<span class="keyword">this</span>(j);</span><br><span class="line">		System.out.println(<span class="string">"我是构造器1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ThisTest(String arg)&#123;</span><br><span class="line">		System.out.println(<span class="string">"我是构造器2"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThisTest tt = <span class="keyword">new</span> ThisTest(<span class="number">2</span>,<span class="string">"嘻嘻"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="/2018/11/13/【Java编程思想】六：初始化与清理/png6.png" alt="png6"></p>
<p>&ensp;&ensp;&ensp;&ensp;可以看到对象在初始化的时候使用了两个构造器，其中一个构造器是在另一个构造器中通过this（）的方式进行了调用。</p>
<h1 id="五、清理：终结处理和垃圾回收"><a href="#五、清理：终结处理和垃圾回收" class="headerlink" title="五、清理：终结处理和垃圾回收"></a>五、清理：终结处理和垃圾回收</h1><p>&ensp;&ensp;&ensp;&ensp;Java中的内存清理使用的是Java自带的垃圾回收机制，但是不管怎么来说，这种方式都不是绝对安全的。Java的垃圾回收机制清理的是通过new创建的对象，而在某些特殊情况下，可能有些对象不是通过new创建的，这些对象如果不使用的时候，垃圾回收器是不能准确的清理他们的从而造成了这块特殊的内存区域一直得不到释放。Java中提供了finalize()方法来处理这一部分特殊的内存区域。它的处理流程是这样的，在Java垃圾回收器启用之前，会先调用这个方法进行一些必要的回收操作。但是针对这一块特殊的区域，或者是new创建的需要被回收的对象，一般情况下只有当Java虚拟机内存快要消耗殆尽的时候，垃圾回收器才会启动，毕竟启动垃圾回收器也是需要消耗资源的，所以不可能说实时存在。所说的特殊的创建对象方式，一般是指“本地方法”使用时，也就是在Java中调用非Java代码的时候发生的。所以一般情况下是不需要使用finalize（）方法的。</p>
<p>&ensp;&ensp;&ensp;&ensp;finalize（）通常还有另一个用法，由于它是在Java垃圾回收器启动之前执行的，所以可以用它来判断终结状态，即判断一个对象是否满足回收条件。</p>
<h1 id="六、成员初始化"><a href="#六、成员初始化" class="headerlink" title="六、成员初始化"></a>六、成员初始化</h1><p>&ensp;&ensp;&ensp;&ensp;Java尽量保证每个变量在使用之前都进行了初始化操作，变量分为局部变量和成员变量，局部变量如果没有显示的初始化，在使用它的时候会报错，而成员变量不会，如果没有显示的初始化一个成员变量，那么它会被默认的分配一个指定的值。</p>
<h1 id="七、构造器初始化"><a href="#七、构造器初始化" class="headerlink" title="七、构造器初始化"></a>七、构造器初始化</h1><p>&ensp;&ensp;&ensp;&ensp;如前边对构造器的阐述，可以使用构造器来初始化类的成员变量，当对象被实例化之后，对象的成员变量会被初始化。静态成员变量只有在第一次使用它是才会被初始化，后边再次用到时不会被初始化。初始化顺序为创建对象时，先初始化这个类的静态变量，然后在堆上为这个对象分配内存，最后执行构造函数。</p>
<h1 id="八、数组初始化"><a href="#八、数组初始化" class="headerlink" title="八、数组初始化"></a>八、数组初始化</h1><p>&ensp;&ensp;&ensp;&ensp;数据是一系列相同数据类型封装起来的序列，它的初始化可以发生在任何时候，int[] a1表示一个int类型的数组，这个数组内部所有的值都是int类型，a1只是这个数组的一个引用，可以显示的通过如int[] a1={1，2，3};的形式进行初始化。如果不能确定数组的内容或者是长度，则可以通过new的形式来创建一个数组。int[] a = new int[20];这种创建也只是创建了一个引用数组，直到数组中的每一个字段都有确切的值了，初始化才真正的完成。如a[1]=3;</p>
<p>&ensp;&ensp;&ensp;&ensp;使用数组我们可以构建一个变参的函数，就是当方法的参数类型和个数都不确定的时候，我们可以使用一个数组作为形参。因为Object类是所有类型的父类，所以这个形参数组的类型就是Obejct类，对于基本数据类型，因为都有对应的包装类，所以也可以转换成Obejct类进行使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DifArgTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(Object[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(Object obj:args)&#123;</span><br><span class="line">			System.out.print(obj + <span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		DifArgTest.printArray(<span class="keyword">new</span> Object[]&#123;<span class="string">"我今年"</span>,<span class="keyword">new</span> Integer(<span class="number">24</span>),<span class="string">"岁！"</span>&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/13/【Java编程思想】六：初始化与清理/png7.png" alt="png7"></p>
<p>&ensp;&ensp;&ensp;&ensp;可以看到printArray（）方法将Obejct的数组内容都打印了出来。但是这样传参数是要写成数组的形式，未免有些臃肿。JDK1.5之后真正的变参函数出来啦。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DifArgTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(Object...args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(Object obj:args)&#123;</span><br><span class="line">			System.out.print(obj + <span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		DifArgTest.printArray(<span class="string">"我"</span>,<span class="string">"今年"</span>,<span class="number">24</span>,<span class="string">"岁"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;用“…”代替了原有的数组符号，同时传递的参数也变得更加简洁了。运行结果：</p>
<p><img src="/2018/11/13/【Java编程思想】六：初始化与清理/png8.png" alt="png8"></p>
<h1 id="九、枚举类型"><a href="#九、枚举类型" class="headerlink" title="九、枚举类型"></a>九、枚举类型</h1><p>&ensp;&ensp;&ensp;&ensp;这里只是初步的了解一下枚举类型，enum，Java中的enum要比C++更加完备。以下是一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumTest</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">enum</span> EnumSet&#123;</span><br><span class="line">		FIRST,SECOND,THIRD</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		EnumSet es = EnumSet.FIRST;</span><br><span class="line">		System.out.println(es);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;创建一个枚举类型，类型内部的实例值是常量，因此按照通用的命名规范进行大写。同时需要使用枚举时，可以初始化一个引用然后进行赋值。结果如下：</p>
<p><img src="/2018/11/13/【Java编程思想】六：初始化与清理/png9.png" alt="png9"></p>
<p>&ensp;&ensp;&ensp;&ensp;当我们创建枚举的时候编译器会自动为我们添加一些有用的特性，我觉得这是与其它语言相比更加完备的地方，比如它会创建一个toString（）方法，这也就是为什么我们上边可以使用syso打印出来。编译器还会创建ordinal（）方法，用来表示特定enum常量的声明顺序，以及一个static values（）方法，该方法是一个静态的方法可以通过enum名字进行访问，方法的作用是按照enmu的声明顺序，产生一个由enum常量值组成的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumTest</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">enum</span> EnumSet&#123;</span><br><span class="line">		FIRST,SECOND,THIRD</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(EnumSet et:EnumSet.values())&#123;</span><br><span class="line">			System.out.println(<span class="string">"value is:"</span> + et + <span class="string">"---ordinal is:"</span> + et.ordinal());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="/2018/11/13/【Java编程思想】六：初始化与清理/png10.png" alt="png10"></p>
<p>&ensp;&ensp;&ensp;&ensp;enum看起来像是一种新的数据类型，但是实际上enum是一个类，并且具有自己的方法。</p>
<p>&ensp;&ensp;&ensp;&ensp;除了上边的特性之外，enum还有个更加实用的特性，由于它是一个常量集，因此可以和switch语句完美匹配：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumTest</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> EnumSet es;</span><br><span class="line">	EnumTest(EnumSet es)&#123;</span><br><span class="line">		<span class="keyword">this</span>.es = es;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">enum</span> EnumSet&#123;</span><br><span class="line">		FIRST,SECOND,THIRD</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSwitchPrint</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">switch</span>(es)&#123;</span><br><span class="line">		<span class="keyword">case</span> FIRST:</span><br><span class="line">			System.out.println(<span class="string">"This is First"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SECOND:</span><br><span class="line">			System.out.println(<span class="string">"This is Second"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> THIRD:</span><br><span class="line">			System.out.println(<span class="string">"This is Third"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			System.out.println(<span class="string">"This is Error"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		EnumTest et1 = <span class="keyword">new</span> EnumTest(EnumSet.FIRST);</span><br><span class="line">		EnumTest et2 = <span class="keyword">new</span> EnumTest(EnumSet.SECOND);</span><br><span class="line">		EnumTest et3 = <span class="keyword">new</span> EnumTest(EnumSet.THIRD);</span><br><span class="line">		et1.doSwitchPrint();</span><br><span class="line">		et2.doSwitchPrint();</span><br><span class="line">		et3.doSwitchPrint();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="/2018/11/13/【Java编程思想】六：初始化与清理/png11.png" alt="png11"></p>
<p>&ensp;&ensp;&ensp;&ensp;以上是对enum的一个初步了解，后续将会单独阐述。</p>
<h1 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h1><p>&ensp;&ensp;&ensp;&ensp;本章在Java中占有了至关重要的作用，也可以说初始化比较重要。总的来说要掌握如何进行初始化，方法的重载，重载不仅发生在构造方法中，也可以发生在普通方法。this关键的使用可以说很重要，但是便于理解。垃圾回收以及枚举只是初步的了解了一下，后续还会单独进行学习。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/13/【Java编程思想】五：控制执行流程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crayon Cxy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ordinary Road">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/13/【Java编程思想】五：控制执行流程/" itemprop="url">【Java编程思想】五：控制执行流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-13T09:48:20+08:00">
                2018-11-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/13/【Java编程思想】五：控制执行流程/" class="leancloud_visitors" data-flag-title="【Java编程思想】五：控制执行流程">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、true和false"><a href="#一、true和false" class="headerlink" title="一、true和false"></a>一、true和false</h1><p>&ensp;&ensp;&ensp;&ensp;关系操作符构造的条件语句如“==”的返回值是true和false，Java中不允许将一个数字作为布尔值使用。</p>
<h1 id="二、if-else"><a href="#二、if-else" class="headerlink" title="二、if-else"></a>二、if-else</h1><p>&ensp;&ensp;&ensp;&ensp;if else语句与其它语言的相同，其中else是可选的。if else用来实现多种条件下的执行。</p>
<h1 id="三、迭代"><a href="#三、迭代" class="headerlink" title="三、迭代"></a>三、迭代</h1><p>&ensp;&ensp;&ensp;&ensp;while、do-while、for用来控制循环，有时候将他们称为迭代语句。语句会重复执行，直到起控制作用的布尔值得到“假”的结果时停止</p>
<h1 id="四、for-each"><a href="#四、for-each" class="headerlink" title="四、for-each"></a>四、for-each</h1><p>&ensp;&ensp;&ensp;&ensp;for-each是一种更加简洁的for语句，语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i:x)&#123;</span><br><span class="line">    <span class="comment">//---</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;x是要被访问的循环体，i是一个变量，类型int只是一种，具体的类型要与x内部的值的类型相同，这个语句的意思就是循环取x内部的值赋值给i</p>
<h1 id="五、return"><a href="#五、return" class="headerlink" title="五、return"></a>五、return</h1><p>&ensp;&ensp;&ensp;&ensp;return关键字有两个用途，一方面指定一个方法返回什么值，另一方面它会强制结束当前方法，并返回那个值。</p>
<h1 id="六、break和continue"><a href="#六、break和continue" class="headerlink" title="六、break和continue"></a>六、break和continue</h1><p>&ensp;&ensp;&ensp;&ensp;在任何迭代语句的主体部分，都可以用break和continue控制循环的流程，其中break用于强制退出循环，不执行循环剩余的语句，比如一共五组数据循环到第三组break，那么后面两组不管了继续执行下边的数据。continue是停止当前的迭代，退到循环开始执行下一次迭代，比如一共五组数据执行到第三组开始的时候continue，那么这个循环体主体剩余的部分不执行，继续从第四组开始执行。</p>
<h1 id="七、臭名昭著的go-to"><a href="#七、臭名昭著的go-to" class="headerlink" title="七、臭名昭著的go-to"></a>七、臭名昭著的go-to</h1><p>&ensp;&ensp;&ensp;&ensp;go-to语句会破坏代码的逻辑结构，降低代码的可读性。因此不建议使用。</p>
<h1 id="八、switch"><a href="#八、switch" class="headerlink" title="八、switch"></a>八、switch</h1><p> &ensp;&ensp;&ensp;&ensp;switch也被划为一种选择语句，根据整数表达式的值，从一系列语句中选择一组执行。语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(a)&#123;</span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">       <span class="comment">//---;</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2:</span><br><span class="line">        <span class="comment">//---;</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//---;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h1><p>&ensp;&ensp;&ensp;&ensp;文中多数控制语句在其它语言中都通用，注意for-each语句的使用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/12/【Java编程思想】四：操作符/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crayon Cxy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ordinary Road">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/12/【Java编程思想】四：操作符/" itemprop="url">【Java编程思想】四：操作符</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-12T10:30:31+08:00">
                2018-11-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/12/【Java编程思想】四：操作符/" class="leancloud_visitors" data-flag-title="【Java编程思想】四：操作符">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、更简单的打印语句"><a href="#一、更简单的打印语句" class="headerlink" title="一、更简单的打印语句"></a>一、更简单的打印语句</h1><p>&ensp;&ensp;&ensp;&ensp;在第二章中使用了一个打印语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Hello World"</span>);</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;结合static的静态包用法，如果这个语句在多个地方进行调用，那么可以将这个语句写成静态方法，然后通过导入静态包的形式使用静态方法：</p>
<p>test包下的Printer类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		System.out.println(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>practice包下的TestStatic类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.chenxyt.java.test.Printer.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		print(<span class="string">"This is TestStatic"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、使用Java操作符"><a href="#二、使用Java操作符" class="headerlink" title="二、使用Java操作符"></a>二、使用Java操作符</h1><p>&ensp;&ensp;&ensp;&ensp;Java与其他语言一样，支持加号，正号，减号，负号，乘除号等操作符，同时“=”，“==”和“！=”不光可以操作基本操作类型，还可以操作所有的对象。此外，String类支持“+”和“+=”。</p>
<h1 id="三、优先级"><a href="#三、优先级" class="headerlink" title="三、优先级"></a>三、优先级</h1><p>&ensp;&ensp;&ensp;&ensp;当一个表达式中存在多个操作符时，操作符的优先级就尤为重要了，它决定了程序运算操作执行的先后顺序。Java中的计算顺序与其它语言的基本相同，先计算乘除，再计算加减，有括号的先计算括号里边的。System.out.println()语句中包含“+”的操作符号，简单的只是进行字符串的连接，复杂一点的就是当编译器发现“+”前边是一个String类型，会尝试将“+”后面的内容转换成String类型。</p>
<h1 id="四、赋值"><a href="#四、赋值" class="headerlink" title="四、赋值"></a>四、赋值</h1><p>&ensp;&ensp;&ensp;&ensp;赋值操作使用的是“=”操作符，将“=”右边的值赋给左边，右值可以是任意的常数、变量或者是表达式，只有它能生成一个值即可，而左值必须是一个明确的已命名的变量，就是必须要有个物理空间来进行存储。比如，可以将一个常数赋给变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>但是却不能将一个变量赋值给一个常数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>=a;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;对于基本的数据类型，赋值操作没有引用的涉及，只是单纯的将一个值赋值给另一个值。例如a=b，当b再次被修改时，a不会受到影响，因为a与b相互独立。但是对于对对象的赋值来说，情况却大大不同，因为我们对对象的操作是操作了对象的引用，所以当一个对象赋值给另一个对象时，实际上是拷贝了引用到左值，也就是比如c和d是指向两个不同对象的引用，当c=d时，实际发生的情况是c和d都指向了原本只有d指向的对象。而c被赋值之后，原来的引用丢失了，它曾经所指向的不再被引用的对象被垃圾回收器回收了。如下例子创建了两个不同的对象，进行赋值操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tank</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> level;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Tank tk1 = <span class="keyword">new</span> Tank();</span><br><span class="line">		Tank tk2 = <span class="keyword">new</span> Tank();</span><br><span class="line">		tk1.level = <span class="number">2</span>;</span><br><span class="line">		tk2.level = <span class="number">3</span>;</span><br><span class="line">		System.out.println(<span class="string">"tk1.level = "</span> + tk1.level + <span class="string">"---tk2.level = "</span> + tk2.level);</span><br><span class="line">		tk1=tk2;</span><br><span class="line">		System.out.println(<span class="string">"tk1.level = "</span> + tk1.level + <span class="string">"---tk2.level = "</span> + tk2.level);</span><br><span class="line">		tk2.level=<span class="number">5</span>;</span><br><span class="line">		System.out.println(<span class="string">"tk1.level = "</span> + tk1.level + <span class="string">"---tk2.level = "</span> + tk2.level);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="/2018/11/12/【Java编程思想】四：操作符/png1.png" alt="png1"></p>
<p>&ensp;&ensp;&ensp;&ensp;tk1和tk2分别是两个独立的对象，它们内部有level属性，赋值之前两个对象的属性值不同，赋值操作完成之后两个对象的属性值相同，当再次更改对象tk2的level值时，预期的理想情况是不会影响tk1的值，但实际结果并非如此，tk1与tk2对象的属性相同，这与前面的分析结果相同。<br>&ensp;&ensp;&ensp;&ensp;Java中这种针对对象的特殊现象叫做“<strong>别名现象</strong>”，如果想避免这种现象的话，可以使用如下操作，赋值操作针对属性而不是对象的引用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tk1.level=tk2.level</span><br></pre></td></tr></table></figure>
<p>这样操作就可以保持两个对象本身相互独立。</p>
<p>&ensp;&ensp;&ensp;&ensp;在调用方法传参的时候也是会产生“别名问题”，如下例子，调用方法copy之后，理想的是只改变了方法内的值，实际上是改变了方法之外对象的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tank</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> level;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(Tank tk3)</span></span>&#123;</span><br><span class="line">		tk3.level = <span class="number">9</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Tank tk1 = <span class="keyword">new</span> Tank();</span><br><span class="line">		tk1.level = <span class="number">2</span>;</span><br><span class="line">		System.out.println(<span class="string">"tk1.level = "</span> + tk1.level);</span><br><span class="line">		copy(tk1);</span><br><span class="line">		System.out.println(<span class="string">"tk1.level = "</span> + tk1.level);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果，方法外部tk1对象的值被修改了</p>
<p><img src="/2018/11/12/【Java编程思想】四：操作符/png2.png" alt="png2"></p>
<h1 id="五、算术操作符"><a href="#五、算术操作符" class="headerlink" title="五、算术操作符"></a>五、算术操作符</h1><p>&ensp;&ensp;&ensp;&ensp;Java中的算术操作符与其它语言基本类似，有加号（+）、减号（-）、乘号（*）、取整（/）、取余（%），同时也具有简化运算符的功能如要将x加4之后再赋值给x，则可以写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x+=<span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<h1 id="六、自动递增递减"><a href="#六、自动递增递减" class="headerlink" title="六、自动递增递减"></a>六、自动递增递减</h1><p>&ensp;&ensp;&ensp;&ensp;Java中的递增递减操作与其它语言基本类似，递增符合（++），递减符合（–），操作目的是快速使一个整数加1或者减1如a++等同于a=a+1，这两种符号分别有两种使用方式称为“前缀式”和“后缀式”，前缀式意味着符号在变量前边，后缀式意味着符号在变量后边。二者的区别，对于前缀式是先做运算再取值，如a=1，b=++a，此时a跟b的值都是2，而后缀式则是先取值再做运算，如a=1，b=a++，此时b的值为1，a的值为2</p>
<h1 id="七、关系操作符"><a href="#七、关系操作符" class="headerlink" title="七、关系操作符"></a>七、关系操作符</h1><p>&ensp;&ensp;&ensp;&ensp;关系操作符生成的是一个boolean（布尔）结果，它们计算操作数之间的关系，如果关系为真则结果为true，如果关系为假则结果为false。关系操作符号包括小于（＜）、大于（＞）、小于等于（＜=）、大于等于（＞＝）、等于（==）以及不等于（！=）。等于和不等于适用于所有的基本数据类型，而其它的操作符不适用于boolean类型，因为它们的值为true或者false，比较大小没有意义。<br>操作符“==”和“！=”同样适用于操作对象，但是与基本操作类型相比有一些不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Integer itg1 = <span class="keyword">new</span> Integer(<span class="number">22</span>);</span><br><span class="line">		Integer itg2 = <span class="keyword">new</span> Integer(<span class="number">22</span>);</span><br><span class="line">		System.out.println(itg1==itg2);</span><br><span class="line">		System.out.println(itg1!=itg2);</span><br><span class="line">		<span class="keyword">int</span> int1 = <span class="number">22</span>;</span><br><span class="line">		<span class="keyword">int</span> int2 = <span class="number">22</span>;</span><br><span class="line">		System.out.println(int1==int2);</span><br><span class="line">		System.out.println(int1!=int2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上创建了两个Integer对象和两个int基本数据类型值，分别做“==”和“！=”判断，结果如下：</p>
<p><img src="/2018/11/12/【Java编程思想】四：操作符/png3.png" alt="png3"></p>
<p>&ensp;&ensp;&ensp;&ensp;从结果可见，两个对象是“！=”，而两个int基本数据类型值是“==”，这是为什么呢？因为对于对象来说，“==”和“！=”比较的是对象的引用，虽然这两个对象的值相同，但是他们对象的引用并不是一个，也就是他们在内存中有两个不同的存储位置，所以不相同。所以要想比较对象的值是否相同，我们可以使用对象的equals（）方法来进行比较，它是Object类的一个通用方法，第一章中说到过所有类的父类都是Object，因此任何类的对象都可以调用这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Integer itg1 = <span class="keyword">new</span> Integer(<span class="number">22</span>);</span><br><span class="line">		Integer itg2 = <span class="keyword">new</span> Integer(<span class="number">22</span>);</span><br><span class="line">		System.out.println(itg1.equals(itg2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2018/11/12/【Java编程思想】四：操作符/png4.png" alt="png4"></p>
<p>&ensp;&ensp;&ensp;&ensp;新的问题来了，我们看如下示例，我们自定义了一个新的类，创建了两个对象进行比较：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Oper</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Oper op1 = <span class="keyword">new</span> Oper();</span><br><span class="line">		Oper op2 = <span class="keyword">new</span> Oper();</span><br><span class="line">		op1.i=<span class="number">2</span>;</span><br><span class="line">		op2.i=<span class="number">2</span>;</span><br><span class="line">		System.out.println(op1.equals(op2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2018/11/12/【Java编程思想】四：操作符/png5.png" alt="png5"></p>
<p>&ensp;&ensp;&ensp;&ensp;结果仍然为fasle！这是为什么呢？这是因为Object类中equals（）方法实际上是比较两个引用是否相同，就是它与“==”的本质效果是一样的，但是在第一个示例中的Integer类中，Java覆盖了这个方法，方法内容判断两个对象的类型是否相同以及值是否相同即可。而我们自己创建的Oper类并没有覆盖这个方法，所以沿用的还是Object类的方法。常见的String类也是覆盖了equals（）方法，效果与Integer类的对象相同。</p>
<h1 id="八、逻辑操作符"><a href="#八、逻辑操作符" class="headerlink" title="八、逻辑操作符"></a>八、逻辑操作符</h1><p>&ensp;&ensp;&ensp;&ensp;Java中的逻辑操作符与其它语言基本类似，包括与（&amp;&amp;）、或（||）、非（！），不同的是Java中的逻辑操作符只能应用与布尔值之间或者是表达式结果为布尔值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">		System.out.println((a&gt;b)&amp;&amp;(b&gt;c));</span><br><span class="line">		System.out.println((a&gt;b)||(b&lt;c));</span><br><span class="line">		System.out.println(!(a&lt;b));		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="/2018/11/12/【Java编程思想】四：操作符/png6.png" alt="png6"></p>
<p>&ensp;&ensp;&ensp;&ensp;逻辑运算满足如下关系，“&amp;&amp;”逻辑与运算符必须两边同时为真则结果为真，否则为假。“||”逻辑或运算符只要有一边为真则结果为真，“！”非运算符取对应值的对立面，即非真则假。对于逻辑与和逻辑或运算还有个名词叫做<strong>短路</strong>，即当两个算式做逻辑与运算时，如果左边第一个算式为假，则显然这个逻辑表达式最后的结果一定为假，那么就没有必要进行下边的表达式计算，直接结束运算，这个过程称作短路。</p>
<h1 id="九、直接常量"><a href="#九、直接常量" class="headerlink" title="九、直接常量"></a>九、直接常量</h1><p>&ensp;&ensp;&ensp;&ensp;Java中同样可以使用例如“π”这种常量表示。</p>
<h1 id="十、按位操作符"><a href="#十、按位操作符" class="headerlink" title="十、按位操作符"></a>十、按位操作符</h1><p>&ensp;&ensp;&ensp;&ensp;Java中的按位操作符与其他语言基本相似，有按位与（&amp;）、按位或（|）、按位异或（^）和按位非（~）操作符。它们针对基本数据类型的一个比特位（bit）进行运算。运算规则如下，&amp;操作符必须同时为1才为1，|操作符只有同时为0时才为0，^操作符只要有一个为1就为1，~是单目运算符，取反，若值为1则结果为0，反之为1。按位操作符除了~还可以与“=”合起来使用，如&amp;=或者|=、^=。<br>对于布尔值，同样可以进行按位与、按位或和按位异或运算，但是不能进行按位非运算，并且他们不会被短路，不管第一个表达式结果是什么，都会继续运算下去。</p>
<h1 id="十一、移位操作符"><a href="#十一、移位操作符" class="headerlink" title="十一、移位操作符"></a>十一、移位操作符</h1><p>&ensp;&ensp;&ensp;&ensp;移位操作符操作的也是二进制的“位”，移位操作符只能用来处理整数类型。移位操作也是二元操作符，一共有三种，左移操作符（&lt;&lt;），右移操作符（&gt;&gt;），无符号右移操作符（&gt;&gt;&gt;），左移操作符是操作符左边的数向左移动操作符右边指定的位数，<strong>低位补0</strong>，右移操作符是操作符左边的数向右移动操作符右边指定的位数，其中<strong>正数高位补0，负数高位补1</strong>。无符号右移操作符是Java独有的一种，<strong>即不管正数还是负数，右移之后高位都补0</strong>。关于移位操作有两点说明，一是高位指的是左边的位，二是对于int类型，最大长度为32位，对于long类型最大长度为64位。移位示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">6297</span>;</span><br><span class="line">		<span class="keyword">int</span> b = -<span class="number">6297</span>;</span><br><span class="line">		System.out.println(Integer.toBinaryString(a));</span><br><span class="line">		System.out.println(Integer.toBinaryString(b));</span><br><span class="line">		System.out.println(Integer.toBinaryString(a&gt;&gt;<span class="number">5</span>));</span><br><span class="line">		System.out.println(Integer.toBinaryString(a&lt;&lt;<span class="number">5</span>));</span><br><span class="line">		System.out.println(Integer.toBinaryString(a&gt;&gt;&gt;<span class="number">5</span>));</span><br><span class="line">		System.out.println(Integer.toBinaryString(b&gt;&gt;<span class="number">5</span>));</span><br><span class="line">		System.out.println(Integer.toBinaryString(b&lt;&lt;<span class="number">5</span>));</span><br><span class="line">		System.out.println(Integer.toBinaryString(b&gt;&gt;&gt;<span class="number">5</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;我们以int类型6297为例，分别对正6297和负6297做三种位移操作，结果如下：</p>
<p><img src="/2018/11/12/【Java编程思想】四：操作符/png7.png" alt="png7"></p>
<p>满足前边所说，左移低位补0，右移正数高位补0，低位补1，因为高位0没有实际意义，所以没有写出。同时，因为数据类型为int类型，所以最大长度为32位，超出的部分被截断了。</p>
<p>&ensp;&ensp;&ensp;&ensp;如果对char、short、byte类型的数值进行移位处理，那么他们会被先转成int类型，并且得到的结果也只是int类型。只有数值右端对的低5位才会有用，这样可以防止移位得到超过int类型的最大位数。比如说5&lt;&lt;34，因为最多能移32位，所以要把34转成二进制，然后取低5位，34转换成2进制是100010，取低5位就是00010，也就是5&lt;&lt;34实际上就是5&lt;&lt;2=10100=20。同样的对于long类型，long的最大长度为64位，所以数值的低6位有效。移位运算符同时也支持“&lt;&lt;=”等运算操作。</p>
<h1 id="十二、三元操作符IF-ELSE"><a href="#十二、三元操作符IF-ELSE" class="headerlink" title="十二、三元操作符IF-ELSE"></a>十二、三元操作符IF-ELSE</h1><p>&ensp;&ensp;&ensp;&ensp;三元操作符也称条件操作符，它有三个操作符。表达形式如下：<br>boolean-exp？value1：value2；<br>boolean-exp是一个布尔表达值，如果值为真，则返回value1的值，如果值为假，则返回value2的值。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">int</span> b = a&gt;<span class="number">10</span>?a*<span class="number">100</span>:a*<span class="number">10</span>;</span><br><span class="line">		System.out.println(<span class="string">"b===="</span>+ b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/12/【Java编程思想】四：操作符/png8.png" alt="png8"></p>
<p>因为a&lt;10，所以布尔表达式的值为假，所以取value2也就是a*10的值。</p>
<h1 id="十三、字符串操作符-和"><a href="#十三、字符串操作符-和" class="headerlink" title="十三、字符串操作符+和+="></a>十三、字符串操作符+和+=</h1><p>&ensp;&ensp;&ensp;&ensp;Java中可以使用+和+=连接String类型，并且当操作符左边你的数为String时，Java会试图将操作符右边的类型转换成String。</p>
<h1 id="十四、使用操作符常犯的错误"><a href="#十四、使用操作符常犯的错误" class="headerlink" title="十四、使用操作符常犯的错误"></a>十四、使用操作符常犯的错误</h1><p>&ensp;&ensp;&ensp;&ensp;注意“=”和“==”的区别，以及逻辑运算符如（&amp;&amp;）和位运算符（&amp;）的区别和前自增“++i”和后自增“i++”的区别。注意“==”和“equals（）”的使用，注意别名现象。</p>
<h1 id="十五、类型转换操作符"><a href="#十五、类型转换操作符" class="headerlink" title="十五、类型转换操作符"></a>十五、类型转换操作符</h1><p>&ensp;&ensp;&ensp;&ensp;Java中有跟其它语言相同的转换方式，（类型）值形式，也可以使用基本类型的包装器的转换方法进行转换。</p>
<h1 id="十六、Java没有size-of"><a href="#十六、Java没有size-of" class="headerlink" title="十六、Java没有size of"></a>十六、Java没有size of</h1><p>&ensp;&ensp;&ensp;&ensp;C语言中使用size of来获取程序占用的内存字节大小，目的是确定平台的移植操作，Java中没有这个方法，也就是不需要获取这个值，因为Java在不同的平台下基本数据类型具有相同的大小，可以便捷的移植。</p>
<h1 id="十七、总结"><a href="#十七、总结" class="headerlink" title="十七、总结"></a>十七、总结</h1><p>&ensp;&ensp;&ensp;&ensp;操作符在各个语言中基本通用，熟练掌握自增自减、逻辑运算、位运算以及移位操作即可，理解“==”和“equals()”的原理，理解别名现象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/【Java编程思想】三：static关键字的四种用法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crayon Cxy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ordinary Road">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/【Java编程思想】三：static关键字的四种用法/" itemprop="url">【Java编程思想】static关键字的四种用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-09T15:16:46+08:00">
                2018-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/09/【Java编程思想】三：static关键字的四种用法/" class="leancloud_visitors" data-flag-title="【Java编程思想】static关键字的四种用法">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&ensp;&ensp;&ensp;&ensp;上一章说到了static关键字，static是Java中很重要的一个关键字，在一些场景下可以达到优化程序的效果。本文学习它的不同使用场景。在此之前先了解一下变量的类型。Java中变量分为两种，按作用域分为成员变量和局部变量。成员变量是在类中声明的，不属于任何方法，当前类中有效。局部变量是声明在方法中的，出了当前方法即超出作用域。接下来正文说一下static关键字的四中使用场景：</p>
<h1 id="一、修饰成员变量"><a href="#一、修饰成员变量" class="headerlink" title="一、修饰成员变量"></a>一、修饰成员变量</h1><p>&ensp;&ensp;&ensp;&ensp;static最常用的作用就是修饰成员变量，被static修饰的成员变量也叫做类变量。它与普通成员变量的区别是，它在内存中只有一份拷贝，Java虚拟机只为其分配一次内存。通俗的讲就是，这个变量，不管被多少人使用，他们使用的都是同一个变量，彼此的修改会有影响。可以通过类名.变量的形式进行访问。而普通的成员变量则是没实例化一个对象就产生一个拷贝，虚拟机为每一个变量拷贝都分配了内存。所以类变量的用处一般在于进行变量共享的时候。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Name:"</span> + name + <span class="string">"---Age:"</span> + age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TestStatic ts1 = <span class="keyword">new</span> TestStatic();</span><br><span class="line">		TestStatic ts2 = <span class="keyword">new</span> TestStatic();</span><br><span class="line">		ts1.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">		ts1.age = <span class="number">22</span>;</span><br><span class="line">		ts2.name = <span class="string">"lisi"</span>;</span><br><span class="line">		ts2.age = <span class="number">33</span>;</span><br><span class="line">		ts1.print();</span><br><span class="line">		ts2.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是普通的成员变量的例子，ts1和ts2对于变量name和age分别拥有自己的副本，互相不影响，所以赋值之后，他们能得到他们期望的值。</p>
<p><img src="/2018/11/09/【Java编程思想】三：static关键字的四种用法/png1.png" alt="png1"></p>
<p>接下来将成员变量age修改为类变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Name:"</span> + name + <span class="string">"---Age:"</span> + age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TestStatic ts1 = <span class="keyword">new</span> TestStatic();</span><br><span class="line">		TestStatic ts2 = <span class="keyword">new</span> TestStatic();</span><br><span class="line">		ts1.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">		ts1.age = <span class="number">22</span>;</span><br><span class="line">		ts2.name = <span class="string">"lisi"</span>;</span><br><span class="line">		ts2.age = <span class="number">33</span>;</span><br><span class="line">		ts1.print();</span><br><span class="line">		ts2.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时由于age变成了类变量，因此ts1和ts2共用了一个变量副本，先赋值的会被后赋值的覆盖掉。</p>
<p><img src="/2018/11/09/【Java编程思想】三：static关键字的四种用法/png2.png" alt="png2"></p>
<p>此外第二个示例代码中，静态成员变量使用了对象.变量的方式进行调用，这里编译器会给出警告，使用类名.方法之后警告就会解除。</p>
<p><img src="/2018/11/09/【Java编程思想】三：static关键字的四种用法/png3.png" alt="png3"></p>
<h1 id="二、修饰成员方法"><a href="#二、修饰成员方法" class="headerlink" title="二、修饰成员方法"></a>二、修饰成员方法</h1><p>&ensp;&ensp;&ensp;&ensp;static另一个作用是修饰类中的方法，其目的是可以通过类名.方法的形式调用方法，而避免频繁的创建对象。同时对于存储空间来说也只有一个，不同对象调用的是同一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Name:"</span> + name + <span class="string">"---Age:"</span> + age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TestStatic ts1 = <span class="keyword">new</span> TestStatic();</span><br><span class="line">		TestStatic ts2 = <span class="keyword">new</span> TestStatic();</span><br><span class="line">		ts1.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">		ts1.age = <span class="number">22</span>;</span><br><span class="line">		ts2.name = <span class="string">"lisi"</span>;</span><br><span class="line">		TestStatic.age = <span class="number">33</span>;</span><br><span class="line">		TestStatic.print();</span><br><span class="line">		TestStatic.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将之前代码中的print方法改为使用static修饰之后，这个方法就可以不用对象.方法的形式调用了。</p>
<h1 id="三、修饰代码块"><a href="#三、修饰代码块" class="headerlink" title="三、修饰代码块"></a>三、修饰代码块</h1><p>&ensp;&ensp;&ensp;&ensp;我们先看一下对象的初始化过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Load</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Load</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		System.out.println(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span></span>&#123;</span><br><span class="line">	Load ld1 = <span class="keyword">new</span> Load(<span class="string">"普通变量1"</span>);</span><br><span class="line">	Load ld2 = <span class="keyword">new</span> Load(<span class="string">"普通变量2"</span>);</span><br><span class="line">	<span class="keyword">static</span> Load ld3 = <span class="keyword">new</span> Load(<span class="string">"静态变量3"</span>);</span><br><span class="line">	<span class="keyword">static</span> Load ld4 = <span class="keyword">new</span> Load(<span class="string">"静态变量4"</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TestStatic</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		System.out.println(msg);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TestStatic ts = <span class="keyword">new</span> TestStatic(<span class="string">"TestStatic 初始化"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;在类TestStatic中，我们初始化了两个普通成员变量和两个静态成员变量，并在main函数开始的时候初始化了TestStatic对象。结果如下：</p>
<p><img src="/2018/11/09/【Java编程思想】三：static关键字的四种用法/png4.png" alt="png4"></p>
<p>&ensp;&ensp;&ensp;&ensp;静态成员变量最先被初始化，并且按照执行的先后顺序进行初始化。其次初始化的是成员变量，最后初始化的是构造方法。所以在创建一个对象的时候，最先被初始化的是静态成员变量。</p>
<p>&ensp;&ensp;&ensp;&ensp;在看另外一个调用了静态方法的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Load</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Load</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		System.out.println(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span></span>&#123;</span><br><span class="line">	Load ld1 = <span class="keyword">new</span> Load(<span class="string">"普通变量1"</span>);</span><br><span class="line">	Load ld2 = <span class="keyword">new</span> Load(<span class="string">"普通变量2"</span>);</span><br><span class="line">	<span class="keyword">static</span> Load ld3 = <span class="keyword">new</span> Load(<span class="string">"静态变量3"</span>);</span><br><span class="line">	<span class="keyword">static</span> Load ld4 = <span class="keyword">new</span> Load(<span class="string">"静态变量4"</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TestStatic</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		System.out.println(msg);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"静态方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TestStatic.staticFunc();</span><br><span class="line">		System.out.println(<span class="string">"@@@@@@@@@"</span>);</span><br><span class="line">		TestStatic ts = <span class="keyword">new</span> TestStatic(<span class="string">"TestStatic 初始化"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 我们在创建对象之前先调用了静态方法，结果如下:</p>
<p><img src="/2018/11/09/【Java编程思想】三：static关键字的四种用法/png5.png" alt="png5"></p>
<p>&ensp;&ensp;&ensp;&ensp;我们可以看到，静态成员的初始化发生在创建对象之前，确切的说是在调用静态方法之前就已经被初始化了。并且，当我们创建对象的时候，原本被初始化过的静态成员变量跟静态方法没有再次被初始化。</p>
<p>&ensp;&ensp;&ensp;&ensp;这时我们的static的作用就是，修饰一段都需要被修饰为static的域。被static修饰的代码域，域中所有的内容都被当成static变量，且优先初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Load</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Load</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		System.out.println(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span></span>&#123;</span><br><span class="line">	Load ld1 = <span class="keyword">new</span> Load(<span class="string">"普通变量1"</span>);</span><br><span class="line">	Load ld2 = <span class="keyword">new</span> Load(<span class="string">"普通变量2"</span>);</span><br><span class="line">	<span class="keyword">static</span> Load ld3;</span><br><span class="line">	<span class="keyword">static</span> Load ld4;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		ld3 = <span class="keyword">new</span> Load(<span class="string">"静态变量3"</span>);</span><br><span class="line">		ld4 = <span class="keyword">new</span> Load(<span class="string">"静态变量4"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TestStatic</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		System.out.println(msg);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"静态方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TestStatic.staticFunc();</span><br><span class="line">		System.out.println(<span class="string">"@@@@@@@@@"</span>);</span><br><span class="line">		TestStatic ts = <span class="keyword">new</span> TestStatic(<span class="string">"TestStatic 初始化"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改之前的代码将静态成员变量放在由static修饰的域中，结果如下：</p>
<p><img src="/2018/11/09/【Java编程思想】三：static关键字的四种用法/png6.png" alt="png6"></p>
<p>与分开修饰结果相同。</p>
<h1 id="四、静态导入"><a href="#四、静态导入" class="headerlink" title="四、静态导入"></a>四、静态导入</h1><p>&ensp;&ensp;&ensp;&ensp;前边三种都是比较常用的场景，还有一种不是太常用，是JDK1.5之后新加入的功能，导入一个带有静态方法的包，并将包修饰为static，从而在当前类中直接调用修饰的静态方法，就好像是自己的方法一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.chenxyt.java.test;</span><br><span class="line">public class Printer &#123;</span><br><span class="line">	public static void print(String msg)&#123;</span><br><span class="line">		System.out.println(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后另一个包中使用import static导入这个类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.chenxyt.java.practice;</span><br><span class="line">import static com.chenxyt.java.test.Printer.*;</span><br><span class="line">public class TestStatic&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		print(&quot;This is TestStatic&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/09/【Java编程思想】三：static关键字的四种用法/png7.png" alt="png7"></p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>&ensp;&ensp;&ensp;&ensp;static是Java语言中的一个很重要的关键字，主要用途有三个方面修饰成员变量，修饰成员方法以及修饰代码块。使用static修饰的成员变量在类加载的时候就已经被初始化了，它属于类变量，不属于某个对象，所有该类的实例化对象拥有同一个静态成员变量副本，常用的用途可以用它来做计数器。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/【Java编程思想】二：一切都是对象/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crayon Cxy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ordinary Road">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/【Java编程思想】二：一切都是对象/" itemprop="url">【Java编程思想】一切都是对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-09T10:49:08+08:00">
                2018-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/09/【Java编程思想】二：一切都是对象/" class="leancloud_visitors" data-flag-title="【Java编程思想】一切都是对象">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、用引用操作对象"><a href="#一、用引用操作对象" class="headerlink" title="一、用引用操作对象"></a>一、用引用操作对象</h1><p>&ensp;&ensp;&ensp;&ensp;在Java中，一切都是对象，但是操作对象的标识符是对象的一个“引用”，这一关系可以理解为电视机与遥控器的关系。我们通过遥控器控制电视机，我们在房间里不管在哪都可以使用遥控器操作电视机。同时，遥控器又可以独立存在，即引用可以独立存在，有如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;上一行代码仅仅是创建了一个引用，而并非是一个对象。如果此时我们向s发送消息的话，将报出运行时异常的错误。因为前文讲到Java中消息的传递是建立在对象之间来完成的。因此我们需要在建立引用的时候对其进行初始化，使其指向一个对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"abc"</span>；</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;这里使用了Java语言的特性，字符串可以使用引号引起来用来进行初始化操作。</p>
<h1 id="二、必须由你创建所有的对象"><a href="#二、必须由你创建所有的对象" class="headerlink" title="二、必须由你创建所有的对象"></a>二、必须由你创建所有的对象</h1><p>&ensp;&ensp;&ensp;&ensp;我们创建了一个操作对象的引用，通常希望它与一个对象相关联，以便我们可以进行消息的传递，完成业务功能。Java语言中使用new关键字来完成这个操作，它的含义是“给我创建一个对象与我的引用关联”。所以上述代码可以改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String（abc<span class="string">"）;</span></span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;它表示为给我一个String类型的对象，并且初始化为“abc”。</p>
<p>&ensp;&ensp;&ensp;&ensp;当我们创建好对象时，他们是怎么样进行内存分配的呢？程序在计算机中有如下五个地方可以分配内存：</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.寄存器：</strong>这是最快的存储区，他在处理器的内部，并且数量非常有限。因此它是根据需求进行分配，你基本不能自己控制他的分配。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.堆栈：</strong>位于通用（RAM）随机存储器中，通过堆栈指针的移动进行内存分配，速度仅次于寄存器。在堆栈中分配内存空间的项，Java系统必须明确知道其声明周期，以便更好地进行指针的移动。这也从一定程度上进行了限制，因此Java中，对象的引用存在堆栈中，但是对象并不存在堆栈中。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.堆：</strong>一种同样存放在RAM的内存池，存放Java中所有的对象，且不需要知道其声明周期。是Java程序中主要的内存分配区域，只需要new关键字即可获得内存，但这种效率要比在堆栈上低很多。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.常量存储：</strong>常量池通常存在程序代码内部，这样使得他们永远不会被改变。在部分嵌入式系统中，常量本身会与其它部分分离，这种情况通常将常量存在（ROM）只读存储器中。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>5.非RAM存储：</strong>数据可以完全脱离程序存储在外部，从而不受程序的控制。比如文件流对象和持久化对象，文件流通常发给另外一台机器，而持久化对象则通常是存储在硬盘中。</p>
<p>&ensp;&ensp;&ensp;&ensp;Java中有一种特殊的类型称作是基本类型，通常情况下，new将对象存储在堆里，当创建一个简单的小的对象时，显得不是很有效，因此Java采用跟C或者C++相同的方式，不用new创建变量，而创建一个并非是引用的自动变量，这个变量直接存储值，并将其存储在堆栈中。与其他语言不同的是，Java中所有的基本类型的大小在各个平台都相同，这使得Java程序有更好的跨平台移植性。</p>
<p><img src="/2018/11/09/【Java编程思想】二：一切都是对象/png1.png" alt="png1"></p>
<p>&ensp;&ensp;&ensp;&ensp;所有的数值类型都有正负号，所以Java中不存在无符号类型。基本类型具有包装器类，使得可以在堆中创建一个非基本对象，用来表示对应的基本类型。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = ‘x’；</span><br><span class="line">Character ch = <span class="keyword">new</span> Character（c）；</span><br></pre></td></tr></table></figure>
<p>也可以这样用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Character ch = <span class="keyword">new</span> Character（‘x’）；</span><br></pre></td></tr></table></figure>
<p>Java SE5的自动包装功能可以自动的将基本类型转换为包装器类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Character ch = ‘x’；</span><br></pre></td></tr></table></figure>
<p>也可以反向转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char c = ch；</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;Java中还提供了两个用于高精度计算的类：BigInteger和BigDecimal，他们大体属于“包装器类”，但是他们没有对应的基本类型，不过可以通过方法调用的方式与int 和 float进行交互操作。BigInteger支持任意精度的整数，BigDecimal支持任意精度的浮点数。</p>
<p>&ensp;&ensp;&ensp;&ensp;Java与其他语言一样都提供了数组的功能，不同的是，Java语言保证了数组的安全性，会确保数组被初始化才使用，不会出现其他语言中的访问没有被初始化的内存区域。当创建了一个数组对象时，实际上就创建了一个引用数组，并且每个引用会自动初始化一个特定的值，该值拥有自己的关键字null，一旦Java看到了null，就知道这个引用还有指向对象，也就是没有被初始化。这个过程称为下标检查。</p>
<h1 id="三、永远不需要销毁对象"><a href="#三、永远不需要销毁对象" class="headerlink" title="三、永远不需要销毁对象"></a>三、永远不需要销毁对象</h1><p>&ensp;&ensp;&ensp;&ensp;Java语言与其它语言一样都有作用域的概念，作用域决定了定义在其内部的变量的可见性和生命周期。作用域使用一对花括号表示。这里需要注意的是，Java对象与其它基本类型不同，它可以存活于作用域外部，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">"x"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;引用s在作用域结束时就已经失去了意义，但是String对象仍然存活，只是我们暂时无法使用它。因为它的唯一引用已经超出了范围。后面会讲程序的执行过程，如何传递和复制引用。Java中只要你需要，对象会一直存在，Java与其它语言不同的是自带了垃圾回收机制，会自动识别不需要的对象进行回收以达到释放内存的目的。因此你无需担心忘了释放对象的内存。</p>
<h1 id="四、创建新的数据类型：类"><a href="#四、创建新的数据类型：类" class="headerlink" title="四、创建新的数据类型：类"></a>四、创建新的数据类型：类</h1><p>&ensp;&ensp;&ensp;&ensp;前文说到，同一种对象的集合我们称作是类，类表示所有由它实例化的对象都有相同的基本属性。Java中使用class关键字创建类，class后跟类的名字。这里不存在类似先有鸡还是先有蛋的问题，对象是一系列集合中的一个具体实例，也就是对象是一个类的具体实例化，因此在创建对象之前，一定先存在了这个对象所属的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Students</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如上我们定义了一个新的类，它是一个空类，没有属性也没有方法，所以还不能传递消息。但是我们可以用它实例化一个对象了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Students student = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;类中有两种数据类型，一种是字段属性，另一种是方法。字段用来表示这个类的一些属性，方法用来表示这个类的一些行为，可以做哪些事情。每个对象都有存储字段的空间，并且类内部的普通属性的字段不可以共享。我们定义如下字段属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Students&#123;</span><br><span class="line">    int i;</span><br><span class="line">    double j;</span><br><span class="line">    boolean k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;定义好了字段属性之后就可以创建一个对象，并通过对象引用操作对象内的字段属性，使用对象引用“.”方法的形式为对象内的字段属性赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Students student = <span class="keyword">new</span> Students();</span><br><span class="line">student.i=<span class="number">1</span>;</span><br><span class="line">student.j=<span class="number">1.1</span>;</span><br><span class="line">student.k=<span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;Java会为类中的基本类型成员提供一个默认的初始值，以确保可以有效的初始化，防止程序运行出错。如果这个初始值不符合业务要求，那么需要开发者自行初始化。如果不是类中的基本类型数据变量，那么它的初始值就是随机的。</p>
<p><img src="/2018/11/09/【Java编程思想】二：一切都是对象/png2.png" alt="png2"></p>
<h1 id="五、方法、参数和返回值"><a href="#五、方法、参数和返回值" class="headerlink" title="五、方法、参数和返回值"></a>五、方法、参数和返回值</h1><p>&ensp;&ensp;&ensp;&ensp;Java类中的方法决定了能做哪些事情，传递哪些消息。方法的组成包括：名称、参数、返回值和方法体，其基本形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">methodName</span><span class="params">(Arg arg)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*Method Body*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中ReturuType是方法返回给调用方的返回值类型，methodName是方法名，Arg是参数类型，arg是参数，注释中的是方法要做的事情。</p>
<p>&ensp;&ensp;&ensp;&ensp;Java中对象的调用同样是通过对象引用“.”方法名来完成的。并且要保证这个对象可以执行这个方法，否则编译器会提示错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objectName.methodName(arg,arg1,arg2);</span><br><span class="line">ReturnType x = obejctName.methodName(arg,arg1,arg2);</span><br></pre></td></tr></table></figure>
<p>如上分别是有返回值和无返回值的调用方式。</p>
<h1 id="六、构建一个Java程序"><a href="#六、构建一个Java程序" class="headerlink" title="六、构建一个Java程序"></a>六、构建一个Java程序</h1><p>&ensp;&ensp;&ensp;&ensp;Java中为了解决命名冲突的问题，采用了分包的形式。将相同类型，或者相同作用，相同业务场景的类放在一个包中，不同的包彼此隔离，并且不同包中可以出现同名的类。使用import关键字导入相关的包即可访问对应包中的类，若导入后出现同名的类，则需要指明对应类的包名。通常情况下，我们必须创建一个类的实例对象来访问类中的属性和方法，而有一种特殊的情况，就是当被static修饰的属性和方法时，不需要对象进行访问。直接使用类名.属性/方法的形式进行访问。也就是说，这个属性和方法属于这个类了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;现在即使我们创建两个对象，对于属性i仍然只有一个值，也就是说这个被static修饰了的域变成了一个公共的属性。不同对象之间共享同一个变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TestStatic ts1 = <span class="keyword">new</span> TestStatic();</span><br><span class="line">TestStatic ts2 = <span class="keyword">new</span> TestStatic();</span><br></pre></td></tr></table></figure>
<p>关于static关键字的作用，下一章详细学习。</p>
<h1 id="七、你的第一个Java程序"><a href="#七、你的第一个Java程序" class="headerlink" title="七、你的第一个Java程序"></a>七、你的第一个Java程序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*</span><br><span class="line">public class HelloWorld&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello World&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;import是导入java.util工具包下的所有类,HelloWorld是类名，类名需要与文件名相同，main方法是程序的入口，虽然这里没有用到参数列表，但是对于main函数来说这是必须的。使用开发工具如Eclipse运行程序即可看到控制台打印“HelloWorld”</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/08/【Java编程思想】一：对象导论/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crayon Cxy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ordinary Road">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/08/【Java编程思想】一：对象导论/" itemprop="url">【Java编程思想】对象导论</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-08T14:21:09+08:00">
                2018-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/08/【Java编程思想】一：对象导论/" class="leancloud_visitors" data-flag-title="【Java编程思想】对象导论">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、抽象过程"><a href="#一、抽象过程" class="headerlink" title="一、抽象过程"></a>一、抽象过程</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>1.万物皆为对象：</strong>理论上来说，我们可以抽取待解决问题中任何一个概念化的构件，将其描述成为程序中的一个对象。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.程序是对象的集合，它们通过发送消息来告知彼此需要做的事：</strong>通俗来讲，程序是一系列对象的集合体，程序之间的通信可以细分到对象与对象之间的通信，要想进行通信就需要发送消息。从程序的角度来说，消息传递这个过程可以理解为一个方法的调用与执行。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.每个对象都可以由其它对象组成：</strong>换句话说，对象之间可以进行组合，形成新的具有具体意义的对象。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.每个对象拥有其自己的类型：</strong>类型用来区分不同对象的特征，比如正方形有四条边，三角形有三条边，边的条数就可以用来区分二者。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>5.某一特定类型的所有对象，都可以接收同样的消息：</strong>也就是说，具有相同类型的一系列对象，它们具有的行为是相同的，因此它们可以接收/处理相同的消息。</p>
<p>&ensp;&ensp;&ensp;&ensp;对象具有行为、状态和标识，每一个对象都可以拥有内部数据和方法，数据用来表示对象的状态，方法用来产生特定的行为，每个对象有唯一的标识与其它对象区分。拥有相同类型的对象的集合称作类，也就是说我们创建的每一个对象，都来自一个类。</p>
<h1 id="二、每个对象都有一个接口"><a href="#二、每个对象都有一个接口" class="headerlink" title="二、每个对象都有一个接口"></a>二、每个对象都有一个接口</h1><p>&ensp;&ensp;&ensp;&ensp;对象之间进行消息传递时是通过接口来完成的，一个对象的接口暴露给另一个对象，接口对应内部的一个具体实现，具体实现表示特定的方法行为。</p>
<h1 id="三、每个对象都提供服务"><a href="#三、每个对象都提供服务" class="headerlink" title="三、每个对象都提供服务"></a>三、每个对象都提供服务</h1><p>&ensp;&ensp;&ensp;&ensp;我们拆分、抽取的每一个对象，都是具有实际业务意义的，它们都应该能够传递具体的消息，从而提供特定的服务。</p>
<h1 id="四、被隐藏的具体实现"><a href="#四、被隐藏的具体实现" class="headerlink" title="四、被隐藏的具体实现"></a>四、被隐藏的具体实现</h1><p>&ensp;&ensp;&ensp;&ensp;很多时候，我们将开发者分为两种，类创建者和客户端开发人员，所谓类创建者，可以理解为对象集合的构建者，客户端开发人员负责使用他们所创建的对象。有些时候，为了避免客户端开发者恶意修改类的功能，或者为了类在不断升级的过程中，能够更好地实现向下兼容，我们需要对客户端开发人员屏蔽一些他们用不到的且很关键的代码。这个屏蔽的过程叫做访问控制。</p>
<p>&ensp;&ensp;&ensp;&ensp;Java中提供了三个级别的访问控制，分别为public、protected、private。public顾名思义就是所有人可见。private就是只有类的创建者可见。protected介于二者之间，在由基类派生出的派生类中，可以访问派生类中被protected修饰的域，而不能访问private域，其它与private相同。具体的访问控制后文继续学习。</p>
<h1 id="五、复用具体实现"><a href="#五、复用具体实现" class="headerlink" title="五、复用具体实现"></a>五、复用具体实现</h1><p>&ensp;&ensp;&ensp;&ensp;有些时候我们需要使用一个现有的类完成特定的功能，但是又不能完成全部功能，那么我们就可以创建一个新的类，在这个类中引入先前的类的对象，并将其声明为private域，这样的话我们就可以使用这个对象的方法来完成一部分功能，然后在新类中创建新的属性和方法，并且在外人看来它就是一个新的类。这种“has-a”的关系我们称为组合。</p>
<h1 id="六、继承"><a href="#六、继承" class="headerlink" title="六、继承"></a>六、继承</h1><p>&ensp;&ensp;&ensp;&ensp;当我们创建一个类时，如果另一个新类与这个类功能相似，我们仍然需要创建这个新类。解决这个问题的办法就是继承。继承虽然也是一个新类，但是这个类是由基类（俗称父类）衍生的导出类（俗称子类）。子类拥有父类所有非private的对象、属性、接口，此外可以根据不同的需要增加不同的功能。父类可以有很多个子类，它包含了子类的所有公共部分。如“几何形”是父类，每一个几何形都具有尺寸、颜色、位置等，同时每一个几何形都可以被绘制、擦除和移动。在此基础上可以导出它的子类“三角形”、“平行四边形”等，他们拥有父类的属性、方法之外还有自己独特的属性，例如有的形状可以被翻转等。<br>​    子类不光继承了父类的属性，同时也继承了父类的方法，也就是说所有发给父类的消息，都可以发给子类。子类对接口的实现方法可以不改变，即访问子类的接口实际是与访问父类相同，当然也可以自己“覆盖”父类接口的方法，也就是说我和父类使用相同的接口，但是我们做不同的事情。同时如前边所说，子类也可以自己新增方法来满足自己的需求。前者不改变或者覆盖接口的方法，这种我们称作是“is-a”的关系，因为子类与父类本质的类型没有发生变化。而后边这种我们称作是“is-like-a”，因为在子类中增加了新的方法，所以这种相同的关系并不完全。</p>
<h1 id="七、伴随多态的可互换对象"><a href="#七、伴随多态的可互换对象" class="headerlink" title="七、伴随多态的可互换对象"></a>七、伴随多态的可互换对象</h1><p>&ensp;&ensp;&ensp;&ensp;我们说子类继承父类，同时继承了父类的方法，也就是说发给父类的消息同时能够发给子类。那么当我们把子类对象看成泛化的基类对象时，如果有个方法是让泛化的父类操作自己，那么编译器在编译时不知道该执行哪段代码的。一个非面向对象程序的函数调用是前期绑定，函数要执行的代码在程序运行之前就已经确定了，然而在面向对象中，直到程序执行我们才知道哪段代码被执行了。所以为了解决消息执行哪段代码的问题，Java使用了后期绑定的概念，使用一小段特殊的代码来代替非面向对象中所说的绝对地址调用，这段代码使用在对象中存储的信息来计算方法的地址。比如有个父类Shape和子类Circle、子类Triangle，父类中有如下方法    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Shape shape)</span></span>&#123;</span><br><span class="line">    shape.erase();</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">    shape.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法可以与任意Shape类型的对象交互，如果程序中有它的子类调用了该方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Circle circle = <span class="keyword">new</span> Circle();</span><br><span class="line">Triangle triangle = <span class="keyword">new</span> Triangle();</span><br><span class="line">cicle.doSomething();</span><br><span class="line">triangle.doSomething();</span><br></pre></td></tr></table></figure>
<h1 id="八、单根继承结构"><a href="#八、单根继承结构" class="headerlink" title="八、单根继承结构"></a>八、单根继承结构</h1><p>&ensp;&ensp;&ensp;&ensp;在Java语言中，所有的类都是Object类的子类，拥有着Object类的基本方法。这种单根继承结构有很大的好处，比如在垃圾回收中可以避免由于不知道对象的类型而无处下手，因为他们都可以使用Object类的方法，并且所有对象都可以很容易的在堆上创建。</p>
<h1 id="九、容器"><a href="#九、容器" class="headerlink" title="九、容器"></a>九、容器</h1><p>&ensp;&ensp;&ensp;&ensp;有时候我们并不知道处理一个问题需要多少个对象，或者他们需要存活多久，那么我们就不知道该怎么样存储这些对象。Java语言中创建了一种对象类型，叫做容器（也叫集合）。这种新的对象类型内部有对其他对象的引用，当你需要的时候你可以很容易的扩充容器的空间来容纳对象。Java中提供了多种容器类型，如List（用于存储序列）、Map（也被称为关联数组，用来建立对象的关联）、Set（每种对象类型只持有一个）。因为容器中存储了其他对象的引用，所以根据单根继承结构，容器中的对象类型都是Obejct类型，这样很方便其他对象类型进行转型。但是从Object类型转到其它特定类型（称作向下转型）很容易发生错误，所以Java SE5之后引入了泛型的概念，参数传递使用一对&lt;&gt;，&lt;&gt;内部可以传递任意类型的对象，这便解决了向下转型带来的安全隐患。</p>
<h1 id="十、对象的创建和生命周期"><a href="#十、对象的创建和生命周期" class="headerlink" title="十、对象的创建和生命周期"></a>十、对象的创建和生命周期</h1><p>&ensp;&ensp;&ensp;&ensp;对象的创建主要有两种，一种是在编程时由程序员控制，将对象置于栈中或者是静态区域，这种的好处是知道对象的大小、生命周期。同时也限制了对象的灵活性。另一种是通过new在内存堆中动态的创建对象，这种方式的好处是灵活，需要的时候直接在内存中创建即可，实现了存储空间的动态管理。Java中完全采用了动态内存的分配方式。</p>
<p>&ensp;&ensp;&ensp;&ensp;对于生命周期，栈上的生命周期，编译器可以知道它什么时候销毁，并自动回收。而在堆上创建的对象，必须由程序员自己指定回收时间，如果没有指定则会造成内存泄漏。Java中提供了垃圾回收机制，可以自动的回收在堆上创建的对象。    </p>
<h1 id="十一、异常处理：处理错误"><a href="#十一、异常处理：处理错误" class="headerlink" title="十一、异常处理：处理错误"></a>十一、异常处理：处理错误</h1><p>&ensp;&ensp;&ensp;&ensp;Java内置了异常处理机制，相当于一条与正确执行并行的路线，当程序发生异常时会执行异常的代码。同时，允许程序在异常中进行处理并返回到正确的结果中去。</p>
<h1 id="十二、并发编程"><a href="#十二、并发编程" class="headerlink" title="十二、并发编程"></a>十二、并发编程</h1><p>&ensp;&ensp;&ensp;&ensp;Java与其他语言一样，提供多线程的并发编程方式，提高程序运行效率。</p>
<h1 id="十三、Java与Internet"><a href="#十三、Java与Internet" class="headerlink" title="十三、Java与Internet"></a>十三、Java与Internet</h1><p>&ensp;&ensp;&ensp;&ensp;Java不仅可以编写客户端程序，还可以编写网络Web应用程序。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Crayon Cxy</p>
              <p class="site-description motion-element" itemprop="description">Go over the mountain, and they will hear your story.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.diosfun.com/" title="六脉神间" target="_blank">六脉神间</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/chenxyt" title="My CSDN" target="_blank">My CSDN</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Crayon Cxy</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("5L2kF0V7XFDR6a7wmWFyGC3Q-gzGzoHsz", "Cy1yzcQbLJV7TGUDEmRnvC9A");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
