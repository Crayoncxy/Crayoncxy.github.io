<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Go over the mountain, and they will hear your story.">
<meta property="og:type" content="website">
<meta property="og:title" content="Ordinary Road">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Ordinary Road">
<meta property="og:description" content="Go over the mountain, and they will hear your story.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ordinary Road">
<meta name="twitter:description" content="Go over the mountain, and they will hear your story.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/">





  <title>Ordinary Road</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ordinary Road</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/20/【Zookeeper】Unable to read additional data from client sessionid , likely client has closed socket/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crayon Cxy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ordinary Road">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/20/【Zookeeper】Unable to read additional data from client sessionid , likely client has closed socket/" itemprop="url">【Zookeeper】Unable to read additional data from client sessionid*,likely client has closed socket</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-20T14:25:26+08:00">
                2018-11-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/问题解决/" itemprop="url" rel="index">
                    <span itemprop="name">问题解决</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/20/【Zookeeper】Unable to read additional data from client sessionid , likely client has closed socket/" class="leancloud_visitors" data-flag-title="【Zookeeper】Unable to read additional data from client sessionid*,likely client has closed socket">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、问题描述："><a href="#一、问题描述：" class="headerlink" title="一、问题描述："></a>一、问题描述：</h1><p>&ensp;&ensp;&ensp;&ensp;因为项目中使用到了Zookeeper，所以我自己找了些关于zk的资料学习了一下。在异步创建节点的过程中，抛出了如下问题：</p>
<p><img src="/2018/11/20/【Zookeeper】Unable to read additional data from client sessionid , likely client has closed socket/png1.png" alt="png1"></p>
<p>&ensp;&ensp;&ensp;&ensp;异步创建节点的时候总是闪退，然后服务端报错 Unable to read additional data from client sessionid 0x162b246bfe50000, likely client has closed socket ，我们先看下代码 这里我把同步跟异步的代码一起贴了出来便于学习</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zk.zkTest;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.AsyncCallback.DataCallback;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.AsyncCallback.StringCallback;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException.Code;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException.NoNodeException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException.NodeExistsException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</span><br><span class="line"><span class="comment">//实现一个监视点Watcher接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Master</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST_POT = <span class="string">"127.0.0.1:2181"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//zk连接对象</span></span><br><span class="line">	<span class="keyword">public</span> ZooKeeper zk;</span><br><span class="line">	<span class="comment">//连接地址、端口</span></span><br><span class="line">	<span class="keyword">public</span> String hostpot;</span><br><span class="line">	<span class="comment">//构造函数 传入连接参数</span></span><br><span class="line">	Master(String hostpot)&#123;</span><br><span class="line">		<span class="keyword">this</span>.hostpot = hostpot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//启动</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">zkStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//this传入该类的对象</span></span><br><span class="line">			zk = <span class="keyword">new</span> ZooKeeper(hostpot,<span class="number">400000</span>,<span class="keyword">this</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">zkStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			zk.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建主节点存储的数据 </span></span><br><span class="line">	Random random = <span class="keyword">new</span> Random();</span><br><span class="line">	String serverId = Integer.toHexString(random.nextInt());</span><br><span class="line">	<span class="comment">//创建主节点（同步）</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">runForMasterSyn</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">		<span class="comment">//循环的原因是 当客户端与服务端发生网络中断时 客户端会尝试重新连接服务端</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 同步调用方法 第一个参数节点名称 第二个是节点数据 第三个是安全策略 此处使用开放式的ACL访问控制列表 第四个是创建模式 此处创建了一个临时节点</span></span><br><span class="line">				zk.create(<span class="string">"/master"</span>,serverId.getBytes(),ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL);</span><br><span class="line">				isLeader = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (NodeExistsException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block  </span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">				isLeader = <span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block 网络连接异常 此处不确定主节点是否已经创建完成 网络断开可能发生在请求之前，也可能发生在请求创建之后 因此要考虑这种异常 所以此处不返回 执行下面的check判断</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(checkMasterSyn())&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isLeader = <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">//检查主节点是否已经创建 发生上述两种异常时执行 （同步）</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">checkMasterSyn</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//获取节点的数据 第二个字段为是否启动监听后续的变化</span></span><br><span class="line">				<span class="keyword">byte</span> data[] = zk.getData(<span class="string">"/master"</span>,<span class="keyword">false</span>,stat);</span><br><span class="line">				<span class="comment">//如果数据里的内容是当前的进程存储的内容 则表示当前进程为主节点 即创建成功</span></span><br><span class="line">				isLeader = <span class="keyword">new</span> String(data).equals(serverId);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (NoNodeException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建主节点（异步） 与同步相比多了两个参数 1.回调方法 2.指定的上下文信息 回调方法调用的是传入的对象的实例 （回调要知道是哪个调用的回调）同时因为回调返回之前不需要等待create结果 所以没有Interrupt异常 因为执行结果会在回调之后收到 所以也没有Keeper异常</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">runForMasterAsyn</span><span class="params">()</span></span>&#123;</span><br><span class="line">		zk.create(<span class="string">"/master"</span>,serverId.getBytes(),ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL,masterCreateCallBack,<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建回调对象 异步调用只有一个线程处理回调请求 因此遵循FIFO的原则 所以应避免异步调用里处理大量逻辑或者阻塞代码</span></span><br><span class="line">	StringCallback masterCreateCallBack = <span class="keyword">new</span> StringCallback()&#123;</span><br><span class="line">		<span class="comment">//回调的函数  rc 返回调用的结果 返回OK或者异常编码 path 对应create的第一个参数 ctx 对应create的上下文 即最后一个字段  name znode节点名  对于非有序节点 path与name相同 有序节点 name会自动标号</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">				String name)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="keyword">switch</span> (Code.get(rc))&#123;</span><br><span class="line">			<span class="keyword">case</span> CONNECTIONLOSS:</span><br><span class="line">				checkMasterAsyn();</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">case</span> OK:</span><br><span class="line">				isLeader = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				isLeader = <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"I'm "</span>+(isLeader?<span class="string">""</span>:<span class="string">"not"</span>)+<span class="string">" Leader"</span>);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">//检查主节点状态 （异步调用创建主节点时做的检查）</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">checkMasterAsyn</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//第一个参数节点名称 第二个参数是否设置监听 第三个为获取数据的异步回调 第四个为上下文信息</span></span><br><span class="line">		zk.getData(<span class="string">"/master"</span>,<span class="keyword">false</span>,masterCheckCallBack,<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//异步获取节点数据信息</span></span><br><span class="line">	DataCallback masterCheckCallBack = <span class="keyword">new</span> DataCallback()&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">byte</span>[] data, Stat stat)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="keyword">switch</span>(Code.get(rc))&#123;</span><br><span class="line">			<span class="keyword">case</span> CONNECTIONLOSS:</span><br><span class="line">				<span class="comment">//此处递归循环调用 尝试连接</span></span><br><span class="line">				checkMasterAsyn();</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">case</span> NONODE:</span><br><span class="line">				<span class="comment">//没有节点重新创建</span></span><br><span class="line">				runForMasterAsyn();</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">//实现的接口方法 </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent arg0)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(arg0);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		Master m = <span class="keyword">new</span> Master(HOST_POT);</span><br><span class="line">		m.zkStart();</span><br><span class="line">		m.runForMasterAsyn();</span><br><span class="line">		<span class="keyword">if</span>(isLeader)&#123;</span><br><span class="line">			<span class="comment">//此处用来处理主节点业务逻辑</span></span><br><span class="line">			System.out.println(<span class="string">"I'M THE LEADER"</span>);</span><br><span class="line">			Thread.sleep(<span class="number">2000000000</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"SORRY,SOMEONE ELSE IS THE LEADER"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		m.zkStop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看下运行之后的控制台信息：</p>
<p><img src="/2018/11/20/【Zookeeper】Unable to read additional data from client sessionid , likely client has closed socket/png2.png" alt="png2"></p>
<h1 id="二、解决方案："><a href="#二、解决方案：" class="headerlink" title="二、解决方案："></a>二、解决方案：</h1><p>&ensp;&ensp;&ensp;&ensp;从上边控制台的信息可以看出 if/else的判断发生在了异步回调之前，并且打印了最后一行日志Session closed<br>所以这里抛错的原因是：<strong>没有等待异步通知的响应信息，就提前关闭了连接。</strong>解决方法就是在if/else之前延时等待，或者设置变量等待异步通知返回结果之后再进行if/else判断。</p>
<p>&ensp;&ensp;&ensp;&ensp;网上还有很多关于这个错误的解决方案，场景不同，但大多数的原因都是因为网络中断，有的可能是超时时间不够，我这里的原因是在异步通知返回结果之前就人为的结束了连接。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/20/【Oracle】ORA-06413-连接未打开/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crayon Cxy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ordinary Road">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/20/【Oracle】ORA-06413-连接未打开/" itemprop="url">【Oracle】ORA-06413 连接未打开</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-20T14:20:43+08:00">
                2018-11-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/问题解决/" itemprop="url" rel="index">
                    <span itemprop="name">问题解决</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/20/【Oracle】ORA-06413-连接未打开/" class="leancloud_visitors" data-flag-title="【Oracle】ORA-06413 连接未打开">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h1><p>&ensp;&ensp;&ensp;&ensp;使用toad连接oracle报错“ORA-06413 连接未打开”</p>
<h1 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h1><p>&ensp;&ensp;&ensp;&ensp;toad安装路径下存在诸如‘（’等特殊字符，比如我的路径是Program Files（x86），修改安装路径为D：\tools等不带特殊字符的路径即可</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/20/【Java编程思想】十五：类型信息/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crayon Cxy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ordinary Road">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/20/【Java编程思想】十五：类型信息/" itemprop="url">【Java编程思想】十五：类型信息</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-20T09:39:48+08:00">
                2018-11-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/20/【Java编程思想】十五：类型信息/" class="leancloud_visitors" data-flag-title="【Java编程思想】十五：类型信息">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、为什么需要RTTI"><a href="#一、为什么需要RTTI" class="headerlink" title="一、为什么需要RTTI"></a>一、为什么需要RTTI</h1><p>&ensp;&ensp;&ensp;&ensp;RTTI（Run-Time-Type-Information），运行时类型信息。读《Java编程思想》这本书时是第一次知道这个词，于是先百度了一番，某乎上的讲解是这个概念最早是由本书的作者在《Think in C++》上提出的，实际上的意思与Java中的反射差不多。书中主要说的应用场景是在多态的过程中，基类的派生类使用基类提供的方法时，动态绑定以及向上转型相关，在最后阶段运行过程中找到自己对应的派生类。也正是有了RTTI，编译器才能正确的找到对应的派生类。上述思想是Java中多态思想的体现，多态也是Java中设计的关键思想，尽量使代码尽可能少的了解其具体的类型，而只与通用的类（基类）打交道。这种设计使代码逻辑更加简单、易于理解。</p>
<h1 id="二、Class对象"><a href="#二、Class对象" class="headerlink" title="二、Class对象"></a>二、Class对象</h1><p>&ensp;&ensp;&ensp;&ensp;要理解RTTI在Java中的工作原理，首先要知道类型信息在运行时是如何表示的。这项工作是由称为Class对象的一种特殊的对象表示的。面向对象思想告诉我们，万事万物都是对象，Java中除了基本的数据类型，其它的都是对象。那么如果我们有如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;我们使用new Student（）创建了一个Student类的对象，那么Student类又是不是对象呢？没错，如前文所说，万事万物都是对象，这里Student就是Class的对象，也就是说任何声明定义的类，都是Class类的类对象。当编译器编译完一个类时，在同名的.class文件中就会保存这个类的Class对象。而为了生成这个对象，运行这个类的JVM会使用一个称作是“类加载器”的子系统。</p>
<p>&ensp;&ensp;&ensp;&ensp;类加载器子系统实际上可以包含一条类加载器链，但只有一个原生的类加载器，它是JVM实现的一部分，用来加载所谓的可信类，以及JavaAPI。如果还需要其它特殊的操作，比如支持Web服务应用，或者是在网络上下载类，那么就可以在类加载器链上挂载额外的类加载器。</p>
<p>&ensp;&ensp;&ensp;&ensp;所有的类在其第一次加载的时候，都被动态的加载到JVM中，当程序创建第一个类的静态成员引用时，就会被加载。这也说明类的构造器也是类的静态方法，即使在构造器之前并没有使用static关键字。因此使用new关键词创建的类的新的对象，也会被当做是类的静态成员引用。也正是如此，Java程序在运行之前并非完全加载，动态加载在诸如C++这类的静态加载语言是无法实现的。</p>
<p>一旦某个类的Class对象被载入内存，它就用来创建这个类的所有对象，如下示例说明这点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Candy</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Loading Candy"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gum</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Loading Gum"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cookie</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Loading Cookie"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SweetShop</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Inside main"</span>);</span><br><span class="line">		<span class="keyword">new</span> Candy();</span><br><span class="line">		System.out.println(<span class="string">"After Creating Candy"</span>);</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Class.forName(<span class="string">"com.chenxyt.java.practice.Gum"</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">			System.err.println(<span class="string">"Gum Not found"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"After Creating Gum"</span>);</span><br><span class="line">		<span class="keyword">new</span> Cookie();</span><br><span class="line">		System.out.println(<span class="string">"After Creating Cookie"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/20/【Java编程思想】十五：类型信息/png1.png" alt="png1"></p>
<p>&ensp;&ensp;&ensp;&ensp;可以看到Class对象仅在需要的时候被加载，static初始化是在类加载时候进行的。需要注意的是Class.forName（）这个方法，它是Class类的一个静态方法，所有的类都是Class类的对象，forName（）是取得Class对象引用的一种方法。它使用目标类名作为参数，返回Class对象的引用。如果找不到指定的类名则抛出ClassNotFound异常。无论何时你想获取到类的运行时使用的类型信息，就必须要获得恰当的Class对象的引用，Class.forName（）是实现此功能的捷径。因此你不需要为了获得Class对象的引用而持有该类型的对象。但是如果你已经拥有了一个指定类型的对象，那么就可以使用.getClass方法获取Class对象的引用。这个方法属于Object，它将返回表示该对象实际类型的Class对象引用。</p>
<p>Class还有很多实用的方法，如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HasBatteries</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">WaterProof</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shoots</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toy</span></span>&#123;</span><br><span class="line">	Toy()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	Toy(<span class="keyword">int</span> i)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FancyToy</span> <span class="keyword">extends</span> <span class="title">Toy</span> <span class="keyword">implements</span> <span class="title">HasBatteries</span>,<span class="title">WaterProof</span>,<span class="title">Shoots</span></span>&#123;</span><br><span class="line">	FancyToy() &#123;</span><br><span class="line">		<span class="keyword">super</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToyTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printInfo</span><span class="params">(Class cc)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Class Name:"</span> + cc.getName() + <span class="string">" Is Interface?"</span> + cc.isInterface());</span><br><span class="line">		System.out.println(<span class="string">"Simple Name:"</span> + cc.getSimpleName());</span><br><span class="line">		System.out.println(<span class="string">"Canonical Name:"</span> + cc.getCanonicalName());</span><br><span class="line">		System.out.println(<span class="string">"----------"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Class c = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="comment">//获取指定类的类对象引用</span></span><br><span class="line">			c = Class.forName(<span class="string">"com.chenxyt.java.practice.FancyToy"</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">			System.err.println(<span class="string">"Class Not Found"</span>);</span><br><span class="line">			System.exit(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		printInfo(c);</span><br><span class="line">		<span class="comment">//获取该类实现的接口</span></span><br><span class="line">		<span class="keyword">for</span>(Class face:c.getInterfaces())&#123;</span><br><span class="line">			printInfo(face);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取该类的基类</span></span><br><span class="line">		Class up = c.getSuperclass();</span><br><span class="line">		Object obj = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="comment">//Class类的构造器 用来构造不确定类型的对象</span></span><br><span class="line">			obj = up.newInstance();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InstantiationException e1)&#123;</span><br><span class="line">			System.err.println(e1);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(IllegalAccessException e2)&#123;</span><br><span class="line">			System.err.println(e2);</span><br><span class="line">		&#125;</span><br><span class="line">		printInfo(obj.getClass());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/20/【Java编程思想】十五：类型信息/png2.png" alt="png2"></p>
<p>&ensp;&ensp;&ensp;&ensp;FancyToy继承了Toy并实现了三个接口，使用Class.forName（）方法创建一个FancyToy类的类对象，并指向引用c。getName（）产生全类名，getSimpleName（）获取不带包路径的类名，getCanonicalName（）获取全类名。isInterface（）判断当前类的类型是不是接口，Class.getInterfaces（）返回当前类的全部接口。如果你已经有了一个Class对象，还可以使用getSuperClass（）获取这个类的基类。Class的newInstance（）方法是实现了一个“虚拟的构造器”，意思是我不知道你的确切类型，但是你必须要正确的进行构造。使用newInstance（）创建的类，必须要带有默认构造器。</p>
<p>&ensp;&ensp;&ensp;&ensp;Java中除了以上两种Class.forName()和obj.getClass()可以产生类的对象引用，还有一种类字面常量的形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FancyToy.class：</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;这样做不仅简单，而且更加安全，因为在编译时即可检查，无需使用try-catch语句，所以更加高效。类字面常量不仅可以应用与普通的类，还可以应用在基本数据类型，以及接口和数组中。此外对于基本数据类型的包装器类，它还有个TYPE字段，TYPE是一个引用，指向对应的基本数据类型的Class对象。</p>
<p>&ensp;&ensp;&ensp;&ensp;此处有一点非常重要需要注意，当使用.class来创建对象的引用时，不会自动的初始化该Class对象。为了使用类而做的准备工作实际上包含三个步骤：<br><strong>1.加载</strong>：这是由类加载器执行的，该步骤将查找字节码（通常在classpath路径查找，但不是必须的），并从这些字节码中创建一个Class对象；<br><strong>2.链接</strong>：在链接阶段验证类的字节码，为静态域分配存储空间，并且如果必要的话，会解析这个类创建的对其它类的所有引用；<br><strong>3.初始化</strong>：如果该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化块。<br>初始化被延迟到了对静态方法（构造器也是隐式的静态方法）或者非常数静态域进行首次引用时才执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Initable</span></span>&#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> staticFinal = <span class="number">45</span>;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> staticFinal2 = ClassInitialization.rand.nextInt(<span class="number">1000</span>);</span><br><span class="line"> <span class="keyword">static</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"Initializing Initable"</span>);</span><br><span class="line">  System.out.println(<span class="string">"Initable---------------"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Initable2</span></span>&#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> staticNonFinal = <span class="number">145</span>;</span><br><span class="line"> <span class="keyword">static</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"Initializing Initable2"</span>);</span><br><span class="line">  System.out.println(<span class="string">"Initable2---------------"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Initable3</span></span>&#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> staticNonFinal = <span class="number">54</span>;</span><br><span class="line"> <span class="keyword">static</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"Initializing Initable3"</span>);</span><br><span class="line">  System.out.println(<span class="string">"Initable3---------------"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitialization</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">45</span>);</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">  Class initable = Initable.class;</span><br><span class="line">  System.out.println(<span class="string">"After Creating Initable Ref"</span>);</span><br><span class="line">  System.out.println(Initable.staticFinal);</span><br><span class="line">  System.out.println(<span class="string">"------------------"</span>);</span><br><span class="line">  System.out.println(Initable.staticFinal2);</span><br><span class="line">  System.out.println(Initable2.staticNonFinal);</span><br><span class="line">  Class initable3 = Class.forName(<span class="string">"com.chenxyt.java.practice.Initable3"</span>);</span><br><span class="line">  System.out.println(<span class="string">"After Creating Initable3 Ref"</span>);</span><br><span class="line">  System.out.println(Initable3.staticNonFinal);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/20/【Java编程思想】十五：类型信息/png3.png" alt="png3"></p>
<p>&ensp;&ensp;&ensp;&ensp;从结果中可以看出.class并不会引发初始化，相反使用Class.forName（）时则立刻完成了初始化的功能。同时，如果一个域被声明为static final的编译时常量，那么它可以不初始化类就被访问，就像Initable.staticFinal一样，但是仅仅被声明为static final并不会保证类不被初始化就能访问，就像Intable.staticFinal2那样，因为它不是编译时常量。<br>&ensp;&ensp;&ensp;&ensp;如果一个static域不是final的，那么在对它访问的时候，总是要求在读取之前先进行链接（为这个域分配存储空间）和初始化（初始化该存储空间），就像在对Initable2.staticNonFinal的访问中看到这样。<br>Class类允许使用泛型指定相应的类型，如下两种形式均可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClassReference</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Class intClass = <span class="keyword">int</span>.class;</span><br><span class="line">		Class&lt;Integer&gt; genericIntClass = <span class="keyword">int</span>.class;</span><br><span class="line">		genericIntClass = Integer.class;</span><br><span class="line">		intClass = <span class="keyword">double</span>.class;</span><br><span class="line">		<span class="comment">//类型不匹配</span></span><br><span class="line">	<span class="comment">//	genericIntClass = double.class;</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;普通的类引用不会产生警告信息，并可以被重新指定为其它类型的引用。而泛型类的引用只能被指定为指定的类型。通过使用泛型语法，可以使编译器做一些额外的类型检查。如果我们希望放松这种限制，那么似乎可以使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Number&gt; genericClass = <span class="keyword">int</span>.class;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;因为Integer类继承自Number类，但实际上并不可以正常工作，因为Integer Class对象不是Number Class对象的子类。为了放松这种类型的限制，我们使用了通配符，它是Java泛型的一部分。通配符就是“？”表示任何事物。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; intClass = <span class="keyword">int</span>.class:</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;尽管看起来这种形式与直接使用Class相同，但是它不会产生编译器警告信息。更确切的说使用通配符表示的是你并非是碰巧或者是由于疏忽而选择了一个非具体类的引用，而是你就是明确的选择了一个非具体的版本。使用通配符与extends关键字，可以有效的解决前边所说的继承的问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;? extends Number&gt; genericClass = <span class="keyword">int</span>.class;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;表示创建一个Number 或是它子类的类对象。</p>
<h1 id="三、类型转换器先做检查"><a href="#三、类型转换器先做检查" class="headerlink" title="三、类型转换器先做检查"></a>三、类型转换器先做检查</h1><p>&ensp;&ensp;&ensp;&ensp;目前的类型转换信息有两种，一种是传统的类型转换，由RTTI确保类型转换，如果执行了一个错误的类型转换，那么将抛出一个ClassCastException异常，另一种是代表对象类类型的Class对象，通过查询Class对象的信息获取运行时的所有状态。RTTI在Java中还有第三种类型转换的形式，就是使用关键字instanceof，它返回布尔值，判断某个对象是不是某个特定类的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">    (Dog)x.bark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;这种先进行判断然后再使用的方式显得很必然，比如在进行向下转型的时候，如果不先进行判断，很容易发生ClassCastException异常。此外也提供了动态判断的形式isInstanceof（）方法。</p>
<h2 id="四、注册工厂"><a href="#四、注册工厂" class="headerlink" title="四、注册工厂"></a>四、注册工厂</h2><p>&ensp;&ensp;&ensp;&ensp;使用注册工厂的目的是将对象的创建工作交给类去完成，即创建一个工厂方法，然后进行多态的调用，从而为你创建恰当类型的对象。在如下的简单的版本中，工厂方法就是Factory接口中的Create方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span>&lt;<span class="title">T</span>&gt;</span>&#123;<span class="function">T <span class="title">create</span><span class="params">()</span></span>;&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;所谓工厂方法，就是意味着我只提供一个创建实例的工厂方法，而无需每创建一个继承类就编写一个新的方法。关于工厂方法更多细节后边在设计模式模块专门再进行学习。</p>
<h1 id="五、instanceof与Class的等价性"><a href="#五、instanceof与Class的等价性" class="headerlink" title="五、instanceof与Class的等价性"></a>五、instanceof与Class的等价性</h1><p>&ensp;&ensp;&ensp;&ensp;在查询类型信息的时候，instanceof与直接比较Class对象有一点很重要的区别，例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseType</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">BaseType</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FamilyVsExactType</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Object x)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Testing x of type"</span> + x.getClass());</span><br><span class="line">		System.out.println(<span class="string">"x instance of BaseType"</span> + (x <span class="keyword">instanceof</span> BaseType));</span><br><span class="line">		System.out.println(<span class="string">"x instance of Derived"</span> + (x <span class="keyword">instanceof</span> Derived));</span><br><span class="line">		System.out.println(<span class="string">"BaseType.isInstance(x)"</span> + BaseType.class.isInstance(x));</span><br><span class="line">		System.out.println(<span class="string">"Derived isInstance(x)"</span> + Derived.class.isInstance(x));</span><br><span class="line">		System.out.println(<span class="string">"x.getClass == BaseType.class"</span> + (x.getClass() == BaseType.class));</span><br><span class="line">		System.out.println(<span class="string">"x.getClass == Derived.class"</span> + (x.getClass() == Derived.class));</span><br><span class="line">		System.out.println(<span class="string">"x.getClass.equals(BaseType.class)"</span> + (x.getClass().equals(BaseType.class)));</span><br><span class="line">		System.out.println(<span class="string">"x.getClass.equals(Derived.class)"</span> + (x.getClass().equals(Derived.class)));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		test(<span class="keyword">new</span> BaseType());</span><br><span class="line">		test(<span class="keyword">new</span> Derived());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/20/【Java编程思想】十五：类型信息/png4.png" alt="png4"></p>
<p>&ensp;&ensp;&ensp;&ensp;可以看出，instanceof表示的是“你是这个类吗？或者你是这个类的子类吗？”而使用Class对象进行比较时，表示的则只有明确的类型信息，忽略了继承的关系。</p>
<h2 id="六、反射：运行时类型信息"><a href="#六、反射：运行时类型信息" class="headerlink" title="六、反射：运行时类型信息"></a>六、反射：运行时类型信息</h2><p>&ensp;&ensp;&ensp;&ensp;我理解的反射概念是程序在编译的时候并不知道具体的类型信息，直到程序运行时通过反射才获取到了准确的类信息。这里提供了几个方法支持获取准确的类信息，以便创建动态的代码。使用Class类的getMethods（）方法可以获取这个类所包含的所有方法，使用getConstructors（）方法可以获取这个类的所有构造函数。前文也提到过，使用Class.forName（）可以用来动态的加载类。它的生成结果在编译的时候是不可知的，因此所有的方法特征信息和签名都是在运行时被提取出来的。</p>
<h1 id="七、动态代理"><a href="#七、动态代理" class="headerlink" title="七、动态代理"></a>七、动态代理</h1><p>&ensp;&ensp;&ensp;&ensp;代理是常用的设计模式之一，它的作用是在基本的对象操作之外，增加一些其它额外的操作。比如我想使用一个对象，同事想了解这个对象的运行过程，那么这个运行过程的监控显然就不能放在基本的对象代码中。有点类似前面文章中提到的组合类的思想，新建一个代理类，代理类引用要使用的对象，然后增加一些新的功能。刚好前几天跟公司一个同事面了一个新人，同事问道代理模式之后自己做了一些阐述，可以把代理模式类比成是中介，中介的目的是卖东西的基础上赚钱，卖东西就是基本操作，赚钱就是中介也就是代理做的额外的操作。下面一个示例展示简单的代理模式：</p>
<p>先定义一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">somethingElse</span><span class="params">(String arg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是这个接口的实现类，也就是前边所说的真正要操作的运行的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealObject</span> <span class="keyword">implements</span> <span class="title">Interface</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"RealObject DoSomeThing"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">somethingElse</span><span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"RealObject somethingElse"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;然后定义一个代理类，代理类实现了Interface接口，同时通过传参的形式传入了前边的实现类，在完成实现类功能的基础上，做了自己的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleProxy</span> <span class="keyword">implements</span> <span class="title">Interface</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Interface proxied;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SimpleProxy</span><span class="params">(Interface proxied)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		<span class="keyword">this</span>.proxied = proxied;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Proxy DoSomething"</span>);</span><br><span class="line">		proxied.doSomeThing();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">somethingElse</span><span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Proxy somethingElse"</span>);</span><br><span class="line">		proxied.somethingElse(arg);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;最后是Main方法，因为consumer方法传参是Interface接口，所以任何实现了它接口的实体类都可以当做参数。这里演示了使用基本的实体类和使用代理的区别，代理在完成普通实体类的功能基础上打印了自己的操作内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleProxyDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">(Interface iface)</span></span>&#123;</span><br><span class="line">		iface.doSomeThing();</span><br><span class="line">		iface.somethingElse(<span class="string">"bobo"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		consumer(<span class="keyword">new</span> RealObject());</span><br><span class="line">		System.out.println(<span class="string">"=============="</span>);</span><br><span class="line">		consumer(<span class="keyword">new</span> SimpleProxy(<span class="keyword">new</span> RealObject()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/11/20/【Java编程思想】十五：类型信息/png5.png" alt="png5"></p>
<p>&ensp;&ensp;&ensp;&ensp;在任何时刻你若想实现一些与“实际”对象分离的额外操作，或者你希望很容易能对这部分操作做出修改，那么使用代理模式无疑是最为方便的。</p>
<p>&ensp;&ensp;&ensp;&ensp;Java的动态代理比代理的思想更向前迈进了一步，因为它可以动态的创建代理，并且动态的处理对所代理方法的调用。动态代理所做的所有操作都会被重定向到单一的调用处理器上，它的工作是揭示调用的类型，并确定相应的对策。下面用动态代理重写上边的示例。</p>
<p>&ensp;&ensp;&ensp;&ensp;Java中要实现动态代理类，必须要继承InvocationHandle这个类，这个类内部嵌入的对象是要被实现的真正的对象，同样使用构造方法传入，这个类唯一的一个方法invoke，它有三个参数，第一个参数是生成的动态代理类。这里我个人理解，既然动态代理是动态的创建代理，那么这个参数固然是所创建的动态代理，第二个参数是传入的对象执行的方法，第三个参数是传入的参数。最后将请求通过Method.invoke（）方法，传入必要的参数，执行代理对象的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Object proxied;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(Object proxied)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		<span class="keyword">this</span>.proxied = proxied;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"**** Proxy:"</span> + proxy.getClass() + <span class="string">",method:"</span> + method + <span class="string">",args "</span> + args );</span><br><span class="line">		<span class="keyword">if</span>(args!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(Object arg:args)&#123;</span><br><span class="line">				System.out.println(<span class="string">"  "</span> + arg);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> method.invoke(proxied, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDynamicProxyDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">(Interface iface)</span></span>&#123;</span><br><span class="line">		iface.doSomeThing();</span><br><span class="line">		iface.somethingElse(<span class="string">"DIDI"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		RealObject real = <span class="keyword">new</span> RealObject();</span><br><span class="line">		consumer(real);</span><br><span class="line">		System.out.println(<span class="string">"========="</span>);</span><br><span class="line">		Interface proxy = (Interface)Proxy.newProxyInstance(Interface.class.getClassLoader(),<span class="keyword">new</span> Class[]&#123;Interface.class&#125;,<span class="keyword">new</span> DynamicProxyHandler(real));</span><br><span class="line">		consumer(proxy);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;客户端类使用Proxy.newProxyInstance（）方法创建了一个代理对象。第一个参数是一个加载器，这里用的是系统加载器，所以使用其它类的加载器结果也是一样的，第二个参数是代理对象要实现的接口，第三个参数是Handler对象，表示我这个代理对象在调用方法时，会映射关联到哪个Hnadler上去，这里是关联到了我们定义的DynamicProxyHandler上，然后转由它的invoke方法执行对象方法。</p>
<p>运行结果：</p>
<p><img src="/2018/11/20/【Java编程思想】十五：类型信息/png6.png" alt="png6"></p>
<p>&ensp;&ensp;&ensp;&ensp;我们可以在代理方法invoke（）中对诸如方法名、参数进行过滤，只执行指定的方法。</p>
<p>&ensp;&ensp;&ensp;&ensp;最近项目中用到了AOP做日志记录的功能，Spring的AOP核心思想就是动态代理，现在更加理解了一些，简单表述一下就是在切入点处执行一写其它操作，如我这里是记录日志，然后执行正常的业务方法。记录日志就是脱离在实际业务之外的一些操作。</p>
<h1 id="八、空对象"><a href="#八、空对象" class="headerlink" title="八、空对象"></a>八、空对象</h1><p>&ensp;&ensp;&ensp;&ensp;这里感觉不是很常用，大概理解了一下，就是当一个对象为null的时候，任何对这个对象的操作都会引发异常。为了避免这种情况，当一个对象为null的时候，我们定义一个空对象赋值给它。何谓空对象呢？就是一个不存在实际意义但是不会引发异常的对象。文中具体代码就不写了。</p>
<h1 id="九、接口与类型信息"><a href="#九、接口与类型信息" class="headerlink" title="九、接口与类型信息"></a>九、接口与类型信息</h1><p>&ensp;&ensp;&ensp;&ensp;接口或者是面向接口编程的重要目的是实现隔离，也就是解耦。但是通过类型信息，这种耦合还是会传播出去。也就是接口对解耦来说，并不是绝对的。如下示例：</p>
<p>定义一个接口A，它有唯一一个方法f</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是接口的实现B，除了A中的方法，还有自己的方法g</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"method f"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    System.out.println(<span class="string">"method g"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceViolation</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		A a = <span class="keyword">new</span> B();</span><br><span class="line">		a.f();</span><br><span class="line">		System.out.println(<span class="string">"a.getClass: "</span> + a.getClass().getName());</span><br><span class="line">		<span class="keyword">if</span>(a <span class="keyword">instanceof</span> B)&#123;</span><br><span class="line">			B b = (B)a;</span><br><span class="line">			b.g();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/20/【Java编程思想】十五：类型信息/png7.png" alt="png7"></p>
<p>&ensp;&ensp;&ensp;&ensp;这里通过使用RTTI，发现a是被当做B类型实现的，因此通过将其转型成B，可以调用了B中新加的方法。</p>
<p>&ensp;&ensp;&ensp;&ensp;上面这种操作，完全合理并且可接受，但是提高了代码的耦合度，实际上并不允许这样做。解决办法是使用包访问权限来加以控制。</p>
<p>新定义一个实现类实现接口A：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	System.out.println(<span class="string">"C.f"</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"C.g"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">u</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"C.u"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"C.v"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"C.w"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HidenC</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title">makeA</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> C();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在另一个包中使用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.test;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.chenxyt.java.practice.A;</span><br><span class="line"><span class="keyword">import</span> com.chenxyt.java.practice.HidenC;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiddenImplementation</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		A a = HidenC.makeA();</span><br><span class="line">		a.f();</span><br><span class="line">		System.out.println(<span class="string">"a.getClass: "</span> + a.getClass().getName());</span><br><span class="line">		<span class="comment">//编译错误 受包访问权限控制</span></span><br><span class="line"><span class="comment">/*		if(a instanceof C)&#123;</span></span><br><span class="line"><span class="comment">			C c = (C)a;</span></span><br><span class="line"><span class="comment">			c.g();</span></span><br><span class="line"><span class="comment">		&#125;*/</span></span><br><span class="line">		callHiddenMethod(a,<span class="string">"g"</span>);</span><br><span class="line">		callHiddenMethod(a,<span class="string">"v"</span>);</span><br><span class="line">		callHiddenMethod(a,<span class="string">"u"</span>);</span><br><span class="line">		callHiddenMethod(a,<span class="string">"w"</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callHiddenMethod</span><span class="params">(Object a,String methodName)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		Method g = a.getClass().getDeclaredMethod(methodName);</span><br><span class="line">		g.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		g.invoke(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/20/【Java编程思想】十五：类型信息/png8.png" alt="png8"></p>
<p>&ensp;&ensp;&ensp;&ensp;可以看到由于包访问权限的限制，在另一个包中获取不到了C新定义的方法。但是如果知道方法名，依然可以通过反射调用所有的方法。当然如果通过只发布编译之后的代码或许可以阻止这种情况发生，但是实际结果并不是这样。如下：</p>
<p><img src="/2018/11/20/【Java编程思想】十五：类型信息/png9.png" alt="png9"></p>
<p>&ensp;&ensp;&ensp;&ensp;使用javap -private 可以看到包括private权限的方法在内的所有方法。因此任何人都可以获取到你这个类中方法名，然后通过反射调用他们。</p>
<p>接下来将接口实现为私有内部类看一下效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.test;</span><br><span class="line"><span class="keyword">import</span> com.chenxyt.java.practice.A;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerA</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			System.out.println(<span class="string">"C.f"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"C.g"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">u</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"C.u"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"C.v"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"C.w"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title">makeA</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> C();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerImplemention</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		A a = InnerA.makeA();</span><br><span class="line">		a.f();</span><br><span class="line">		System.out.println(<span class="string">"a.getClass "</span> + a.getClass().getName());</span><br><span class="line">		HiddenImplementation.callHiddenMethod(a,<span class="string">"g"</span>);</span><br><span class="line">		HiddenImplementation.callHiddenMethod(a,<span class="string">"u"</span>);</span><br><span class="line">		HiddenImplementation.callHiddenMethod(a,<span class="string">"v"</span>);</span><br><span class="line">		HiddenImplementation.callHiddenMethod(a,<span class="string">"w"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/20/【Java编程思想】十五：类型信息/png10.png" alt="png10"></p>
<p>&ensp;&ensp;&ensp;&ensp;可见使用内部类还是不能躲避反射的查找。</p>
<p>接下来试一下匿名类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.test;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.chenxyt.java.practice.A;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnoymousA</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title">makeA</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> A()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				System.out.println(<span class="string">"C.f"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"C.g"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="function"><span class="keyword">void</span> <span class="title">u</span><span class="params">()</span></span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"C.u"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">()</span></span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"C.v"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">()</span></span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"C.w"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnoymousImplemention</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		A a = AnoymousA.makeA();</span><br><span class="line">		a.f();</span><br><span class="line">		System.out.println(<span class="string">"a.getClass"</span> + a.getClass().getName());</span><br><span class="line">		HiddenImplementation.callHiddenMethod(a,<span class="string">"g"</span>);</span><br><span class="line">		HiddenImplementation.callHiddenMethod(a,<span class="string">"u"</span>);</span><br><span class="line">		HiddenImplementation.callHiddenMethod(a,<span class="string">"v"</span>);</span><br><span class="line">		HiddenImplementation.callHiddenMethod(a,<span class="string">"w"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/20/【Java编程思想】十五：类型信息/png11.png" alt="png11"></p>
<p>&ensp;&ensp;&ensp;&ensp;可见匿名类也被反射给找到了。即便是private域的方法也逃不过反射的到来。</p>
<p>&ensp;&ensp;&ensp;&ensp;书中最后一段讲述，如果有人通过这种所谓的投机的方式获取内部私有的方法，那么他就应该接受这种方法改变之后带来的后果。</p>
<h1 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h1><p>&ensp;&ensp;&ensp;&ensp;反射这一章节，看的前后拖的时间比较长了，基本理解了反射的概念，比如在运行时获取类型信息，通过class对象可以获得这个类的全部信息啊一些，因为文中涉及到一些设计模式，所以又补充了一下设计模式的知识。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/19/【Java编程思想】十四：字符串/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crayon Cxy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ordinary Road">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/19/【Java编程思想】十四：字符串/" itemprop="url">【Java编程思想】十四：字符串</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-19T19:50:56+08:00">
                2018-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/19/【Java编程思想】十四：字符串/" class="leancloud_visitors" data-flag-title="【Java编程思想】十四：字符串">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&ensp;&ensp;&ensp;&ensp;大量程序表明，字符串操作是程序设计中的最基本操作。</p>
<h1 id="一、不可变String"><a href="#一、不可变String" class="headerlink" title="一、不可变String"></a>一、不可变String</h1><p>&ensp;&ensp;&ensp;&ensp;String对象是不可变的，每一个看似修改了String值的方法，实际都是产生了一个新的字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Immutable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">upCase</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String q = <span class="string">"howdy"</span>;</span><br><span class="line">		System.out.println(q);</span><br><span class="line">		String qq = upCase(q);</span><br><span class="line">		System.out.println(qq);</span><br><span class="line">		System.out.println(q);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/19/【Java编程思想】十四：字符串/png1.png" alt="png1"></p>
<p>&ensp;&ensp;&ensp;&ensp;当把q传给upCase方法时，实际上传递的是引用的一个拷贝。其实每当String对象作为参数传递时，传递的都是一个拷贝。再看upCase方法，只有当该方法运行时，局部引用s才存在，一旦该方法结束，引用s就消失了。该方法的返回值，实际上是最终值的引用，也就是upCase返回的引用已经指向了一个新的对象，而原本的q并没有发生任何变化。比如如下的方法，我们并不希望在经过一个操作之后，改变原有的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"abcde"</span>;</span><br><span class="line">String x = Immutable.upCase(s);</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;因为方法的参数是用来传递信息的，而不是用来改变原有对象本身的。</p>
<h1 id="二、重载“-”与StringBuilder"><a href="#二、重载“-”与StringBuilder" class="headerlink" title="二、重载“+”与StringBuilder"></a>二、重载“+”与StringBuilder</h1><p>&ensp;&ensp;&ensp;&ensp;String对象是不可变的，所以指向它的任何引用都不会改变该对象的值。不可变性会对效率带来一个问题，为String对象重载“+”操作符就是一个例子，重载的意思是一个操作符应用与特定的类时被赋有特殊的意义。（用于String的“+”和”+=”是Java中仅有的两个重载过的操作符，Java不允许程序员自己重载操作符）<br>操作符“+”可以用来连接两个String</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Concatetion</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String mango = <span class="string">"mango"</span>;</span><br><span class="line">		String s = <span class="string">"abc"</span> + mango + <span class="string">"def"</span> + <span class="number">42</span>;</span><br><span class="line">		System.out.println(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/19/【Java编程思想】十四：字符串/png2.png" alt="png2"></p>
<p>&ensp;&ensp;&ensp;&ensp;上述代码的运行过程可能是这样的：String可能有一个append方法，然后它会生成一个新的String对象用来连接abc和mango，然后该对象再与def相连生成新的对象，依次类推。这样做的话会产生很多中间垃圾需要清理因此它效率极低。<br>我们使用JDK自带的反编译工具查看上述代码如何工作：</p>
<p><img src="/2018/11/19/【Java编程思想】十四：字符串/png3.png" alt="png3"></p>
<p>&ensp;&ensp;&ensp;&ensp;我们代码中并没有使用StringBuilder类，然而编译器却自动的引入了StringBuilder类，从编译后的代码可以看出，字符串连接工作主要的操作是编译器创建一个StringBuilder对象，然后调用该对象的append（）方法将所有的要连接的字符串连接到后边，最后调用toString（）方法转换成String对象存给s。<br>&ensp;&ensp;&ensp;&ensp;因此在编写一个类似toString（）的方法时，如果字符串较短时，我们可以使用普通的拼接方式，当字符串操作较为复杂的时候，我们在代码中直接创建一个StringBuilder对象进行操作效率会更加优异。</p>
<h1 id="三、无意识的递归"><a href="#三、无意识的递归" class="headerlink" title="三、无意识的递归"></a>三、无意识的递归</h1><p>&ensp;&ensp;&ensp;&ensp;我们希望使用toString（）方法打印出对象的内存地址，那么我们可能会考虑使用this关键字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfiniteRecursion</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"InfiniteRecursion address"</span> + <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;InfiniteRecursion&gt; v = <span class="keyword">new</span> ArrayList&lt;InfiniteRecursion&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">			v.add(<span class="keyword">new</span> InfiniteRecursion());</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/19/【Java编程思想】十四：字符串/png4.png" alt="png4"></p>
<p>这里当运行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">"InfiniteRecursion address"</span> + <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure>
<p>时发生了类型转换，编译器发现“+”后边不是String类型，会试图转换成String类型，转换的方式就是调用toString方法，因此会递归调用，此处如果想正确打印地址，那么需要使用其基类Object的toString（）方法。</p>
<h1 id="四、String上的操作"><a href="#四、String上的操作" class="headerlink" title="四、String上的操作"></a>四、String上的操作</h1><p>&ensp;&ensp;&ensp;&ensp;所有的类都是Class类的对象，使用Class类的getMethods（）方法可以返回该类的所有方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringMethods</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Class&lt;String&gt; c = String.class;</span><br><span class="line">		Method[] methods = c.getMethods();</span><br><span class="line">		<span class="keyword">for</span>(Method method :methods)&#123;</span><br><span class="line">			System.out.println(method);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> java.lang.String.hashCode()</span><br><span class="line"><span class="comment">//比较两个字符串 重载了Object的方法 当两个字符串值相同、类型相同则认为相同 忽略了引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> java.lang.String.equals(java.lang.Object)</span><br><span class="line"><span class="keyword">public</span> java.lang.String java.lang.String.toString()</span><br><span class="line"><span class="comment">//获取指定索引下标位置上的字符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">char</span> java.lang.String.charAt(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> java.lang.String.codePointAt(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> java.lang.String.codePointBefore(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> java.lang.String.codePointCount(<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> java.lang.String.compareTo(java.lang.Object)</span><br><span class="line"><span class="comment">//按词典顺序比较两个字符串 大小写并不等价</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> java.lang.String.compareTo(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> java.lang.String.compareToIgnoreCase(java.lang.String)</span><br><span class="line"><span class="comment">//字符串连接 返回一个新的String为指定String连接参数</span></span><br><span class="line"><span class="keyword">public</span> java.lang.String java.lang.String.concat(java.lang.String)</span><br><span class="line"><span class="comment">//查找字符串中是否包含指定字符 存在返回true</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> java.lang.String.contains(java.lang.CharSequence)</span><br><span class="line"><span class="comment">//比较两个字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> java.lang.String.contentEquals(java.lang.StringBuffer)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> java.lang.String.contentEquals(java.lang.CharSequence)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.String java.lang.String.copyValueOf(<span class="keyword">char</span>[])</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.String java.lang.String.copyValueOf(<span class="keyword">char</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> java.lang.String.endsWith(java.lang.String)</span><br><span class="line"><span class="comment">//比较字符串是否相同 忽略大小写</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> java.lang.String.equalsIgnoreCase(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.String java.lang.String.format(java.lang.String,java.lang.Object[])</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.String java.lang.String.format(java.util.Locale,java.lang.String,java.lang.Object[])</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> java.lang.String.getBytes(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">byte</span>[],<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] java.lang.String.getBytes(java.lang.String) <span class="keyword">throws</span> java.io.UnsupportedEncodingException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] java.lang.String.getBytes(java.nio.charset.Charset)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] java.lang.String.getBytes()</span><br><span class="line"><span class="comment">// s.getChars(1,2,char,3) 赋值s串中下标为1-2的到char中 char中起始位置为3</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> java.lang.String.getChars(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">char</span>[],<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> java.lang.String.indexOf(<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> java.lang.String.indexOf(java.lang.String,<span class="keyword">int</span>)</span><br><span class="line"><span class="comment">//是否包含该字符 包含返回下标 否则返回-1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> java.lang.String.indexOf(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> java.lang.String.indexOf(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> java.lang.String java.lang.String.intern()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> java.lang.String.isEmpty()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> java.lang.String.lastIndexOf(<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> java.lang.String.lastIndexOf(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> java.lang.String.lastIndexOf(java.lang.String,<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> java.lang.String.lastIndexOf(<span class="keyword">int</span>)</span><br><span class="line"><span class="comment">//String 中字符的个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> java.lang.String.length()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> java.lang.String.matches(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> java.lang.String.offsetByCodePoints(<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> java.lang.String.regionMatches(<span class="keyword">boolean</span>,<span class="keyword">int</span>,java.lang.String,<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> java.lang.String.regionMatches(<span class="keyword">int</span>,java.lang.String,<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br><span class="line"><span class="comment">//把字符串中的第一个参数字符替换成第二个</span></span><br><span class="line"><span class="keyword">public</span> java.lang.String java.lang.String.replace(<span class="keyword">char</span>,<span class="keyword">char</span>)</span><br><span class="line"><span class="keyword">public</span> java.lang.String java.lang.String.replace(java.lang.CharSequence,java.lang.CharSequence)</span><br><span class="line"><span class="keyword">public</span> java.lang.String java.lang.String.replaceAll(java.lang.String,java.lang.String)</span><br><span class="line"><span class="keyword">public</span> java.lang.String java.lang.String.replaceFirst(java.lang.String,java.lang.String)</span><br><span class="line"><span class="keyword">public</span> java.lang.String[] java.lang.String.split(java.lang.String,<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> java.lang.String[] java.lang.String.split(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> java.lang.String.startsWith(java.lang.String,<span class="keyword">int</span>)</span><br><span class="line"><span class="comment">//字符串起始串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> java.lang.String.startsWith(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> java.lang.CharSequence java.lang.String.subSequence(<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br><span class="line"><span class="comment">//字符串截断</span></span><br><span class="line"><span class="keyword">public</span> java.lang.String java.lang.String.substring(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> java.lang.String java.lang.String.substring(<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br><span class="line"><span class="comment">//返回一个字符数组，该字符数组包含字符串的所有字符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[] java.lang.String.toCharArray()</span><br><span class="line"><span class="comment">//字符串字符转换成小写</span></span><br><span class="line"><span class="keyword">public</span> java.lang.String java.lang.String.toLowerCase()</span><br><span class="line"><span class="keyword">public</span> java.lang.String java.lang.String.toLowerCase(java.util.Locale)</span><br><span class="line"><span class="comment">//字符串字符转换成大写</span></span><br><span class="line"><span class="keyword">public</span> java.lang.String java.lang.String.toUpperCase()</span><br><span class="line"><span class="keyword">public</span> java.lang.String java.lang.String.toUpperCase(java.util.Locale)</span><br><span class="line"><span class="comment">//删除String两端的空白字符</span></span><br><span class="line"><span class="keyword">public</span> java.lang.String java.lang.String.trim()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.String java.lang.String.valueOf(<span class="keyword">char</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.String java.lang.String.valueOf(<span class="keyword">float</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.String java.lang.String.valueOf(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.String java.lang.String.valueOf(<span class="keyword">long</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.String java.lang.String.valueOf(<span class="keyword">double</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.String java.lang.String.valueOf(java.lang.Object)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.String java.lang.String.valueOf(<span class="keyword">char</span>[])</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.String java.lang.String.valueOf(<span class="keyword">char</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.String java.lang.String.valueOf(<span class="keyword">boolean</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> java.lang.Class java.lang.Object.getClass()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notify()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notifyAll()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="keyword">long</span>,<span class="keyword">int</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="keyword">long</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait() <span class="keyword">throws</span> java.lang.InterruptedException</span><br></pre></td></tr></table></figure>
<p>注释了一些常用的方法，其它的方法可自行查阅。</p>
<h1 id="五、格式化输出"><a href="#五、格式化输出" class="headerlink" title="五、格式化输出"></a>五、格式化输出</h1><p>&ensp;&ensp;&ensp;&ensp;JavaSE5提供了格式化输出功能，这一功能使得控制输出的功能变得更加简单，同时也给开发者带来了更加强大的代码输出控制能力。JavaSE5引入的format方法可以用于PrintStream或PrintWriter对象，其中也包括System.out对象。format（）方法模仿在C语言的printf（）如下简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFormat</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">double</span> y = <span class="number">5.333221</span>;</span><br><span class="line">		System.out.println(<span class="string">"Row1: ["</span> + x + <span class="string">" "</span> + y + <span class="string">"]"</span>);</span><br><span class="line">		System.out.format(<span class="string">"Row1: [%d %f]\n"</span>,x,y);</span><br><span class="line">		System.out.printf(<span class="string">"Row1: [%d %f]\n"</span>,x,y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/19/【Java编程思想】十四：字符串/png5.png" alt="png5"></p>
<p>可以看到，format（）与printf（）相同，只需要加上对应的格式化字符即可。</p>
<p>&ensp;&ensp;&ensp;&ensp;Java中所有新的格式化功能都由java.util.Formatter类处理，可以将其看做是一个翻译器，它将你的格式化字符串和数据翻译成想要的结果。当你创建了一个Formatter对象的时候，需要向编译器传递一些信息，告诉他最终的结果将向哪里输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Formatter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tutle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> Formatter f;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Tutle</span><span class="params">(String name,Formatter f)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.f = f;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">		f.format(<span class="string">"%s The Tutle is at (%d,%d)\n"</span>,name,x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Tutle tommy = <span class="keyword">new</span> Tutle(<span class="string">"Tommy"</span>,<span class="keyword">new</span> Formatter(System.out));</span><br><span class="line">		Tutle terry = <span class="keyword">new</span> Tutle(<span class="string">"Terry"</span>,<span class="keyword">new</span> Formatter(System.err));</span><br><span class="line">		tommy.move(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">		terry.move(<span class="number">4</span>, <span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/19/【Java编程思想】十四：字符串/png6.png" alt="png6"></p>
<p>如上我们指定了格式化输出的结果分别打印到了System.out和System.err上</p>
<p>&ensp;&ensp;&ensp;&ensp;有的时候我们希望做一些更精致的格式化信息，比如控制空格与对齐，最常见的是控制域的最小尺寸，这可以通过指定width实现，Formatter对象通过在必要时添加空格，来确保一个域至少达到某个长度。默认情况下域是右对齐的，不过也可以通过“-”指定数据的对齐方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.util.Formatter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reciept</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> Formatter f = <span class="keyword">new</span> Formatter(System.out);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTitle</span><span class="params">()</span></span>&#123;</span><br><span class="line">		f.format(<span class="string">"%-15s %5s %10s\n"</span>,<span class="string">"Item"</span>,<span class="string">"Qty"</span>,<span class="string">"Price"</span>);</span><br><span class="line">		f.format(<span class="string">"%-15s %5s %10s\n"</span>,<span class="string">"----"</span>,<span class="string">"---"</span>,<span class="string">"-----"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String name,<span class="keyword">int</span> qty,<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">		f.format(<span class="string">"%-15.15s %5d %10.2f\n"</span>,name,qty,price);</span><br><span class="line">		total+=price;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTotal</span><span class="params">()</span></span>&#123;</span><br><span class="line">		f.format(<span class="string">"%-15.15s %5s %10.2f\n"</span>,<span class="string">"Tax"</span>,<span class="string">""</span>,total*<span class="number">0.06</span>);</span><br><span class="line">		f.format(<span class="string">"%-15.15s %5s %10s\n"</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">"------"</span>);</span><br><span class="line">		f.format(<span class="string">"%-15.15s %5s %10.2f\n"</span>,<span class="string">"Total"</span>,<span class="string">""</span>,total*<span class="number">1.06</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Reciept receipt = <span class="keyword">new</span> Reciept();</span><br><span class="line">		receipt.printTitle();</span><br><span class="line">		receipt.print(<span class="string">"Jack's Magic Beans"</span>,<span class="number">4</span>,<span class="number">4.25</span>);</span><br><span class="line">		receipt.print(<span class="string">"Princess Beans"</span>,<span class="number">3</span>,<span class="number">5.1</span>);</span><br><span class="line">		receipt.print(<span class="string">"Thres Bears Porridge"</span>,<span class="number">1</span>,<span class="number">14.25</span>);</span><br><span class="line">		receipt.printTotal();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/19/【Java编程思想】十四：字符串/png7.png" alt="png7"></p>
<p>可以看到Formatter类提供了很强大的格式化支持</p>
<p>Formatter类也有很多类型转换，常用的类型转换如下</p>
<p>d：整数型（十进制）e：浮点数（科学计数）c：Unicode字符 x：整数（十六进制）b：Boolean值 h：散列码（十六进制）s：String %：字符“%”f：浮点数（十进制），针对不同的数据类型，有些转换是无效的，如果强制使用则会发生异常。</p>
<h1 id="六、正则表达式"><a href="#六、正则表达式" class="headerlink" title="六、正则表达式"></a>六、正则表达式</h1><p>&ensp;&ensp;&ensp;&ensp;正则表达式就是以某种方式来描述字符串，因此你可以说“如果一个字符串含有某些东西，那么它就是我需要的东西”。\d表示一位数字，Java中对于\反斜线有不同的处理，在其它语言中，\表示我想插入一个普通的反斜线，而在Java中\表示我将要插入一个正则表达式反斜线，所以它后边的值应该具有特殊意义。例如你想表示一个数字，那么就是\d，如果想插入一个普通的反斜线，则需要使用\\，不过制表之类的应该使用单反斜线，\d\n，使用？表示可能存在，使用+表示一个或多个+之前的表达式。比如我们要判断可能有一个负号后边跟着一个或多个数字则使用：</p>
<p>-？\d+</p>
<p>应用正则的最简单方式是使用String类提供的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerMatch</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"-1234"</span>.matches(<span class="string">"-?\\d+"</span>));</span><br><span class="line">		System.out.println(<span class="string">"5678"</span>.matches(<span class="string">"-?\\d+"</span>));</span><br><span class="line">		System.out.println(<span class="string">"+911"</span>.matches(<span class="string">"-?\\d+"</span>));</span><br><span class="line">		System.out.println(<span class="string">"+911"</span>.matches(<span class="string">"(-|\\+)?\\d+"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/19/【Java编程思想】十四：字符串/png8.png" alt="png8"></p>
<p>&ensp;&ensp;&ensp;&ensp;前两个满足正则表达式的结果，第三个“+“作为一个独立的符号，所以与”可能有个负号开头的一个或多个整数“不匹配，应该使用”可能有一个正号或者符号开头的一个或多个整数“，括号有着分组的作用，|表示或。</p>
<p>&ensp;&ensp;&ensp;&ensp;String类还带有一个非常有用的正则表达式方法split（），功能是将字符串在正则表达式匹配的地方分割开：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice; <span class="keyword">import</span> java.util.Arrays; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Splitting</span> </span>&#123; <span class="keyword">public</span> <span class="keyword">static</span> String knights = <span class="string">"Then。when you have found the shrubbery.you must"</span> + <span class="string">"cut down the mightiest tree in the forest。。。"</span> + <span class="string">"with... a herring"</span>; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(String regex)</span></span>&#123; System.out.println(Arrays.toString(knights.split(regex))); &#125; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; split(<span class="string">" "</span>); split(<span class="string">"\\W+"</span>);</span><br><span class="line">split(<span class="string">"\\w+"</span>);</span><br><span class="line">split(<span class="string">"n\\W+"</span>); &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/19/【Java编程思想】十四：字符串/png9.png" alt="png9"></p>
<p>&ensp;&ensp;&ensp;&ensp;第一个是使用空格拆分，\W表示非单词字符，\w表示单词字符，第三个表示字母n以及后边的一个或多个非单词字符。可见与正则表达式相同的内容都消失了。</p>
<p>&ensp;&ensp;&ensp;&ensp;String类自带的最后一个正则表达式方法为替换，你可以替换正则表达式第一个匹配的子串，也可以替换所有匹配的地方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Replacing</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> String s = Splitting.knights;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        System.out.println(s.replaceFirst(<span class="string">"f\\w+"</span>,<span class="string">"located"</span>));  </span><br><span class="line">        System.out.println(s.replaceAll(<span class="string">"shrubbery|tree|herring"</span>,<span class="string">"banana"</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/19/【Java编程思想】十四：字符串/png10.png" alt="png10"></p>
<p>&ensp;&ensp;&ensp;&ensp;第一个正则表示以字母f开头后面跟着一个或多个字母的，将第一个匹配的子串替换成“located”，第二个表达式是替换三个单词中的任意一个，只要存在则替换。</p>
<p>&ensp;&ensp;&ensp;&ensp;我们也可以自己创建正则表达式，java.util.regex.Pattern类提供了完整的正则表达式列表，先列举一些常用的：</p>
<p><img src="/2018/11/19/【Java编程思想】十四：字符串/png11.png" alt="png11"></p>
<p>&ensp;&ensp;&ensp;&ensp;以下是一些字符类创建的典型方式，以及一些预定义类。</p>
<p><img src="/2018/11/19/【Java编程思想】十四：字符串/png12.png" alt="png12"></p>
<p>作为演示，下面的每一个正则表达式都可以成功的匹配“Rudolph“</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rudolph</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(String parten:<span class="keyword">new</span> String[]&#123;<span class="string">"Rudolph"</span>,<span class="string">"[rR]udolph"</span>,<span class="string">"[rR][aeiou][a-z]ol.*"</span>,<span class="string">"R.*"</span>&#125;)&#123;</span><br><span class="line">			System.out.println(<span class="string">"Rudolph"</span>.matches(parten));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/19/【Java编程思想】十四：字符串/png13.png" alt="png13"></p>
<p>&ensp;&ensp;&ensp;&ensp;我们的任务是在能够完成任务的情况下编写简单的易于理解的正则表达式，而不是编写难以理解的正则表达式。<br>我们在使用正则表达式的时候很容易混淆，因为他是一种在Java之上的新语言，CharSequence，该接口从CharBuffer、String、StringBuffer、StringBuilder类之中抽象出了字符序列的一般化定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> i )</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，这些类都实现了该接口，多数正则表达式操作都接受CharSequence类型的参数。</p>
<p>&ensp;&ensp;&ensp;&ensp;String类作为正则表达式的匹配使用功能有限，因此我们可以使用更为强大的正则表达式对象。只需要导入java.util.regex包，然后使用Pattern.compile（）方法编译正则表达式。它会根据传入的String类型的正则表达式生成一个Pattern对象，接下来把我们想要检索的字符串传入Pattern.matcher（）方法，该方法会生成一个Matcher对象，它有很多功能可以使用。<br>以下为演示示例，第一个控制台参数为要匹配的字符串，后边一个或多个参数都为正则表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRegularExpression</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(args.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">"Usage:\n java TestRegularExpression "</span> + <span class="string">"characterSequence regularExpression+"</span>);</span><br><span class="line">			System.exit(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"Input: \""</span> + args[<span class="number">0</span>] + <span class="string">"\""</span>);</span><br><span class="line">		<span class="keyword">for</span>(String arg:args)&#123;</span><br><span class="line">			System.out.println(<span class="string">"Regular expression: \""</span> + arg + <span class="string">"\""</span>);</span><br><span class="line">			<span class="comment">//编译正则表达式</span></span><br><span class="line">			Pattern p = Pattern.compile(arg);</span><br><span class="line">			<span class="comment">//传入字符串进行匹配</span></span><br><span class="line">			Matcher m = p.matcher(args[<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">				System.out.println(<span class="string">"Match \""</span> + m.group() + <span class="string">"\" at positions "</span> + m.start() + <span class="string">"-"</span> + (m.end() - <span class="number">1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/19/【Java编程思想】十四：字符串/png14.png" alt="png14"></p>
<p>&ensp;&ensp;&ensp;&ensp;Matcher.find（）方法用来查找字符串中的多个匹配。start（）方法返回匹配的起始位置的索引，end（）方法匹配的终止位置的索引。</p>
<h1 id="七、扫描输入"><a href="#七、扫描输入" class="headerlink" title="七、扫描输入"></a>七、扫描输入</h1><p>&ensp;&ensp;&ensp;&ensp;目前来说，读取文本或者从标准输入读取数据一般的解决方法是读入一行文本，然后对其进行分词，然后使用Integer、Double的各种解析方法来解析数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.StringReader;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRead</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> StringReader(<span class="string">"Sir Robin of Camelot\n22 1.523222"</span>));</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"What's your name?"</span>);</span><br><span class="line">			String name = input.readLine();</span><br><span class="line">			System.out.println(name);</span><br><span class="line">			System.out.println(<span class="string">"How old are you?What's your favorite double"</span>);</span><br><span class="line">			String numbers = input.readLine();</span><br><span class="line">			System.out.println(numbers);</span><br><span class="line">			String numArray[] = numbers.split(<span class="string">" "</span>);</span><br><span class="line">			<span class="keyword">int</span> age = Integer.parseInt(numArray[<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">double</span> favorite = Double.parseDouble(numArray[<span class="number">1</span>]);</span><br><span class="line">			System.out.format(<span class="string">"Hi %s.\n"</span>,name);</span><br><span class="line">			System.out.format(<span class="string">"In 5 years you will be %d. \n"</span>,age+<span class="number">5</span>);</span><br><span class="line">			System.out.format(<span class="string">"My Favorite double is %f."</span>,favorite/<span class="number">2</span>);</span><br><span class="line">			&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">				System.err.println(<span class="string">"I/O Exception"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/19/【Java编程思想】十四：字符串/png15.png" alt="png15"></p>
<p>&ensp;&ensp;&ensp;&ensp;以上代码中，使用了IO中的readLine（）方法读取输入流中的一行，然后进行解析。终于在JavaSE5新增了Scanner类，它可以大大的减轻扫描输入的工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BetterRead</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner stdin = <span class="keyword">new</span> Scanner(SimpleRead.input);</span><br><span class="line">		System.out.println(<span class="string">"What's your name?"</span>);</span><br><span class="line">		String name = stdin.nextLine();</span><br><span class="line">		System.out.println(name);</span><br><span class="line">		System.out.println(<span class="string">"How old are you?What's your favorite double"</span>);</span><br><span class="line">		System.out.println(<span class="string">"(input:&lt;age&gt;&lt;double&gt;)"</span>);</span><br><span class="line">		<span class="keyword">int</span> age = stdin.nextInt();</span><br><span class="line">		<span class="keyword">double</span> favorite = stdin.nextDouble();</span><br><span class="line">		System.out.println(age);</span><br><span class="line">		System.out.println(favorite);</span><br><span class="line">		System.out.format(<span class="string">"Hi %s.\n"</span>,name);</span><br><span class="line">		System.out.format(<span class="string">"In 5 years you will be %d. \n"</span>,age+<span class="number">5</span>);</span><br><span class="line">		System.out.format(<span class="string">"My Favorite double is %f."</span>,favorite/<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/19/【Java编程思想】十四：字符串/png16.png" alt="png16"></p>
<p>&ensp;&ensp;&ensp;&ensp;Scanner的构造器可以接受任意类型的输入对象，其普通的next方法将返回一个String，而所有的基本类型都有一个next方法，该方法的作用是，读取到下一个完整的指定类型的分词之后才返回。同时Scanner还有对应的hasNext方法，用来判断是否有所输入分词的类型。<br>Scanner默认的定界符为空白符，我们也可以自己使用正则表达式指定分隔符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannerDelimiter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner scanner = <span class="keyword">new</span> Scanner(<span class="string">"12,24    ,35,67"</span>);</span><br><span class="line">		scanner.useDelimiter(<span class="string">"\\s*,\\s*"</span>);</span><br><span class="line">		<span class="keyword">while</span>(scanner.hasNextInt())&#123;</span><br><span class="line">			System.out.println(scanner.nextInt());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/19/【Java编程思想】十四：字符串/png17.png" alt="png17"></p>
<p>&ensp;&ensp;&ensp;&ensp;这个例子使用逗号以及任意的空白字符来实现字符串的分割。使用useDelimiter（）方法设置定界符，也可以使用delimiter（）方法返回现在所使用的定界符。</p>
<p>&ensp;&ensp;&ensp;&ensp;Scanner除了可以扫描基本类型外，还可以扫描正则表达式，这在扫描复杂数据类型的时候非常有用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.MatchResult;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadAnalyzer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> String threatData = <span class="string">"58.27.82.161@02/10/2005\n"</span> +</span><br><span class="line">								<span class="string">"204.45.234.40@02/11/2005\n"</span> +</span><br><span class="line">								<span class="string">"58.27.82.161@02/11/2005\n"</span> +</span><br><span class="line">								<span class="string">"58.27.82.161@02/11/2005\n"</span> +</span><br><span class="line">								<span class="string">"58.27.82.161@02/11/2005\n"</span> +</span><br><span class="line">								<span class="string">"[Next log section width different data format]"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner scanner = <span class="keyword">new</span> Scanner(threatData);</span><br><span class="line">		String pattern = <span class="string">"(\\d+[.]\\d+[.]\\d+[.]\\d+)@"</span> + <span class="string">"(\\d&#123;2&#125;/\\d&#123;2&#125;/\\d&#123;4&#125;)"</span>;</span><br><span class="line">		<span class="keyword">while</span>(scanner.hasNext(pattern))&#123;</span><br><span class="line">			scanner.next(pattern);</span><br><span class="line">			MatchResult match = scanner.match();</span><br><span class="line">			String ip = match.group(<span class="number">1</span>);</span><br><span class="line">			String date = match.group(<span class="number">2</span>);</span><br><span class="line">			System.out.format(<span class="string">"Thread on %s from %s\n"</span>,date,ip);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/19/【Java编程思想】十四：字符串/png18.png" alt="png18"></p>
<p>&ensp;&ensp;&ensp;&ensp;当next（）方法配合指定正则表达式使用时，将找到下一个匹配该模式的输入部分，调用match（）方法获得匹配的结果。有一点需要注意，它只针对下一个输入分词进行匹配，如果正则表达式含有定界符，那将永远不能成功。</p>
<h1 id="八、StringTokenizer"><a href="#八、StringTokenizer" class="headerlink" title="八、StringTokenizer"></a>八、StringTokenizer</h1><p>&ensp;&ensp;&ensp;&ensp;在正则表达式和Scanner引入之前，我们使用的是StringTokenizer来进行字符串匹配，下面演示这种方式并与其它方式进行比较：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplacingStringTokenizer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String input = <span class="string">"But I'm not dead yet!I feel happy!"</span>;</span><br><span class="line">		StringTokenizer stoke = <span class="keyword">new</span> StringTokenizer(input);</span><br><span class="line">		<span class="keyword">while</span>(stoke.hasMoreElements())&#123;</span><br><span class="line">			System.out.print(stoke.nextToken() + <span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">			System.out.println(Arrays.toString(input.split(<span class="string">" "</span>)));</span><br><span class="line">			Scanner scanner = <span class="keyword">new</span> Scanner(input);</span><br><span class="line">			<span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">				System.out.print(scanner.next() + <span class="string">" "</span>);</span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/19/【Java编程思想】十四：字符串/png19.png" alt="png19"></p>
<p>&ensp;&ensp;&ensp;&ensp;使用正则表达式或者Scanner我们可以使用更加复杂的模式匹配字符串，而使用StringTokenizer则很困难了，因此实际上StringTokenizer这个类基本上已经被废弃了。</p>
<h1 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h1><p>&ensp;&ensp;&ensp;&ensp;String类型作为程序设计中最为常见的一种操作类型，它是一种不可变的操作类型。它内部重载了“+”操作符，使得可以使用”+”操作符完成字符串的拼接工作，拼接的原理是编译器为我们自动生成了StringBuilder类来完成。因此对于复杂的字符串拼接操作，我们自己使用StringBuilder效率会更高一些。String还有很多常用的方法，正则表达式为我们提供了字符串匹配的多种形式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/16/【Java编程思想】十三：通过异常处理错误/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crayon Cxy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ordinary Road">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/16/【Java编程思想】十三：通过异常处理错误/" itemprop="url">【Java编程思想】十三：通过异常处理错误</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-16T09:24:08+08:00">
                2018-11-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/16/【Java编程思想】十三：通过异常处理错误/" class="leancloud_visitors" data-flag-title="【Java编程思想】十三：通过异常处理错误">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&ensp;&ensp;&ensp;&ensp;错误的理想时机是在程序的编写过程中，但是一些业务逻辑错误，在编写过程中很难发现。这些问题就只能在程序运行的过程中解决。这就需要程序在运行过程中发生错误的时候能够准确的提供信息给某个接收者，以便可以正确的处理错误。</p>
<p>&ensp;&ensp;&ensp;&ensp;Java中提供了一种非常优秀的处理错误的手段，被称为“异常处理”，下文讲述如何编写正确的异常处理程序，并将展示方法出现问题时，如何自定义异常。</p>
<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p>&ensp;&ensp;&ensp;&ensp;C语言以及其它早期的编程语言都是采用一种约定俗称的模式，比如在发生错误的时候，返回一个错误标记，或者设置一个特殊的变量来记录错误。这种形式需要增加大量的判断以及额外的代码无疑使程序更加繁重不利于构建。</p>
<p>&ensp;&ensp;&ensp;&ensp;解决的方法是，用强制规定的形式来消除错误处理过程中随心所欲的因素。“异常”这个词有“我对此感到意外”的意思，当错误问题出现了，你可能不知道出现在哪里，或者出现了什么错误，也不知道怎么解决。那么就停下来，将这个问题提供给更高的环境，看看有没有正确的解决方案。使用异常的另一个好处是，它能够明显的降低代码的复杂程度，避免了大量的错误检查，只需要在一个特定的地方进行异常捕获，并且不需要做任何判断，异常捕获区能够捕获所有发生的错误。这种异常的处理方式与之前的错误处理方式相比，完全的将“正常做的事儿”与“出现问题怎么办”隔离开来。是代码的读写变得更加井井有条。</p>
<h1 id="二、基本异常"><a href="#二、基本异常" class="headerlink" title="二、基本异常"></a>二、基本异常</h1><p>&ensp;&ensp;&ensp;&ensp;“异常情形”是指阻止当前方法或者作用域继续执行的问题，要把异常情形与普通问题区分开来，普通问题是指在当前的错误收集情况下，能够解决这个问题并继续执行正常的程序。而对于异常情形，这个程序就不能够正常的执行下去了。<br>&ensp;&ensp;&ensp;&ensp;除法是一个简单的例子，除数有可能为0，所以先进行检查很有必要。但除数为0如果是一个意外的值，你也不清楚该如何处理，那么抛出异常就显得尤为重要了，而不是顺着原来的路走下去。<br>&ensp;&ensp;&ensp;&ensp;当抛出异常之后有几件事儿会随之发生，同 Java中其它对象的创建相同，将使用new在堆上创建对象，然后当前程序的执行路径被终止了，因为发生了异常，不能继续执行下去，并且从当前执行的环境中弹出异常对象的引用。此时，异常处理机制接管程序，并开始寻找一个恰当的地方继续执行程序，这个恰当的地方就是异常处理程序。它的任务是使程序从错误的状态中恢复，要么换一种方式运行，要么继续运行下去。<br>&ensp;&ensp;&ensp;&ensp;举一个抛出异常的简单例子，对于一个对象引用t，传递给你的时候可能没有被初始化，所以在使用这个对象引用调用执行方法之前，进行合理的判断是非常有必要的。可以创建一个代表错误信息的对象，并且将它从当前环境中抛出，这样就把错误异常抛到更大的环境中去了。所以一个异常，看起来是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(t==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;上面代码中，我们判断当前对象引用是否没有进行初始化，如果没有进行初始化，那么就创建一个NullPointerException（）对象，然后使用throw关键字，将该对象的引用抛出。</p>
<p>&ensp;&ensp;&ensp;&ensp;异常使我们将每件事都当做一个事务考虑，我们还可以将异常看作是一种内建的恢复系统，因为我们在程序中拥有不同的恢复点，如果程序的某部分失败了，异常将“恢复”到程序的某个已知点上。异常最大的好处就是在发生错误的时候能够强制程序终止当前线路的运行。<br>&ensp;&ensp;&ensp;&ensp;同其它对象的处理方式一样，我们使用new关键字在堆上创建异常对象，因此同样伴随着存储空间的分配和构造器的调用。所有标准异常器都有两个构造函数，一个是无参构造函数，另一个是可以传递一个字符串的构造函数，将相关信息放入到构造器中。此外，异常处理能够抛出任意类型的Throwable对象，它是异常类型的根类。通常对于不同类型的错误，要抛出对应的异常，错误信息可以保存在异常对象内部，或者使用异常的名称来暗示。</p>
<h1 id="三、捕获异常"><a href="#三、捕获异常" class="headerlink" title="三、捕获异常"></a>三、捕获异常</h1><p>&ensp;&ensp;&ensp;&ensp;我们可以在程序中专门定义一个方法块儿，用来尝试各种可能产生异常的方法，这个块的定义形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//---</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;在关键字try后包围的一部分代码块，称作try块，这样做比起之前说的要在每个会产生错误的地方进行判断要容易的多，并且代码的可读性大大增强，产生异常之后抛出的异常必须在某处得到处理，这个地点就是异常处理区，异常处理区紧跟着try块，使用catch关键字表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">try&#123; //---&#125;catch(Type1 arg1)&#123; //---&#125;catch(Type2 arg2)&#123;</span><br><span class="line">//---</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;每个catch语句看起来像是一个接收一个且仅接收一个的特殊参数类型的方法。可以在方法块内部处理这个参数，当然有的异常见名知意，因此可以不用处理参数，但并不可以省略。可以有多个catch块与try对应，用来捕获多种不同的异常。异常处理程序必须紧跟在try块之后，当异常被抛出之后，异常处理机制负责搜寻参数与异常类型相匹配的第一个处理程序。然后进入catch块中执行，此时认为异常得到了处理。一旦catch子句结束，则认为处理程序的查找过程结束。只有匹配的catch字句才会执行，在try块内部不同的方法可能会产生相同的异常，而你只需要提供一个针对此类型的异常处理程序。异常的处理理论上有两种模型，一种是终止模型，表示程序发生异常之后，已经无法恢复到程序正常执行的顺序上，程序被迫发生终止。另一种模型是恢复模型，表示异常发生时，我们要做的是处理错误，而不是抛出异常。目前终止模型已经基本取代了恢复模型，虽然这种恢复模型看起来很好，但是实际上使用起来并不容易。</p>
<h1 id="四、创建自定义异常"><a href="#四、创建自定义异常" class="headerlink" title="四、创建自定义异常"></a>四、创建自定义异常</h1><p>&ensp;&ensp;&ensp;&ensp;Java中虽然提供了很多默认的异常类型，但是要想完全覆盖会发生的异常情况显然是不现实的，因此我们可以自定义异常来表示我们预期可能会出现的异常。自定义的形式也非常简单，只需要继承一个相似的异常类即可。建立一个新的异常类最贱的方法就是让编译器为你产生默认构造器，所以这几乎不需要多少代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritingException</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> SimpleException</span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Throw SimpleException from f"</span>);  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SimpleException();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        InheritingException ite = <span class="keyword">new</span> InheritingException();  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            ite.f();  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(SimpleException e)&#123;  </span><br><span class="line">            System.out.println(<span class="string">"Caught it!"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/16/【Java编程思想】十三：通过异常处理错误/png1.png" alt="png1"></p>
<p>&ensp;&ensp;&ensp;&ensp;当然我们还可以创建一个带有参数的构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FullConstructors</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Throwing myException from f()"</span>);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> MyException();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> <span class="keyword">throws</span> MyException</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Throwing myException from g()"</span>);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"Originated in g()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			f();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(MyException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			g();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(MyException e)&#123;</span><br><span class="line">			e.printStackTrace(System.out);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/16/【Java编程思想】十三：通过异常处理错误/png2.png" alt="png2"></p>
<p>&ensp;&ensp;&ensp;&ensp;在带参数的异常构造器中，显示的调用了其基类的带参构造方法。在catch块的异常处理程序中，调用了在Throwable类（所有异常的基类）声明的printStackTrace方法，该方法如果不带参数则将异常信息也就是从方法调用处到异常产生出的所有方法调用信息打印到标准错误流上，如果带了标准输出流参数，则打印在标准输出流上。区别可以从控制台错误信息的眼神看出。标准错误流更加的引人注目。</p>
<h1 id="五、异常说明"><a href="#五、异常说明" class="headerlink" title="五、异常说明"></a>五、异常说明</h1><p>&ensp;&ensp;&ensp;&ensp;Java提供了相应的语法（并强制使用这个语法），使你可以使用礼貌的方式告知客户端程序员某个方法可能会抛出的异常类型，然后客户端程序员就可以进行相应的处理。这就是异常说明，它属于方法声明的一部分，紧跟在形式参数列表之后，使用throws关键字，后面接一个所有潜在异常类型的列表，所以方法定义可能看起来像是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> TooBig,TooSmall,DivZero</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;代码必须与异常说明一致，比如上边的方法，如果我们在main（）中调用，编译器会提示该方法会产生异常，要么使用try catch进行处理，要么使用throws关键字抛出这种异常。</p>
<h1 id="六、捕获所有异常"><a href="#六、捕获所有异常" class="headerlink" title="六、捕获所有异常"></a>六、捕获所有异常</h1><p>&ensp;&ensp;&ensp;&ensp; 我们可以使用所有异常类型的基类Exception来捕获所有的异常，即不管发生什么类型的异常，都能被捕获到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>（Exception e）&#123;</span><br><span class="line">    <span class="comment">//---</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;Exception是与编程相关的所有异常的基类（还有其它的基类），所以它不会具有太多的信息。不过可以调用它从其基类Throwable继承的方法</p>
<p>String getMessage（） 获取详细信息<br>String getLocalizedMessage（）获取用本地语言表示的详细信息<br>String toString（）返回对Throwable的简单描述<br>void printStackTrace（）打印Throwable的调用栈轨迹 输出到标准错误流<br>void printStackTrace（PrintStream）打印Throwable的调用栈轨迹 输出到可选择的流<br>void printStackTrace（PrintStream）打印Throwable的调用栈轨迹 输出到可选择的流<br>调用栈显示了“把你带到异常抛出地点”的方法调用序列。<br>&ensp;&ensp;&ensp;&ensp;Throwable fillInStackTrace（）用于在Throwable对象内部，记录栈帧的当前状态，这在程序重新抛出错误或者异常时很有必要。<br>&ensp;&ensp;&ensp;&ensp;此外，也可以使用Throwable从其基类Object继承的方法，getClass（）它将返回一个表示此类型的对象，然后可以使用getName（）方法查询这个Class对象包含包信息的名称，也可以使用getSimpleName（）返回只有类名的名称。<br>下面展示Exception类型方法的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionMethods</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"My Exception"</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">			System.out.println(<span class="string">"Caught Exception"</span>);</span><br><span class="line">			System.out.println(<span class="string">"getMessage():"</span> + e.getMessage());</span><br><span class="line">			System.out.println(<span class="string">"getLocalizedMessage():"</span> + e.getLocalizedMessage());</span><br><span class="line">			System.out.println(<span class="string">"toString()"</span> + e.toString());</span><br><span class="line">			System.out.println(<span class="string">"printStackTrace():--=="</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.out.println(<span class="string">"printStackTrace(System.out):--=="</span>);</span><br><span class="line">			e.printStackTrace(System.out);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/16/【Java编程思想】十三：通过异常处理错误/png3.png" alt="png3"></p>
<p>&ensp;&ensp;&ensp;&ensp;printStackTrace（）方法所提供的信息可以使用getStackTrace（）方法获取到，这个方法返回一个由栈轨迹元素所构成的数组，其中每一个元素都表示栈中的一帧。元素0为栈顶元素，表示调用序列最后的一个方法，也就是Throwable创建和抛出的地方，数组中最后一个元素为方法调用序列中的第一个调用方法。下面程序简单演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhoCalled</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">			<span class="keyword">for</span>(StackTraceElement ste : e.getStackTrace())&#123;</span><br><span class="line">				System.out.println(ste.getMethodName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">		f();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">		g();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		f();</span><br><span class="line">		System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">		g();</span><br><span class="line">		System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">		h();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/16/【Java编程思想】十三：通过异常处理错误/png4.png" alt="png4"></p>
<p>可以看到第一个打印的是异常抛出的方法，最后打印的是main（）函数方法。</p>
<p>&ensp;&ensp;&ensp;&ensp;有时候我们希望把刚捕获的异常抛出，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    System.out.println(<span class="string">"caught an exception"</span>);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;重抛异常会把异常抛给上一级环境中的异常处理程序，同一个try块后边的catch块将被忽略。此外，异常对象的所有信息都会被保持，所以上一级环境的异常捕获程序可以获得 这个异常的所有信息。如果只是单纯的把这个异常抛出，那么printStackTrace（）显示的将是原来这个异常的栈调用信息。如果想更新这个序列信息，可以使用fillInStackTrace（）方法，这将返回一个Throwable对象，它是把当前调用栈的信息，填入到原来那个异常对象而建立的。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReThrowing</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"the exception in f()"</span>);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"exception from f()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			f();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">			System.out.println(<span class="string">"inside g e.printStackTrace"</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">throw</span> e;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			f();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">			System.out.println(<span class="string">"inside h e.printStackTrace"</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">throw</span> (Exception)e.fillInStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			g();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">			System.out.println(<span class="string">"main:printStackTrace"</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			h();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">			System.out.println(<span class="string">"main:printStackTrace"</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/16/【Java编程思想】十三：通过异常处理错误/png5.png" alt="png5"></p>
<p>&ensp;&ensp;&ensp;&ensp;可以看出当使用了fillInStackTrace（）方法之后，调用栈中的方法栈信息发生了变化。当然如果在捕获了第一种异常之后抛出了另一种异常，那么调用栈的信息也会发生变化，类似使用了fillInStackTrace（）方法。但是这样做的话，原始的异常信息就消失了，有时候我们希望在抛出新的异常的时候能保留原来的异常信息，这被称作是异常链。在JDK1.4之前，程序员需要自己编写代码保存原来的异常信息，现在所有的Throwable子类都可以在构造函数中传入一个cause参数，这个参数就用来保存原始异常。这样就可以在当前位置创建并抛出新的异常，也可以通过这个异常链追踪到原始异常。</p>
<p>&ensp;&ensp;&ensp;&ensp;现在在所有Throwable的子类中，只有三种基本异常类型提供了带有cause参数的构造器，分别是Error、Exception、RuntimeException，对于其他类型的异常链接，应该使用initCause（）方法，而不是构造器。</p>
<h1 id="七、Java标准异常"><a href="#七、Java标准异常" class="headerlink" title="七、Java标准异常"></a>七、Java标准异常</h1><p>&ensp;&ensp;&ensp;&ensp;Throwable这个类表示任何可以被作为异常抛出的类，Error表示编译时的系统错误，一般不需要我们关心。Exception是可以被抛出的基本类型，在Java类库、用户方法以及运行时故障都可以抛出此类异常。所以Java程序员通常需要关心此类的异常信息，同时Java异常要求可以见名知意。Java中还有一种Runtime异常，它表示程序编程错误，无法由程序员自己控制，这种异常不需要我们自己主动捕获并抛出，程序会自动抛出此类异常，如前文提到的NullPointerException。</p>
<h1 id="八、使用finally进行清理"><a href="#八、使用finally进行清理" class="headerlink" title="八、使用finally进行清理"></a>八、使用finally进行清理</h1><p>&ensp;&ensp;&ensp;&ensp;对于一些代码，可能希望无论是否抛出异常，这些代码都必须要执行。这通常包括内存回收之外的一些操作，因为内存回收是由垃圾回收器完成。为了达到这个效果，可以在catch块之后加上finally块。在finally块中处理这些代码。完整的异常处理如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">//---</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e1)&#123;</span><br><span class="line">	<span class="comment">//---</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e2)&#123;</span><br><span class="line">	<span class="comment">//---</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="comment">//---</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;下面的示例用来证明finally字句不管异常是否抛出都能被执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyWorks</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(count++ == <span class="number">0</span>)&#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">"No Exception"</span>);</span><br><span class="line">				&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">					System.out.println(<span class="string">"Exception"</span>);</span><br><span class="line">				&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">					System.out.println(<span class="string">"In finally clause"</span>);</span><br><span class="line">					<span class="keyword">if</span>(count == <span class="number">2</span>)&#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;可以看到不管异常是否被抛出，finally字句都执行了。这个程序告诉我们，当程序发生了异常之后不能正确的回到原来的执行顺序上，我们可以在finally块中处理一些必要做的事情。比如打开文件的操作，当文件操作发生异常的时候，我们要确保文件被正确的关闭。</p>
<h1 id="九、异常的限制"><a href="#九、异常的限制" class="headerlink" title="九、异常的限制"></a>九、异常的限制</h1><p>&ensp;&ensp;&ensp;&ensp;当覆盖一个方法的时候，我们只能抛出在其基类方法异常说明列出的那些异常。这个限制的目的是符合面向对象的思想的，意味着其基类方法应用到派生类对象的时候，也能正常使用。异常也不例外。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseballException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foul</span> <span class="keyword">extends</span> <span class="title">BaseballException</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Strike</span> <span class="keyword">extends</span> <span class="title">BaseballException</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Inning</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Inning</span><span class="params">()</span> <span class="keyword">throws</span> BaseballException</span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">event</span><span class="params">()</span> <span class="keyword">throws</span> BaseballException</span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">atBat</span><span class="params">()</span> <span class="keyword">throws</span> Strike,Foul</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StormException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RainedOut</span> <span class="keyword">extends</span> <span class="title">StormException</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PopFoul</span> <span class="keyword">extends</span> <span class="title">Foul</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Storm</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">events</span><span class="params">()</span> <span class="keyword">throws</span> RainedOut</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rainHard</span><span class="params">()</span> <span class="keyword">throws</span> RainedOut</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StormyInning</span> <span class="keyword">extends</span> <span class="title">Inning</span> <span class="keyword">implements</span> <span class="title">Storm</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">StormyInning</span><span class="params">()</span> <span class="keyword">throws</span> BaseballException </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rainHard</span><span class="params">()</span> <span class="keyword">throws</span> RainedOut </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">atBat</span><span class="params">()</span> <span class="keyword">throws</span> Strike, Foul </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">events</span><span class="params">()</span> <span class="keyword">throws</span> RainedOut </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//抽象类中的该方法没有抛出任何异常 所以覆盖重写的时候 也不能抛出异常</span></span><br><span class="line"><span class="comment">//	public void walk() throws RainedOut&#123;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//抽象类中的该方法抛出了异常 重写的时候可以选择不抛出异常</span></span><br><span class="line"><span class="comment">//	public void event()&#123;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//抽象类中的该方法抛出了BaseballException 所以可以抛出其异常的子异常</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">event</span><span class="params">()</span> <span class="keyword">throws</span> Foul</span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;如注释上所述，当继承或者实现一个类的时候，这个子类只能抛出基类中异常列表中的异常，或者其子异常，或者不抛出异常，但是不能抛出其它异常，或者抛出异常的基类异常。</p>
<h1 id="十、构造器"><a href="#十、构造器" class="headerlink" title="十、构造器"></a>十、构造器</h1><p>&ensp;&ensp;&ensp;&ensp;“如果异常发生了，所有东西能被正确清理吗？”大多数情况都是非常安全的，可以使用finally进行清理。但是当使用构造函数的时候，就有些问题了。比如使用构造函数构造文件操作，因为finally语句不管构造成功或者失败都会执行。假如构造失败了，如果文件没有被打开，那么这时候如果执行finally关闭文件操作就是不正确的。还有，如果文件构造成功了，因为文件需要在后边使用，所以在finally中关闭文件显然是不合理的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputFile</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> BufferedReader in;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InputFile</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(name));</span><br><span class="line">		&#125;<span class="keyword">catch</span>(FileNotFoundException e1)&#123;</span><br><span class="line">			<span class="comment">//没有找到文件也就是文件没有打开 所以不需要清理</span></span><br><span class="line">			System.out.println(<span class="string">"The file is not found"</span>);</span><br><span class="line">			<span class="keyword">throw</span> e1;</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e2)&#123;</span><br><span class="line">			<span class="comment">//所有其它的异常都发生在文件打开之后 因此需要进行清理工作</span></span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				in.close();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(IOException e3)&#123;</span><br><span class="line">				<span class="comment">//---</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span> e2;</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="comment">//此处由于构造成功也会执行 所以不能进行文件关闭操作</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;对于这种需要在构造器中创建的对象，合理的做法是使用嵌套try-catch</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CleanUp</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			InputFile in = <span class="keyword">new</span> InputFile(<span class="string">"CleanUp.java"</span>);</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				<span class="comment">//</span></span><br><span class="line">			&#125;<span class="keyword">catch</span>(Exception e1)&#123;</span><br><span class="line">				<span class="comment">//此处为文件操作异常</span></span><br><span class="line">			&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">				<span class="comment">//-- 此处清理操作关闭文件</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e2)&#123;</span><br><span class="line">			<span class="comment">//--此处捕获构造异常</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="十一、异常匹配"><a href="#十一、异常匹配" class="headerlink" title="十一、异常匹配"></a>十一、异常匹配</h1><p>&ensp;&ensp;&ensp;&ensp;在抛出异常之后，异常处理系统会按照代码的编写顺序找到最近的异常处理程序并执行，此时便任务异常已经得到了处理，就不会继续进行下去。查找的时候并不要求抛出的异常同处理程序所声明的异常完全匹配，子类的对象也可以匹配到其基类的处理程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Annyoance</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneeze</span> <span class="keyword">extends</span> <span class="title">Annyoance</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Sneeze();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Sneeze s)&#123;</span><br><span class="line">			System.out.println(<span class="string">"Catch Sneeze"</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Annyoance a)&#123;</span><br><span class="line">			System.out.println(<span class="string">"Catch Annyoance1"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Sneeze();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Annyoance a)&#123;</span><br><span class="line">			System.out.println(<span class="string">"Catch Annyoance2"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/16/【Java编程思想】十三：通过异常处理错误/png6.png" alt="png6"></p>
<p>&ensp;&ensp;&ensp;&ensp;编译器发现Annyoance是Sneeze的基类，所以编译的过程会提示警告。</p>
<h1 id="十二、总结"><a href="#十二、总结" class="headerlink" title="十二、总结"></a>十二、总结</h1><p>&ensp;&ensp;&ensp;&ensp;异常是Java编程中不可或缺的一部分，它将程序正常执行的路径与错误处理分开，减少了编码判断的冗余。使用try-catch的方式进行异常处理，同时我们也可以创建自己的异常，继承其它的异常类。一些RuntimeException无需我们自己捕捉，程序会自动捕捉。注意构造器内发生异常的情况，因为构造器往往是只是简单的构造了一个对象，对象还需要使用，所以在使用finally进行清理的时候需要注意这一点。因为finally域的代码块不管异常是否发生都会执行。处理异常的时候可以使用基类Throwable提供的方法，比如使用printStackTrace打印栈的调用顺序。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/15/【Java编程思想】十二：持有对象/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crayon Cxy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ordinary Road">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/15/【Java编程思想】十二：持有对象/" itemprop="url">【Java编程思想】十二：持有对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-15T15:45:02+08:00">
                2018-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/15/【Java编程思想】十二：持有对象/" class="leancloud_visitors" data-flag-title="【Java编程思想】十二：持有对象">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&ensp;&ensp;&ensp;&ensp;在前面的学习过程中，我们使用的都是固定数量的且生命周期已知的对象。而在一些情况中，我们可能需要不确定数量不确切类型的对象，这种创建一个单一的对象显然是不行的了。Java提供了多种支持，比如数组，数组可以保存一组基本数据类型。但是数组的大小是固定的，在更特殊的编程条件下，固定长度显然是不友好的，所以Java类库提供了一套相当完整的容器类来解决这个问题。我们也称作是集合类。本章优先学习常用的集合以及用法，后续将会更加深入的讨论其它的集合。</p>
<h1 id="一、泛型和类型安全的容器"><a href="#一、泛型和类型安全的容器" class="headerlink" title="一、泛型和类型安全的容器"></a>一、泛型和类型安全的容器</h1><p>&ensp;&ensp;&ensp;&ensp;在JavaSE5泛型的概念出来之前，容器的一个主要问题就是编译器允许你在容器中插入任意类型的对象，这在一些情况下显然是不合理也是不可靠的。考虑这样一个情况，有一个存储Apple对象的容器，我们使用最基本最可靠的ArrayList，ArrayList你可以看成是一个可以自动扩充的数组。ArrayList需要使用索引就像数组下标一样，但是不需要使用方括号，它使用add（）插入对象，使用get（）获取对象，使用size（）获取长度。</p>
<p>&ensp;&ensp;&ensp;&ensp;在本例中Orange对象也会存在Apple容器中，正常情况下编译器会报出警告信息，此处使用@SuppressWarnings注解忽略没有类型检查的警告信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getid</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleAndOrangesWithoutGeneric</span> </span>&#123;</span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ArrayList al = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">			al.add(<span class="keyword">new</span> Apple());</span><br><span class="line">			al.add(<span class="keyword">new</span> Orange());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;al.size();i++)&#123;</span><br><span class="line">			Apple apple = (Apple) al.get(i);</span><br><span class="line">			System.out.println(apple.getid());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;在这里我们实际上存入ArrayList是Object对象，因为所有的类都继承自Object类，所以这里实际上不光可以添加Orange对象还可以添加任意类型的对象。我们在get（）获取数据的时候，我们以为获取的是一个Apple对象，实际上获取的是一个Obejct的引用，然后强制转换成我们需要的对象。在这里我们强制的将从ArrayList中取出的Object引用强制转换成Apple类型，那么当遇到这个对象类型实际上是Orange类型时，就会发生类型转换错误。所以说这种创建形式非常不安全。报错如下：</p>
<p><img src="/2018/11/15/【Java编程思想】十二：持有对象/png1.png" alt="png1"></p>
<p>&ensp;&ensp;&ensp;&ensp;JavaSE5之后引入了泛型的概念，这个概念应用在这种不确定类型的对象集合中最好不过。例如我们如果想创建一个Apple类型的容器，那么就可以使用ArrayList<apple> 其中&lt;&gt;括起来的是类型参数（可以有多个），它指定了这个容器可以保存的数据类型，在进入容器之前就限制了对象的类型，所以在取出数据的时候就不会发生类型转换错误了。相对来说是更加安全的。</apple></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getid</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleAndOrangesWithoutGeneric</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;Apple&gt; al = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">			al.add(<span class="keyword">new</span> Apple());</span><br><span class="line">		<span class="comment">//	al.add(new Orange());</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(Apple apple :al)&#123;</span><br><span class="line">			System.out.println(apple.getid());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;现在你可以阻止将Orange对象加入到Apple容器中了，并且我们可以使用for-each循环获取容器中的内容。实际上当我们固定了一种泛型数据参数，正如前面几章说到的，继承的时候基类收发的消息，子类也可以收发，所以泛型同样支持向上转型，我们可以传递其导出类参数。</p>
<h1 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h1><p>&ensp;&ensp;&ensp;&ensp;Java容器的用途是“保存对象”，并将其划分为两个不同的概念。</p>
<p><strong>&ensp;&ensp;&ensp;&ensp;Collection：</strong>一个独立的元素序列，这些元素都服从一条或多条规则。List必须按照插入的顺序保存对象，而Set不能有重复的元素。Queue按照排队的规则来确定对象的产生顺序。</p>
<p><strong>&ensp;&ensp;&ensp;&ensp;Map：</strong>一组成对的“键值对”对象，允许你使用键来查找值。ArrayList允许你使用数组查找值，所以某种意义上讲它是将对象与数字进行了绑定。</p>
<p>&ensp;&ensp;&ensp;&ensp;尽管并非总是这样，但是理想情况下我们都是与这些接口打交道。比如，我们可以像下边这样创建一个List:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;这里ArrayList已经被向上转型为List，使用接口的目的是如何修改它的实现，这里实现由ArrayList完成。这种方式并非永远有效，会带来一个其它的问题，ArrayList类可能新添加了其它的方法，因此当它向上转型为List时，可能会是不完善的。因此如果我们要使用这类方法，那就需要使用更加确切的类型。</p>
<h1 id="三、添加一组元素"><a href="#三、添加一组元素" class="headerlink" title="三、添加一组元素"></a>三、添加一组元素</h1><p>&ensp;&ensp;&ensp;&ensp;java.util包中Arrays和Collections都有很多实用的方法，可以在一个Collection中添加一组元素。<br>Arrays.asList()方法接受一个数组或者一组用逗号分隔的数据元素列表，并将其转化成一个List对象，但是实际底层是Array数组，因此该方法转换之后的对象不支持变更长度。<br>&ensp;&ensp;&ensp;&ensp;Collection.addAll()方法接受一个Collection对象，以及一个数组或者是一组用逗号分隔的元素列表，将后者添加到前者对象中。<br>&ensp;&ensp;&ensp;&ensp;下边的例子展示了上边两种方法，以及传统的Collection.addAll()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddingGroups</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Collection&lt;Integer&gt; collection = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">		Integer[] moreInts = &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">		collection.addAll(Arrays.asList(moreInts));</span><br><span class="line">		Collections.addAll(collection,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>);</span><br><span class="line">		Collections.addAll(collection,moreInts);</span><br><span class="line">		List&lt;Integer&gt; list = Arrays.asList(<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>);</span><br><span class="line">		list.set(<span class="number">1</span>,<span class="number">29</span>);</span><br><span class="line">		<span class="comment">//run error 数组不支持变更长度</span></span><br><span class="line">		list.add(<span class="number">21</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;Collection的构造器可以传递另一个Collection用来初始化，但是这种方式不如定义个空的Collection然后使用addAll的形式添加数据灵活</p>
<h1 id="四、容器的打印"><a href="#四、容器的打印" class="headerlink" title="四、容器的打印"></a>四、容器的打印</h1><p>&ensp;&ensp;&ensp;&ensp;基本类型的容器都带有toString（）的方法，以便打印。如下示例介绍了几种基本类型的容器的打印。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintingContainers</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Collection <span class="title">fill</span><span class="params">(Collection&lt;String&gt; collection)</span></span>&#123;</span><br><span class="line">		collection.add(<span class="string">"one"</span>);</span><br><span class="line">		collection.add(<span class="string">"two"</span>);</span><br><span class="line">		collection.add(<span class="string">"three"</span>);</span><br><span class="line">		collection.add(<span class="string">"four"</span>);</span><br><span class="line">		collection.add(<span class="string">"five"</span>);</span><br><span class="line">		collection.add(<span class="string">"five"</span>);</span><br><span class="line">		<span class="keyword">return</span> collection;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Map <span class="title">fill</span><span class="params">(Map&lt;String,String&gt; map)</span></span>&#123;</span><br><span class="line">		map.put(<span class="string">"one"</span>,<span class="string">"ONE"</span>);</span><br><span class="line">		map.put(<span class="string">"two"</span>,<span class="string">"TWO"</span>);</span><br><span class="line">		map.put(<span class="string">"three"</span>,<span class="string">"THREE"</span>);</span><br><span class="line">		map.put(<span class="string">"four"</span>,<span class="string">"FOUR"</span>);</span><br><span class="line">		map.put(<span class="string">"five"</span>,<span class="string">"FIVE"</span>);</span><br><span class="line">		map.put(<span class="string">"five"</span>,<span class="string">"FIVE"</span>);</span><br><span class="line">		<span class="keyword">return</span> map;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"ArrayList==="</span> + fill(<span class="keyword">new</span> ArrayList&lt;String&gt;()));</span><br><span class="line">		System.out.println(<span class="string">"LinkedList==="</span> + fill(<span class="keyword">new</span> LinkedList&lt;String&gt;()));</span><br><span class="line">		System.out.println(<span class="string">"HashSet==="</span> + fill(<span class="keyword">new</span> HashSet&lt;String&gt;()));</span><br><span class="line">		System.out.println(<span class="string">"TreeSet==="</span> + fill(<span class="keyword">new</span> TreeSet&lt;String&gt;()));</span><br><span class="line">		System.out.println(<span class="string">"LinkedHashSet==="</span> + fill(<span class="keyword">new</span> LinkedHashSet&lt;String&gt;()));</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"HashMap==="</span> + fill(<span class="keyword">new</span> HashMap&lt;String,String&gt;()));</span><br><span class="line">		System.out.println(<span class="string">"TreeMap==="</span> + fill(<span class="keyword">new</span> TreeMap&lt;String,String&gt;()));</span><br><span class="line">		System.out.println(<span class="string">"LinkedHashMap==="</span> + fill(<span class="keyword">new</span> LinkedHashMap&lt;String,String&gt;()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/15/【Java编程思想】十二：持有对象/png2.png" alt="png2"></p>
<p>&ensp;&ensp;&ensp;&ensp;这里展示了Java容器中的两种主要的类型：Collection和Map，Collection又包括List和Set他们每个位置只能保存一个数据。而Map保存数据的形式则是使用键值对“key-value”的形式。List：以特定的顺序保存数据，Set：集合中的元素都不能重复。Collection还包括另外一种Queue，它要求元素只能从集合的一端进入，从另一端取出。<br>&ensp;&ensp;&ensp;&ensp;从本例的输出结果可以看出，默认的容器带有的toString方法，可以很好的将容器中的数据展示出来。Collection使用[]括起来，Map使用{}括起来，键值对使用=连接。<br>&ensp;&ensp;&ensp;&ensp;接着分析打印输出，ArrayList和LinkedList都是List类型，它们能够按照元素的填入顺序进行打印。区别在于执行某些操作时候的性能不同，而且LinkedList的功能要多于ArrayList，这在后文介绍。<br>&ensp;&ensp;&ensp;&ensp;HashSet、TreeSet、LinkedHashSet都是Set类型，每个相同的元素只保存一个，HashSet使用了相当复杂的存储结构，后文会介绍，因此HashSet的存储顺序没有实际意义。TreeSet按元素比较结果的升序排序，LinkedHashSet与List相同，按照元素的插入顺序进行了排序。<br>&ensp;&ensp;&ensp;&ensp;Map也可以称作是关联数组，可以使用key查找对应的value，同时可以不用关心它们的大小。Map会自动的扩容。同时也不需要关心打印的顺序。</p>
<h1 id="五、List"><a href="#五、List" class="headerlink" title="五、List"></a>五、List</h1><p>&ensp;&ensp;&ensp;&ensp;List将元素按照插入的顺序排列起来，它在Collection的接口中增加了新的功能，使得可以在List的中间插入和删除元素。List有两种类型如上一节介绍:<br>&ensp;&ensp;&ensp;&ensp;1.ArrayList 优势在于随机访问的速度很快，但是在List中间插入和删除元素比较慢。<br>&ensp;&ensp;&ensp;&ensp;2.LinkedList 与上基本相反，它的特性集较ArrayList更大。<br>&ensp;&ensp;&ensp;&ensp;下面的一个例子展示List的一些特性，首先有个枚举类型，它有几个常量，然后是一个向List中增加数据的方法，这个方法我们使用的是ArrayList，注意前边说到，ArrayList增删操作性能消耗很大，如果我们的程序设计中出现了大量的ArrayList插入操作，那么可能会导致性能的降低</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">enum</span> Pet&#123;</span><br><span class="line">	Pet,Rat,Manx,Mutt,Pug,Cymric,Humaster</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pets</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Pet&gt; <span class="title">arrayList</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		List&lt;Pet&gt; pets = <span class="keyword">new</span> ArrayList&lt;Pet&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">			Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">			<span class="keyword">int</span> j = rand.nextInt(n);</span><br><span class="line">			<span class="keyword">switch</span>(j)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				pets.add(Pet.Pet);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				pets.add(Pet.Rat);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				pets.add(Pet.Manx);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				pets.add(Pet.Mutt);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">				pets.add(Pet.Pug);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">				pets.add(Pet.Cymric);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">				pets.add(Pet.Humaster);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pets;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;然后是一个List的操作类，相关操作的注释已经标注：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListFeature</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">		List&lt;Pet&gt; pets = Pets.arrayList(<span class="number">7</span>);</span><br><span class="line">		<span class="comment">//基本的List展示</span></span><br><span class="line">		System.out.println(<span class="string">"1:"</span> + pets);</span><br><span class="line">		pets.add(Pet.Humaster);</span><br><span class="line">		<span class="comment">//List可以自动扩容 向其中添加的元素会被追加到最后</span></span><br><span class="line">		System.out.println(<span class="string">"2:"</span> + pets);</span><br><span class="line">		<span class="comment">//a.contains(b)方法判断 集合a中是否包含b 返回的是boolean类型 </span></span><br><span class="line">		System.out.println(<span class="string">"3:"</span> + pets.contains(Pet.Humaster));</span><br><span class="line">		<span class="comment">//remove 移除指定的元素</span></span><br><span class="line">		pets.remove(Pet.Humaster);</span><br><span class="line">		Pet p = pets.get(<span class="number">2</span>);</span><br><span class="line">		<span class="comment">//get（2）获取指定位置上的元素 下标从0开始  indexOf(p) 返回指定元素的下标</span></span><br><span class="line">		System.out.println(<span class="string">"4:"</span> + p + <span class="string">" "</span> + pets.indexOf(p));</span><br><span class="line">		Pet cymric = Pet.Cymric;</span><br><span class="line">		<span class="comment">//indexOf(p) 返回指定元素的下标 如果没有则返回-1 存在多个则返回第一个</span></span><br><span class="line">		System.out.println(<span class="string">"5:"</span> + pets.indexOf(cymric));</span><br><span class="line">		<span class="comment">//remove（p） 移除指定元素 返回boolean类型 不存在为false 存在多个则移除第一个</span></span><br><span class="line">		System.out.println(<span class="string">"6:"</span> + pets.remove(cymric));</span><br><span class="line">		System.out.println(<span class="string">"7:"</span> + pets.remove(p));</span><br><span class="line">		System.out.println(<span class="string">"8:"</span> + pets);</span><br><span class="line">		<span class="comment">//在下标为3的位置插入元素，后边的元素顺序后移</span></span><br><span class="line">		pets.add(<span class="number">3</span>,Pet.Mutt);</span><br><span class="line">		System.out.println(<span class="string">"9:"</span> + pets);</span><br><span class="line">		<span class="comment">//截断 下标为1到4的元素 包括1但是不包括4</span></span><br><span class="line">		List&lt;Pet&gt; sub = pets.subList(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">		System.out.println(<span class="string">"subList:"</span> + sub);</span><br><span class="line">		<span class="comment">//a.containsAll(b) a集合是否包含b集合中的全部元素 返回boolean类型</span></span><br><span class="line">		System.out.println(<span class="string">"10:"</span> + pets.containsAll(sub));</span><br><span class="line">		<span class="comment">//排序</span></span><br><span class="line">		Collections.sort(sub);</span><br><span class="line">		System.out.println(<span class="string">"sorted subList:"</span> + sub);</span><br><span class="line">		System.out.println(<span class="string">"11:"</span> + pets.containsAll(sub));</span><br><span class="line">		<span class="comment">//随机排序</span></span><br><span class="line">		Collections.shuffle(sub,rand);</span><br><span class="line">		System.out.println(<span class="string">"suffle subList:"</span> + sub);</span><br><span class="line">		System.out.println(<span class="string">"12:"</span> + pets.containsAll(sub));</span><br><span class="line">		List&lt;Pet&gt; copy = <span class="keyword">new</span> ArrayList&lt;Pet&gt;(pets);</span><br><span class="line">		sub = Arrays.asList(pets.get(<span class="number">1</span>),pets.get(<span class="number">4</span>));</span><br><span class="line">		System.out.println(<span class="string">"sub:"</span> + sub);</span><br><span class="line">		<span class="comment">//a.retainAll(b) a中保留所有与b的交集部分</span></span><br><span class="line">		copy.retainAll(sub);</span><br><span class="line">		System.out.println(<span class="string">"13:"</span> + copy);</span><br><span class="line">		copy = <span class="keyword">new</span> ArrayList&lt;Pet&gt;(pets);</span><br><span class="line">		copy.remove(<span class="number">2</span>);</span><br><span class="line">		System.out.println(<span class="string">"14:"</span> + copy);</span><br><span class="line">		<span class="comment">//移除所有的元素</span></span><br><span class="line">		copy.removeAll(sub);</span><br><span class="line">		System.out.println(<span class="string">"15:"</span> + copy);</span><br><span class="line">		<span class="comment">//将下标为1的元素更换为指定元素</span></span><br><span class="line">		copy.set(<span class="number">1</span>,Pet.Pug);</span><br><span class="line">		System.out.println(<span class="string">"16:"</span> + copy);</span><br><span class="line">		copy.addAll(<span class="number">2</span>,sub);</span><br><span class="line">		System.out.println(<span class="string">"17:"</span> + copy);</span><br><span class="line">		<span class="comment">//判断是否为空 返回boolean类型</span></span><br><span class="line">		System.out.println(<span class="string">"18:"</span> + pets.isEmpty());</span><br><span class="line">		<span class="comment">//清空数据</span></span><br><span class="line">		pets.clear();</span><br><span class="line">		System.out.println(<span class="string">"19:"</span> + pets);</span><br><span class="line">		System.out.println(<span class="string">"20:"</span> + pets.isEmpty());</span><br><span class="line">		pets.addAll(Pets.arrayList(<span class="number">4</span>));</span><br><span class="line">		System.out.println(<span class="string">"21:"</span> + pets);</span><br><span class="line">		<span class="comment">//将List转换成数组</span></span><br><span class="line">		Object[] o = pets.toArray();</span><br><span class="line">		System.out.println(<span class="string">"22:"</span> + o[<span class="number">3</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/15/【Java编程思想】十二：持有对象/png3.png" alt="png3"></p>
<p>&ensp;&ensp;&ensp;&ensp;因为数据的插入是随机的，所以后边对应的操作也是随机结果。相关操作已经写在注释中，这里不再阐述。</p>
<h1 id="六、迭代器"><a href="#六、迭代器" class="headerlink" title="六、迭代器"></a>六、迭代器</h1><p>&ensp;&ensp;&ensp;&ensp;迭代器（也是一种设计模式），是一种应用在容器之上的设计。它是一个对象，它的作用是遍历并选择序列中的对象，而不需要确定该序列的底层机构。也就是说，我们使用迭代器的目的是解决了不同容器之间的互通性问题。因此迭代器通常被称作是“轻量级对象”，创建它的代价较小。因此通常有些奇怪的限制。例如：Java中的迭代器只能单向移动，并且它通常：<br>&ensp;&ensp;&ensp;&ensp;1、使用方法iterator（）要求容器返回一个Iterator，Iterator将准备好返回容器的第一个元素。<br>&ensp;&ensp;&ensp;&ensp;2、使用next（）方法获得容器中的下一个元素。<br>&ensp;&ensp;&ensp;&ensp;3、使用hasNext（）方法检查容器中是否还有下一个元素。<br>&ensp;&ensp;&ensp;&ensp;4、使用remove（）方法将迭代器中新近返回的元素删除。<br>&ensp;&ensp;&ensp;&ensp;我们继续使用上节的Pets类进行Iterator的测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleIterator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;Pet&gt; pets = Pets.arrayList(<span class="number">7</span>);</span><br><span class="line">		Iterator&lt;Pet&gt; it = pets.iterator();</span><br><span class="line">		System.out.println(<span class="string">"1:"</span> + pets);</span><br><span class="line">		System.out.println(<span class="string">"2:"</span> + it);</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			Pet p = it.next();</span><br><span class="line">			System.out.println(<span class="string">"---&gt;"</span> + p);</span><br><span class="line">		&#125;</span><br><span class="line">		it = pets.iterator();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">			it.next();</span><br><span class="line">			it.remove();</span><br><span class="line">			System.out.println(pets);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/15/【Java编程思想】十二：持有对象/png4.png" alt="png4"></p>
<p>&ensp;&ensp;&ensp;&ensp;需要注意的是，第二行我们打印Iterator时并没有像打印其它对象时把数据打印出来，而是只打印了这个迭代器底层容器的类型ArrayList。还有就是迭代器对象第一次.next之后获取的是第一个元素，remove方法移除的是next方法获取到的元素，所以remove之前必须要调用next方法。在同一方法中使用Iterator时，要注意前面使用过之后，Iterator的位置会发生变化。<br>&ensp;&ensp;&ensp;&ensp;现在我们换用其它类型的容器来测试迭代器的作用，这里有个display（）方法，它不考虑任何容器的类型来进行打印：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleIterator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Iterator&lt;Pet&gt; it)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"==="</span> +it.getClass().getName()+ <span class="string">"==="</span>);</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			Pet p = it.next();</span><br><span class="line">			System.out.println(p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;Pet&gt; pets = (ArrayList&lt;Pet&gt;) Pets.arrayList(<span class="number">7</span>);</span><br><span class="line">		LinkedList&lt;Pet&gt; lkp = <span class="keyword">new</span> LinkedList&lt;Pet&gt;(pets);</span><br><span class="line">		HashSet&lt;Pet&gt; hs = <span class="keyword">new</span> HashSet&lt;Pet&gt;(pets);</span><br><span class="line">		TreeSet&lt;Pet&gt; ts = <span class="keyword">new</span> TreeSet&lt;Pet&gt;(pets);</span><br><span class="line">		LinkedHashSet&lt;Pet&gt; lhs = <span class="keyword">new</span> LinkedHashSet&lt;Pet&gt;(pets);</span><br><span class="line">		display(pets.iterator());</span><br><span class="line">		display(lkp.iterator());</span><br><span class="line">		display(hs.iterator());</span><br><span class="line">		display(ts.iterator());</span><br><span class="line">		display(lhs.iterator());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/15/【Java编程思想】十二：持有对象/png5.png" alt="png5"></p>
<p>&ensp;&ensp;&ensp;&ensp;还有一种比Iterator更加强大的迭代器ListIterator，这个迭代器功能更全，可以向前或者向后移动，也可以使用set（）方法替换它最后访问的元素（使用方式如Iterator的remove方法，要先指定访问元素），同时它还可以使用listIterator（n）方法直接指定到第n个元素的ListIterator。下面的示例展示了ListIterator的功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleListIterator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;Pet&gt; pets = Pets.arrayList(<span class="number">7</span>);</span><br><span class="line">		ListIterator&lt;Pet&gt; lit = pets.listIterator();</span><br><span class="line">		System.out.println(pets);</span><br><span class="line">		System.out.println(lit);</span><br><span class="line">		System.out.println(<span class="string">"=====Next====="</span>);</span><br><span class="line">		<span class="keyword">while</span>(lit.hasNext())&#123;</span><br><span class="line">			<span class="keyword">int</span> index = lit.nextIndex();</span><br><span class="line">			Pet p = lit.next();</span><br><span class="line">			System.out.println(<span class="string">"Index:"</span> + index + <span class="string">","</span> + <span class="string">"Pet:"</span> + p );</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"=====Previous====="</span>);</span><br><span class="line">		lit = pets.listIterator(<span class="number">7</span>);</span><br><span class="line">		<span class="keyword">while</span>(lit.hasPrevious())&#123;</span><br><span class="line">			<span class="keyword">int</span> index = lit.previousIndex();</span><br><span class="line">			Pet p = lit.previous();</span><br><span class="line">			System.out.println(<span class="string">"Index:"</span> + index + <span class="string">","</span> + <span class="string">"Pet:"</span> + p );</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"=====Update Set====="</span>);</span><br><span class="line">		lit = pets.listIterator();</span><br><span class="line">		<span class="keyword">while</span>(lit.hasNext())&#123;</span><br><span class="line">			Pet p = lit.next();</span><br><span class="line">			lit.set(Pet.Humaster);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(pets);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/15/【Java编程思想】十二：持有对象/png6.png" alt="png6"></p>
<p>&ensp;&ensp;&ensp;&ensp;如上是ListIterator的一些特性，相比Iterator，功能更加全面了一些。需要注意的是，nextIndex和previous不会发生移位操作。</p>
<h1 id="七、LinkedList"><a href="#七、LinkedList" class="headerlink" title="七、LinkedList"></a>七、LinkedList</h1><p>&ensp;&ensp;&ensp;&ensp;LinkedList与ArrayList相同都是实现了List接口，但是它在增删的时候效率较高，在随机访问的时候效率略低。LinkedList还增加了其作为栈、队列、双端队列的操作方法。这些方法有的只是名字有差异，或者是返回值有差异。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListFeatures</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		LinkedList&lt;Pet&gt; pets = <span class="keyword">new</span> LinkedList&lt;Pet&gt;(Pets.arrayList(<span class="number">7</span>));</span><br><span class="line">		System.out.println(pets);</span><br><span class="line">		<span class="comment">//以下两个方法都返回容器的第一个元素 在容器为空的时候抛异常</span></span><br><span class="line">		System.out.println(<span class="string">"pets.getFirst()---》"</span> + pets.getFirst());</span><br><span class="line">		System.out.println(<span class="string">"pets.elements()---》"</span> + pets.element());</span><br><span class="line">		<span class="comment">//与上两个方法相同 区别在于为空时返回null</span></span><br><span class="line">		System.out.println(<span class="string">"pets.peek()---》"</span> + pets.peek());</span><br><span class="line">		<span class="comment">//以下两个方法移除列表的第一个元素 在容器为空的时候抛出异常</span></span><br><span class="line">		System.out.println(<span class="string">"pets.remove()---&gt;"</span> + pets.remove());</span><br><span class="line">		System.out.println(<span class="string">"pets.removeFirst()---&gt;"</span> + pets.removeFirst());</span><br><span class="line">		<span class="comment">//与上两个方法相同 区别在于容器为空时返回null</span></span><br><span class="line">		System.out.println(<span class="string">"pets.pool()---&gt;"</span> + pets.poll());</span><br><span class="line">		System.out.println(pets);</span><br><span class="line">		<span class="comment">//在容器第一个位置加入新的元素 其它元素依次后移</span></span><br><span class="line">		pets.addFirst(Pet.Manx);</span><br><span class="line">		System.out.println(<span class="string">"After addFirst()"</span> + pets);</span><br><span class="line">		<span class="comment">//以下两个方法在容器尾部插入新元素</span></span><br><span class="line">		pets.add(Pet.Humaster);</span><br><span class="line">		System.out.println(<span class="string">"After add()"</span> + pets);</span><br><span class="line">		pets.addLast(Pet.Pug);</span><br><span class="line">		System.out.println(<span class="string">"After addLast()"</span> + pets);</span><br><span class="line">		<span class="comment">//offer 是针对queue 在尾部插入数据 add是针对list 在尾部插入数据</span></span><br><span class="line">		pets.offer(Pet.Rat);</span><br><span class="line">		System.out.println(<span class="string">"After offer()"</span> + pets);</span><br><span class="line">		<span class="comment">//移除最后一个并返回该元素</span></span><br><span class="line">		System.out.println(<span class="string">"pets.removeLast()"</span> + pets.removeLast());</span><br><span class="line">		System.out.println(<span class="string">"After removeLast()"</span> + pets);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/15/【Java编程思想】十二：持有对象/png7.png" alt="png7"></p>
<h1 id="八、Stack"><a href="#八、Stack" class="headerlink" title="八、Stack"></a>八、Stack</h1><p>&ensp;&ensp;&ensp;&ensp;“栈”通常是指“后进先出的容器”，比如装羽毛球的桶，最后放进去的羽毛球可以第一个被拿出来，因为另一端也就是栈底是封闭的。LinkedList具有能够直接实现栈的所有功能的方法，因此可以直接将LinkedList作为栈使用。这里我们使用一个真正的Stack，内部使用LinkedList来实现它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> LinkedList&lt;T&gt; storage = <span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T v)</span></span>&#123;</span><br><span class="line">		storage.addFirst(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> storage.getFirst();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> storage.removeFirst();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> storage.isEmpty();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		 <span class="keyword">return</span> storage.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;这里使用<t>泛型来告诉编译器这个Stack是持有参数化类型T的容器，这个Stack是使用LinkedList实现的，而LinkedList也被告知是使用了T类型的对象。peek（）方法返回栈顶元素，但是并不是移除。而pop（）方法这里是弹出栈顶元素，也就是移除了栈顶元素。如果我们只是需要栈的行为，而不需要其它无关的行为方法，那么这里使用继承就显然不合适了。后边会讨论在Java1.0中，java.util.Stack这个类的设计。</t></p>
<p>&ensp;&ensp;&ensp;&ensp;下面演示了我们如何使用上边这个新的Stack类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">		<span class="keyword">for</span>(String s : <span class="string">"My Dog has fleas"</span>.split(<span class="string">" "</span>))&#123;</span><br><span class="line">			stack.push(s);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">			System.out.print(stack.pop() + <span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;这里使用了push方法将字符串“My Dog has fleas”用空格分开的单词压入栈中，然后使用pop方法弹出栈顶元素。因为pop方法调用之后会移除栈顶元素，所以会依次弹出栈中的所有元素。在这里我们使用了自己定义的Stack，如果我们导入了java.util.Stack类的话，那么我们这样使用可能会产生命名冲突的现象，解决方法是我们在实例化的时候使用完整的类名，或者修改我们自己定义的Stack类名。</p>
<h1 id="九、Set"><a href="#九、Set" class="headerlink" title="九、Set"></a>九、Set</h1><p>&ensp;&ensp;&ensp;&ensp;Set不保存重复的元素（至于如何判断元素是否重复，则较为复杂，稍后便会看到），Set最常见的使用是判断对象的归属性，即判断某个对象是否在Set中。正因为如此，Set的查询效率就显得尤为重要了，所以通常会使用HashSet来实现所需要的功能，它对查询专门做了优化。</p>
<p>&ensp;&ensp;&ensp;&ensp;Set具有与Collection完全一样的接口，我们可以说Set就是Collection，这是表现了不同的功能，这是Java中继承与多态思想的展现。Set中更加复杂的问题后边17章会介绍。</p>
<p>&ensp;&ensp;&ensp;&ensp;下面示例使用了HashSet存放Integer对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetofInteger</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Random random = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">		Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">			set.add(random.nextInt(<span class="number">30</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(set);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/15/【Java编程思想】十二：持有对象/png8.png" alt="png8"></p>
<p>&ensp;&ensp;&ensp;&ensp;set中插入了0-29的随机数，插入了10000次，但是从打印结果可以看出，只保证了每个数据只出现了一次。而且似乎插入的顺序并没有规律可寻。这是因为出于查找速度的考虑，HashSet使用了散列，将在17章中介绍。HashSet使用散列存储，TreeSet使用红黑树存储，LinkedHahSet因为查询速度的原因也使用了散列，但是它看起来像是使用了链表来进行存储，因为它保证了元素的插入顺序。</p>
<p>&ensp;&ensp;&ensp;&ensp;注意：插入顺序与元素的顺序的区别，插入顺序是我们在容器中添加元素时的顺序，而元素的顺序说的是按照某种规则比如从小到大或者从大到小的顺序，也就是元素的结果。当然，上边的示例如果我们相对元素的结果进行排序，那么可以使用TreeSet来替换，因为LinkedHashSet只是保证了元素的插入顺序。</p>
<p>&ensp;&ensp;&ensp;&ensp;Set 常用的方法是使用contains（）判断是否存在某元素，当然还有一些其它的顾名思义的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetOperations</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Set&lt;String&gt; set1 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		Collections.addAll(set1,<span class="string">"A B C D E F G H I J K L"</span>.split(<span class="string">" "</span>));</span><br><span class="line">		set1.add(<span class="string">"M"</span>);</span><br><span class="line">		System.out.println(<span class="string">"H:"</span> +  set1.contains(<span class="string">"H"</span>));</span><br><span class="line">		System.out.println(<span class="string">"N:"</span> +  set1.contains(<span class="string">"N"</span>));</span><br><span class="line">		Set&lt;String&gt; set2 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		Collections.addAll(set2,<span class="string">"H I J K L"</span>.split(<span class="string">" "</span>));</span><br><span class="line">		System.out.println(<span class="string">"set2 in set1:"</span> + set1.containsAll(set2));</span><br><span class="line">		set1.remove(<span class="string">"H"</span>);</span><br><span class="line">		System.out.println(<span class="string">"set1: "</span> + set1);</span><br><span class="line">		System.out.println(<span class="string">"set2 in set1:"</span> + set1.containsAll(set2));</span><br><span class="line">		set1.removeAll(set2);</span><br><span class="line">		System.out.println(<span class="string">"set2 removed from set1:"</span> + set1);</span><br><span class="line">		Collections.addAll(set1,<span class="string">"X Y Z"</span>.split(<span class="string">" "</span>));</span><br><span class="line">		System.out.println(<span class="string">"XYZ added to set1:"</span> + set1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/15/【Java编程思想】十二：持有对象/png9.png" alt="png9"></p>
<h1 id="十、Map"><a href="#十、Map" class="headerlink" title="十、Map"></a>十、Map</h1><p>&ensp;&ensp;&ensp;&ensp;Map可以将一个对象映射到另一个对象上组建一种一对一的键值关系。比如可以设计这样一个程序来验证Java中Random的随机性，理想情况下，Random对每个随机数产生的概率是相同的。我们测试这一理论，于是定义一个Map，键来表示随机出现的数字，值来表示该数字出现的次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomTest</span> </span>&#123;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Random random = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">		Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">1000000</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> x = random.nextInt(<span class="number">20</span>);</span><br><span class="line">			Integer freq = map.get(x);</span><br><span class="line">			map.put(x,freq == <span class="keyword">null</span>?<span class="number">1</span>:freq+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(map);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/15/【Java编程思想】十二：持有对象/png10.png" alt="png10"></p>
<p><img src="/2018/11/15/【Java编程思想】十二：持有对象/png11.png" alt="png11"></p>
<p>&ensp;&ensp;&ensp;&ensp;20个数字随机1000000次，每个数字出现的概率为1/50000，由运行结果可以看出，基本符合这一理想情况下的推论。上述main（）方法中所用的map.get（）方法，获取指定键对应的值，如果该键不存在则返回null。Map同样具有判断键值是否存在的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PetMap</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Map&lt;String,Pet&gt; petMap = <span class="keyword">new</span> HashMap&lt;String,Pet&gt;();</span><br><span class="line">		petMap.put(<span class="string">"MyCat"</span>,Pet.Cymric);</span><br><span class="line">		petMap.put(<span class="string">"MyDog"</span>,Pet.Humaster);</span><br><span class="line">		petMap.put(<span class="string">"MyPig"</span>,Pet.Mutt);</span><br><span class="line">		System.out.println(petMap);</span><br><span class="line">		Pet p = petMap.get(<span class="string">"MyDog"</span>);</span><br><span class="line">		System.out.println(p);</span><br><span class="line">		System.out.println(petMap.containsKey(<span class="string">"MyDog"</span>));</span><br><span class="line">		System.out.println(petMap.containsValue(Pet.Cymric));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/15/【Java编程思想】十二：持有对象/png12.png" alt="png12"></p>
<p>&ensp;&ensp;&ensp;&ensp;Map与数组或者其它的Collection一样，可以扩展到多维角度，即key是String类型，value可以重新定义为一个容器。比如上边的示例改造为一个动物有多个名字。那么你需要的就是一个Map&lt;String,List<pet>&gt;:</pet></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.chenxyt.java.practice;</span><br><span class="line"> </span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">public class MapOfList &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		 Map&lt;String,List&lt;Pet&gt;&gt; petList = new HashMap&lt;String,List&lt;Pet&gt;&gt;();</span><br><span class="line">		 petList.put(&quot;MyDog&quot;,Arrays.asList(Pet.Cymric,Pet.Humaster,Pet.Mutt));</span><br><span class="line">		 System.out.println(petList);</span><br><span class="line">		 System.out.println(&quot;key:&quot; + petList.keySet());</span><br><span class="line">		 System.out.println(&quot;value:&quot; + petList.values());</span><br><span class="line">		 for(String s:petList.keySet())&#123;</span><br><span class="line">			 System.out.print(s + &quot;:&quot;);</span><br><span class="line">			 for(Pet p:petList.get(s))&#123;</span><br><span class="line">				 System.out.print(p + &quot; &quot;);</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/15/【Java编程思想】十二：持有对象/png13.png" alt="png13"></p>
<p>&ensp;&ensp;&ensp;&ensp;上述代码中还展示了.keySet（）方法和.values（）方法，分别返回Map中所有的键和所有的值。</p>
<h1 id="十一、Queue"><a href="#十一、Queue" class="headerlink" title="十一、Queue"></a>十一、Queue</h1><p>&ensp;&ensp;&ensp;&ensp;队列是一个典型的先进先出的容器，就像是一个两端打开的管子，从一端放进去的物品，从另一端取出，并且最先取出的是最先放进去的物品。因此队列的取出顺序往往是与插入顺序相同的。正因为队列这种顺序特性，它常常被作为一种可靠的将对象从程序的某个区域发送到另一个区域的途径。LinkedList实现了Queue的接口，因此LinkedList可以当做是Queue的一种实现，这是面向对象编程中继承与多态思想的体现。将LinkedList向上转型为Queue，下面的示例将展示Queue接口中与Queue相关的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printQ</span><span class="params">(Queue queue)</span></span>&#123;</span><br><span class="line">		<span class="comment">//不移除的情况下返回队列头部元素  element（）方法相同  peek为空返回null  element为空抛出异常</span></span><br><span class="line">		<span class="keyword">while</span>(queue.peek()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="comment">//remove（）移除头元素 为空抛出异常 poll 为空返回null</span></span><br><span class="line">			System.out.println(queue.remove() + <span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">			<span class="comment">//元素插入队尾</span></span><br><span class="line">			queue.offer(i);</span><br><span class="line">		&#125;</span><br><span class="line">		printQ(queue);</span><br><span class="line">		Queue&lt;Character&gt; qc = <span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">char</span> c:<span class="string">"QUEUEDEMO"</span>.toCharArray())&#123;</span><br><span class="line">			qc.offer(c);</span><br><span class="line">		&#125;</span><br><span class="line">		printQ(qc);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/15/【Java编程思想】十二：持有对象/png14.png" alt="png14"></p>
<p>&ensp;&ensp;&ensp;&ensp;offer方法是队列的相关方法之一，它在队列允许的情况下，将元素插入到队列的尾部，或者返回false，peek和element方法都是在不删除的情况下返回队列的第一个元素，peek在队列为空时返回null，element在队列为空抛NoSuchElementException，poll和remove删除当前队列的第一个元素，如果为空poll返回null，remove抛NoSuchElementException异常。</p>
<p>&ensp;&ensp;&ensp;&ensp;先进先出描述了最典型的队列规则，在某些情况下，队列还需要弹出当前最需要的元素，这种队列称作是优先级队列。优先级队列每个元素都具有一个执行的优先级，也就是这个元素何时弹出与何时插入没有必然的联系。PriorityQueue添加到Java SE5中，是为了这种优先级形式自动实现。当我们在PriorityQueue上调用了offer（）方法来插入一个对象时，这个对象在队列中就会被重新排序。默认的排序是对象在队列中的自然顺序。但是你可以通过提供自己的Comparator来修改这个顺序。PriorityQueue可以确保你在调用peek、poll、remove等方法时获取的是当前队列中优先级最高的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printQ</span><span class="params">(Queue queue)</span></span>&#123;</span><br><span class="line">		<span class="comment">//不移除的情况下返回队列头部元素  element（）方法相同  peek为空返回null  element为空抛出异常</span></span><br><span class="line">		<span class="keyword">while</span>(queue.peek()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="comment">//remove（）移除头元素 为空抛出异常 poll 为空返回null</span></span><br><span class="line">			System.out.println(queue.remove() + <span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;Integer&gt; ints = Arrays.asList(<span class="number">25</span>,<span class="number">22</span>,<span class="number">20</span>,<span class="number">18</span>,<span class="number">14</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">14</span>,<span class="number">18</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">25</span>);</span><br><span class="line">		PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(ints.size(),Collections.reverseOrder());</span><br><span class="line">		queue.addAll(ints);</span><br><span class="line">		printQ(queue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/15/【Java编程思想】十二：持有对象/png15.png" alt="png15"></p>
<p>&ensp;&ensp;&ensp;&ensp;我们使用了JavaSE5中定义的reverseOrder反序定义了PriorityQueue的优先级。</p>
<h1 id="十二、Collection和Iterator"><a href="#十二、Collection和Iterator" class="headerlink" title="十二、Collection和Iterator"></a>十二、Collection和Iterator</h1><p> &ensp;&ensp;&ensp;&ensp;Collection是描述所有序列容器共性的根接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceVsIterator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Iterator&lt;Pet&gt; it)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"IT-P:"</span>);</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			Pet p = it.next();</span><br><span class="line">			System.out.print(p + <span class="string">","</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Collection&lt;Pet&gt; collection)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"CL-P:"</span>);</span><br><span class="line">		<span class="keyword">for</span>(Pet p:collection)&#123;</span><br><span class="line">			System.out.print(p + <span class="string">","</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;Pet&gt; petList = Pets.arrayList(<span class="number">7</span>);</span><br><span class="line">		Set&lt;Pet&gt; petSet = <span class="keyword">new</span> HashSet&lt;Pet&gt;(petList);</span><br><span class="line">		Map&lt;String,Pet&gt; petMap = <span class="keyword">new</span> LinkedHashMap&lt;String,Pet&gt;();</span><br><span class="line">		String[] names = (<span class="string">"A,B,C,D,E"</span>).split(<span class="string">","</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;names.length;i++)&#123;</span><br><span class="line">			petMap.put(names[i],petList.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">		display(petList);</span><br><span class="line">		display(petSet);</span><br><span class="line">		display(petList.iterator());</span><br><span class="line">		display(petSet.iterator());</span><br><span class="line">		System.out.println(petMap);</span><br><span class="line">		System.out.println(petMap.keySet());</span><br><span class="line">		display(petMap.values());</span><br><span class="line">		display(petMap.values().iterator());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/15/【Java编程思想】十二：持有对象/png16.png" alt="png16"></p>
<p>&ensp;&ensp;&ensp;&ensp;从运行结果可以看出，使用Collection和Iterator看起来没有什么区别，通常情况下，使用Collection要更方便一些。</p>
<h1 id="十三、Foreach与迭代器"><a href="#十三、Foreach与迭代器" class="headerlink" title="十三、Foreach与迭代器"></a>十三、Foreach与迭代器</h1><p>&ensp;&ensp;&ensp;&ensp;foreach语法可以应用在数组中，也可以应用在任何Collection对象，之所以能够这样，是因为JavaSE5引入了新的被称为Iterable的接口，该接口包含了一个能够产生Iterator的iterator（）方法，并且Iterable接口被foreach用来在序列中移动。因此如果你创建了任何实现Iterabel的类，都可以将它应用在foreach中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IterableClass</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> String[] words = (<span class="string">"And that is how we know the earth"</span>).split(<span class="string">" "</span>);</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator&lt;String&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;String&gt;()&#123;</span><br><span class="line">			<span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="keyword">return</span> index&lt;words.length;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="keyword">return</span> words[index++];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="comment">//---</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(String s :<span class="keyword">new</span> IterableClass())&#123;</span><br><span class="line">			System.out.print(s + <span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/15/【Java编程思想】十二：持有对象/png17.png" alt="png17"></p>
<p>&ensp;&ensp;&ensp;&ensp;iterator（）方法返回的实现了Iterator<string> 的匿名内部类的实例，该匿名内部类可以遍历数组中的所有单词。在main（）中，你可以看到IteratorClass确实可以用于foreach语句中。</string></p>
<h1 id="十四、总结"><a href="#十四、总结" class="headerlink" title="十四、总结"></a>十四、总结</h1><p>&ensp;&ensp;&ensp;&ensp;容器也就是集合，是Java基础中很重要的一个模块，本篇文章了解了基础的容器使用方式。Java提供了多种容器持有对象的方式：<br>&ensp;&ensp;&ensp;&ensp;1.数组将数字也就是下标与内容关联，查询时不需要进行类型转换，缺点是大小一旦确定，则不能被改变。<br>&ensp;&ensp;&ensp;&ensp;2.Collection保存单一的元素，Map保存相关联的键值对。<br>&ensp;&ensp;&ensp;&ensp;3.像数组一样，List也建立数字索引与对象的关联，因此数组和List都是排序好的容器。<br>&ensp;&ensp;&ensp;&ensp;4.如果要进行大量的随机访问，就要使用ArrayList，如果要进行大量的插入删除操作，就要使用LinkedList。<br>&ensp;&ensp;&ensp;&ensp;5.各种队列与栈的操作，由LinkedList提供支持。<br>&ensp;&ensp;&ensp;&ensp;6.Map是一种将对象与对象进行关联的容器，HashMap设计用来快速访问，TreeMap保持键始终处于排序状态，所以没有HashMap快。LinkedHashMap保持元素插入的顺序，但是也通过散列提供快速访问的能力。<br>&ensp;&ensp;&ensp;&ensp;7.Set不接受重复的数据，HashSet提供最快的查询速度，而TreeSet保持元素处于排序状态。LinkedHashSet以插入顺序保持元素。</p>
<p>&ensp;&ensp;&ensp;&ensp;简单的容器分类：</p>
<p><img src="/2018/11/15/【Java编程思想】十二：持有对象/png18.png" alt="png18"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/15/【Java编程思想】十一：内部类/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crayon Cxy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ordinary Road">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/15/【Java编程思想】十一：内部类/" itemprop="url">【Java编程思想】十一：内部类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-15T10:23:00+08:00">
                2018-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/15/【Java编程思想】十一：内部类/" class="leancloud_visitors" data-flag-title="【Java编程思想】十一：内部类">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、创建内部类"><a href="#一、创建内部类" class="headerlink" title="一、创建内部类"></a>一、创建内部类</h1><p>&ensp;&ensp;&ensp;&ensp;将一个类定义在另一个类的内部，这就是内部类。内部类与组合是不同的概念。</p>
<p>&ensp;&ensp;&ensp;&ensp;创建一个内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcell</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> String label;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Destination</span><span class="params">(String whereto)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">			label = whereto;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">String <span class="title">readLabel</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> label;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Contents();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Destination(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ship</span><span class="params">(String dest)</span></span>&#123;</span><br><span class="line">		Contents c = <span class="keyword">new</span> Contents();</span><br><span class="line">		Destination d = <span class="keyword">new</span> Destination(dest);</span><br><span class="line">		System.out.println(d.readLabel());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Parcell p1 = <span class="keyword">new</span> Parcell();</span><br><span class="line">		p1.ship(<span class="string">"Inner Class"</span>);</span><br><span class="line">		Parcell p2 = <span class="keyword">new</span> Parcell();</span><br><span class="line">		Contents c = p2.contents();</span><br><span class="line">		Parcell.Destination d = p2.destination(<span class="string">"Class Inner"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;如上我们创建了一个内部类，内部类与其它类的区别在于将类隐藏在了另一个类的内部，同时如contents方法所示，外部类的方法还可以返回一个指向内部类的引用，这也是很常见的一种用法。此外我们看到main（）方法中创建的内部类对象是使用外部类的引用关联创建的，这一点在下一节中会说到。</p>
<p><img src="/2018/11/15/【Java编程思想】十一：内部类/png1.png" alt="png1"></p>
<h1 id="二、链接到外部类"><a href="#二、链接到外部类" class="headerlink" title="二、链接到外部类"></a>二、链接到外部类</h1><p>&ensp;&ensp;&ensp;&ensp;上边的代码似乎只展示了内部类与其它类名字和组织结构的区别，内部类还有其它的用途。当我们创建了一个内部类对象，此对象就与制造它的外围对象之间有了一种关联，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外围类的所有元素的访问权。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Selector</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">Object <span class="title">current</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object[] items;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">		items = <span class="keyword">new</span> Object[size];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(next&lt;items.length)&#123;</span><br><span class="line">			items[next++] = x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceSelector</span> <span class="keyword">implements</span> <span class="title">Selector</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="keyword">return</span> i == items.length;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="keyword">return</span> items[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="keyword">if</span>(i&lt;items.length)&#123;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Selector <span class="title">selector</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SequenceSelector();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//初始化一个长度为10的数组</span></span><br><span class="line">		Sequence sequence = <span class="keyword">new</span> Sequence(<span class="number">10</span>);</span><br><span class="line">		<span class="comment">//数组赋值 每个域赋值为下标编号</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">			sequence.add(Integer.toString(i));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//创建接口对象 返回接口实现的为内部类的对象</span></span><br><span class="line">		Selector selector = sequence.selector();</span><br><span class="line">		<span class="comment">//判断当前数组下标是否已到最大</span></span><br><span class="line">		<span class="keyword">while</span>(!selector.end())&#123;</span><br><span class="line">			<span class="comment">//返回当前数组域的值</span></span><br><span class="line">			System.out.print(selector.current() + <span class="string">" "</span>);</span><br><span class="line">			<span class="comment">//数组下标+1</span></span><br><span class="line">			selector.next();</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;上边的代码很好的展示了这一点，外部类Sequence创建了个数组，内部类SequenceSelector实现了Selector接口获取数组内容并操作数组，可以看到这个类的实现方法访问了外部类的private域。 </p>
<p><img src="/2018/11/15/【Java编程思想】十一：内部类/png2.png" alt="png2"></p>
<p>&ensp;&ensp;&ensp;&ensp;所以内部类自动拥有对其外围类所有成员的访问权限，那么这是如何做到的呢？当某个外围类的对象创建一个内部类的对象的时候，这个内部类对象必然会秘密捕获一个外围类对象的引用，也就是这个引用来选择外围类的成员。这里所有的细节都交给了编译器来处理。内部类的对象只能在其与外部类的对象相关联的时候才能被创建（在static方法中），构建内部类对象时，需要一个指向其外围类对象的引用，如果编译器访问不到这个引用就会报错，不过绝大多数情况下这种都不需要我们操心。这里也就解释了上一节关于内部类初始化方式不同的原因。意思就是在static方法中，不能通过直接的new 构造函数的形式创建内部类，因为这种形式没有将内部类与外部类对象做关联，要先创建一个外部类的对象，然后使用该对象的引用创建内部类对象。当然如果内部类是静态的，那么就没有这种要求了。</p>
<p><img src="/2018/11/15/【Java编程思想】十一：内部类/png3.png" alt="png3"></p>
<p><img src="/2018/11/15/【Java编程思想】十一：内部类/png4.png" alt="png4"></p>
<p>&ensp;&ensp;&ensp;&ensp;我们将上一个示例中的ship方法改成static修饰，原来的使用构造器创建内部类对象的方法就报错了。因为它没有找到关联的外部类对象引用。然后我们把这个内部类Contents改成static修饰，则编译器就不报错了。或者使用main函数中的形式，先创建一个外部类的对象，然后使用这个对象的引用去创建内部类对象。</p>
<h1 id="三、使用-this和-new"><a href="#三、使用-this和-new" class="headerlink" title="三、使用.this和.new"></a>三、使用.this和.new</h1><p>&ensp;&ensp;&ensp;&ensp;如果我们需要在内部类生成外部类对象的引用，那么可以使用外部类名.this的形式，这里如果只使用this，则返回的是内部类对象的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoThis</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"This is outClass's method"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> DoThis <span class="title">outer</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> DoThis.<span class="keyword">this</span>;</span><br><span class="line">			<span class="comment">//return this;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Inner <span class="title">inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		DoThis dt = <span class="keyword">new</span> DoThis();</span><br><span class="line">		Inner in = dt.inner();</span><br><span class="line">		in.outer().f();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/15/【Java编程思想】十一：内部类/png5.png" alt="png5"></p>
<p>&ensp;&ensp;&ensp;&ensp;如上在outer（）方法中使用return this 会提示Dothis类型无法转换成Inner类型。<br>&ensp;&ensp;&ensp;&ensp;如前文说到，我们不能使用new直接创建内部类对象，我们需要使用外部类对象的引用创建，这里可以使用外部类对象的引用.new语法进行创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoThis</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> DoThis <span class="title">outer</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> DoThis.<span class="keyword">this</span>;</span><br><span class="line">			<span class="comment">//return this;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		DoThis dt = <span class="keyword">new</span> DoThis();</span><br><span class="line">		Inner in = dt.new Inner();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;只有内部类是静态内部类或者在非static方法中，我们才可以通过new的形式直接进行创建。</p>
<h1 id="四、内部类与向上转型"><a href="#四、内部类与向上转型" class="headerlink" title="四、内部类与向上转型"></a>四、内部类与向上转型</h1><p>&ensp;&ensp;&ensp;&ensp;当将内部类向上转型为基类时，尤其是转型为接口时，内部类就有了用武之地。这是因为我们可以使内部类也就是接口的实现完全不可见也不可用，得到的只是基类或者接口的引用，从而更好的隐藏了实现的细节。</p>
<p>&ensp;&ensp;&ensp;&ensp;我们先创建两个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">readLabel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;然后创建一个类，并在这个类的内部创建两个内部类去实现上边的接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parcell4</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PContents</span> <span class="keyword">implements</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> String label;</span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereto)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">			label = whereto;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="keyword">return</span> label;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> PContents();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestParcell</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Parcell4 p = <span class="keyword">new</span> Parcell4();</span><br><span class="line">		Contents c = p.contents();</span><br><span class="line">		Destination d = p.destination(<span class="string">"Inner Class"</span>);</span><br><span class="line">		System.out.println(d.readLabel());</span><br><span class="line">		System.out.println(c.value());</span><br><span class="line">		<span class="comment">//因为PContents是private 所以不能被访问</span></span><br><span class="line">		<span class="comment">//Parcell4.PContents pc = p.new PContents();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;Parcell4中增加了一些新的东西，首先内部类PContents是private，除了Parcell4没有人能访问它，所以main函数最后一行编译不能通过。其次PDestination是protected的，所以除了该类本身和其子类还有同一个包中的类，其它类不能访问。因此客户端如果想访问这些实现，就受到了限制。不过我们可以看到，main函数的第二、第三行都实现了转型，也就是虽然不可见，但是不影响使用接口的实现。因此private的内部类提供了一种设计思路，通过这种方式完全阻止了依赖任何类型的编码，并且完全隐藏了实现的细节，并且由于不能访问任何新增加的、原本不属于公共接口的方法，因此接口的扩展就是没有价值的了。</p>
<p><img src="/2018/11/15/【Java编程思想】十一：内部类/png6.png" alt="png6"></p>
<h1 id="五、在方法和作用域内的内部类"><a href="#五、在方法和作用域内的内部类" class="headerlink" title="五、在方法和作用域内的内部类"></a>五、在方法和作用域内的内部类</h1><p>&ensp;&ensp;&ensp;&ensp;有些时候我们可以将内部类创建在方法的作用域里或者是其它任何地方的作用域中，这么做有两个理由：</p>
<p>&ensp;&ensp;&ensp;&ensp;1.如前所示，实现了某个类型的接口，可以创建并返回接口的引用。</p>
<p>&ensp;&ensp;&ensp;&ensp;2.要解决一个复杂的问题，需要一个类来辅助解决，但是又不希望这个类是公开的。</p>
<p>&ensp;&ensp;&ensp;&ensp;在方法的作用域内部创建的内部类称为局部内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel5</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String label;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereTo)</span></span>&#123;</span><br><span class="line">    label=whereTo;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="keyword">return</span> label;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Parcel5 p5 = <span class="keyword">new</span> Parcel5();</span><br><span class="line">  Destination d = p5.destination(<span class="string">"Area Inner Class"</span>);</span><br><span class="line">  System.out.println(d.readLabel());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;如上所示，destination方法中的内部类实现了Destination接口，PDestination类是destination方法内部的类，所以其它地方不能访问。return语句向上转型返回了Destination，它是PDestination类的接口，也就是基类。</p>
<p><img src="/2018/11/15/【Java编程思想】十一：内部类/png7.png" alt="png7"></p>
<p>&ensp;&ensp;&ensp;&ensp;下面的例子展示在任意作用域中使用内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel6</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalTracking</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(b)&#123;</span><br><span class="line">			<span class="class"><span class="keyword">class</span> <span class="title">TrackingSkip</span></span>&#123;</span><br><span class="line">				<span class="keyword">private</span> String id;</span><br><span class="line">				TrackingSkip(String s)&#123;</span><br><span class="line">					id = s;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="function">String <span class="title">getSkip</span><span class="params">()</span></span>&#123;</span><br><span class="line">					<span class="keyword">return</span> id;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			TrackingSkip ts = <span class="keyword">new</span> TrackingSkip(<span class="string">"SLIP"</span>);</span><br><span class="line">			String s = ts.getSkip();</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//因为内部类在if（b）的作用域内 此处已经超过了作用范围 所以不可以使用</span></span><br><span class="line">		<span class="comment">//TrackingSkip ts1 = new TrackingSkip("SLIP1");</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">()</span></span>&#123;</span><br><span class="line">		internalTracking(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Parcel6 p = <span class="keyword">new</span> Parcel6();</span><br><span class="line">		p.track();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;上边的例子主要是想在方法中判断如果入参为true则实现一个类的功能，而这个类又不想被外部可见，所以在if中创建了内部类。</p>
<p><img src="/2018/11/15/【Java编程思想】十一：内部类/png8.png" alt="png8"></p>
<h1 id="六、匿名内部类"><a href="#六、匿名内部类" class="headerlink" title="六、匿名内部类"></a>六、匿名内部类</h1><p>&ensp;&ensp;&ensp;&ensp;现在有如下个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Contents()&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Parcel7 p7 = <span class="keyword">new</span> Parcel7();</span><br><span class="line">  Contents c = p7.contents();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;在此处，contents方法内部要返回一个Contents对象的时候，我们突然加了一个类的定义，这个类没有名字，它实现了Contents接口，也就是我们实际上创建了一个继承自Contents类的匿名类对象，于是这个return对象的引用就变成了一个来自向上转型的Contents引用。上述这个匿名内部类是下面这种形式的一种简化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContents</span> <span class="keyword">implements</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyContents();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Parcel7 p7 = <span class="keyword">new</span> Parcel7();</span><br><span class="line">		Contents c = p7.contents();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;上述代码使用了默认的无参构造器，下边的示例展示当基类的构造器为有参数的构造器时，匿名内部类应当如何创建：</p>
<p>&ensp;&ensp;&ensp;&ensp;基类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapping</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Wrapping</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		i=x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;匿名内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel8</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Wrapping <span class="title">wrapping</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Wrapping(x)&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">super</span>.value() * <span class="number">11</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;只需要传递合适的参数到基类的构造器中即可，虽然Wrapping只是一个普通的实现类，但是他还是被其导出类当做了公共接口来使用。</p>
<p>&ensp;&ensp;&ensp;&ensp;如第一个例子所示，匿名内部类中的域可以进行初始化操作。但是，当匿名内部类的域要使用外部对象的引用时，需要强行将函数参数的引用设置为final才可以。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel8</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Wrapping <span class="title">wrapping</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Wrapping(x)&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">super</span>.value() * x;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="七、嵌套类"><a href="#七、嵌套类" class="headerlink" title="七、嵌套类"></a>七、嵌套类</h1><p>&ensp;&ensp;&ensp;&ensp;前边我们说的内部类，都是必须要有外部类关联的，也就是这些内部类有个隐式的引用，指向外部类。如果我们不需要这种关联，那么就可以将内部类显示的声明为static的，这种内部类称为嵌套类。嵌套类意味着：</p>
<p>&ensp;&ensp;&ensp;&ensp;1.要创建嵌套类的对象，并不依赖外部对象</p>
<p>&ensp;&ensp;&ensp;&ensp;2.不能从嵌套类的对象中访问非静态的外围类对象</p>
<p>&ensp;&ensp;&ensp;&ensp;嵌套类与普通的内部类还有一个区别，普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类，而嵌套类可以包含所有这些东西。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel11</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParcelContents</span> <span class="keyword">implements</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParcelDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> String label;</span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="title">ParcelDestination</span><span class="params">(String whereTo)</span></span>&#123;</span><br><span class="line">			label = whereTo;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="keyword">return</span> label;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">8</span>;</span><br><span class="line">		<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherLevel</span></span>&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">funx</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="comment">//</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">static</span> <span class="keyword">int</span> y = <span class="number">11</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Destination <span class="title">destination</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ParcelDestination(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ParcelContents();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Contents c = <span class="keyword">new</span> ParcelContents();</span><br><span class="line">		Destination d = <span class="keyword">new</span> ParcelDestination(<span class="string">"dss"</span>);</span><br><span class="line">		Destination d1 = destination(<span class="string">"d1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;如上，在main方法中，没有任何Parcel11对象是必须的，我们可以自由的创建内部类对象。<br>&ensp;&ensp;&ensp;&ensp;在正常情况下，不能在接口内部放置任何代码，但是嵌套类可以作为接口的一部分，放在接口中的任何域都是public static的，所以放入的类是嵌套类，甚至我们可以使用此类实现外部接口。如果你想要创建某些公共的代码，并让它可以被某个接口的所有不同实现所共有，那么这种情况就最好不过了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassInnerInterface</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">howd</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">ClassInnerInterface</span></span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">howd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			System.out.println(<span class="string">"其它不同实现的公共方法"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">new</span> Test().howd();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;如上我们在内部类中加入了一个main函数，这个main可以用来测试每一个我们编写的类，编译过程中会生成一个独立的class文件，名称如下。如果在生产项目上，我们可以简单的在编译好的文件中删除该class文件即可。</p>
<p><img src="/2018/11/15/【Java编程思想】十一：内部类/png9.png" alt="png9"></p>
<p>&ensp;&ensp;&ensp;&ensp;一个内部类被嵌套多少层并不重要，重要的是它能够透明的访问它所嵌入的外围类的所有成员，即便是被定义为private的域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManyInner</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//---</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="comment">//---</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">			<span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">				f();</span><br><span class="line">				g();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MNA</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ManyInner mi = <span class="keyword">new</span> ManyInner();</span><br><span class="line">		ManyInner.A a = mi.new A();</span><br><span class="line">		ManyInner.A.B b = a.new B();</span><br><span class="line">		b.h();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;如上可见，在嵌套了多层的内部类B中调用方法f（）和方法g（）并不需要任何其它附加条件，即便他们被定义为private</p>
<h1 id="八、为什么需要内部类"><a href="#八、为什么需要内部类" class="headerlink" title="八、为什么需要内部类"></a>八、为什么需要内部类</h1><p>&ensp;&ensp;&ensp;&ensp;一般来说，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象，所以可以认为内部类提供了一种进入它外围类的窗口。如果我们只是需要一个对接口的引用，那么为何不使用外围类去实现那个接口呢？答案是如果这样能满足需求，那就需要这样做。内部类实现接口与外部类实现接口的区别在于后者不是总能享用到接口带来的方便，有时需要用到接口的实现。所以使用内部类最吸引人的原因：</p>
<p><strong>&ensp;&ensp;&ensp;&ensp;每个内部类都能够独立的继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的实现），对于内部类都没有影响。</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;内部类有效的实现了“多重继承”，如果在一个类中要使用两个接口，那么使用单一类和内部类看起来没有什么区别（因为单一类可以直接实现多个接口，此处不写例子了），而如果这两个接口换成是抽象类或者是具体的类，那么由于Java不支持多重继承的原因，这里使用单一类显然不能解决问题了，而内部类恰好可以有效的解决这个问题，看似是个“多重继承”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="comment">//要继承的类1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span></span>&#123;</span><br><span class="line">	<span class="comment">//---</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//要继承的类2</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">G</span></span>&#123;</span><br><span class="line">	<span class="comment">//---</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外部类继承A 内部匿名类继承B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">F</span></span>&#123;</span><br><span class="line">	<span class="function">G <span class="title">makeG</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> G()&#123;</span><br><span class="line">			<span class="comment">//--</span></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutiExtends</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takeF</span><span class="params">(F f)</span></span>&#123;</span><br><span class="line">		<span class="comment">//--</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takeG</span><span class="params">(G g)</span></span>&#123;</span><br><span class="line">		<span class="comment">//--</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		H h = <span class="keyword">new</span> H();</span><br><span class="line">		takeF(h);</span><br><span class="line">		takeG(h.makeG());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;如果不是要解决类似上边的“多重继承”问题，那么可以不实用内部类，但是使用内部类还可以获得一些其它的特性。</p>
<p>&ensp;&ensp;&ensp;&ensp;1.内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外部类的对象信息相互独立。<br>&ensp;&ensp;&ensp;&ensp;2.在单个外围类中，可以让多个内部类继承或实现多个基类。<br>&ensp;&ensp;&ensp;&ensp;3.创建内部类的时刻并不依赖于外围对象的创建。（个人不太理解这里，因为前边说了非嵌套类在static方法中使用时，需要关联一个外部对象的引用，不知道这里具体指的是什么。）<br>&ensp;&ensp;&ensp;&ensp;4.内部类并没有令人迷惑的is-a关系，它是一个独立的实体。</p>
<h1 id="九、内部类的继承"><a href="#九、内部类的继承" class="headerlink" title="九、内部类的继承"></a>九、内部类的继承</h1><p>&ensp;&ensp;&ensp;&ensp;内部类由于与外部类之间有一个隐式的引用关联关系，所以在继承内部类的时候，要显示的说明他们之前的关联。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">withInner</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">withInner</span>.<span class="title">Inner</span></span>&#123;</span><br><span class="line">	InheritInner(withInner wi)&#123;</span><br><span class="line">		wi.<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		withInner wi = <span class="keyword">new</span> withInner();</span><br><span class="line">		InheritInner ii = <span class="keyword">new</span> InheritInner(wi);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;如上，在子类的构造函数中要传入继承内部类的外部类的引用。</p>
<h1 id="十、内部类可以被覆盖吗"><a href="#十、内部类可以被覆盖吗" class="headerlink" title="十、内部类可以被覆盖吗"></a>十、内部类可以被覆盖吗</h1><p>&ensp;&ensp;&ensp;&ensp;如果一个类继承了另一个外部类，那么基类中的内部类会发生覆盖吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Yolk y;</span><br><span class="line">	<span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"Egg.Yolk"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Egg</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"New Egg"</span>);</span><br><span class="line">		y = <span class="keyword">new</span> Yolk();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg</span> <span class="keyword">extends</span> <span class="title">Egg</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"BigEgg.Yolk"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> BigEgg();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;基类中使用了默认的构造函数，并创建了一个内部类对象，子类中“覆盖”了内部类，所以预期的结果应该是使用子类中覆盖之后的内部类构造器。</p>
<p><img src="/2018/11/15/【Java编程思想】十一：内部类/png10.png" alt="png10"></p>
<p>&ensp;&ensp;&ensp;&ensp;但是实际结果显然不是这样的，它还是走了正常的逻辑流程，说明子类并没有覆盖基类中内部类，这两个内部类彼此独立，在自己的命名空间中。当我们想进行类似“覆盖”内部类的功能时，可以明确的继承内部类，然后覆盖其方法。</p>
<h1 id="十一、局部内部类"><a href="#十一、局部内部类" class="headerlink" title="十一、局部内部类"></a>十一、局部内部类</h1><p>&ensp;&ensp;&ensp;&ensp;定义在方法体中内部类称为局部内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClass</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//局部内部类</span></span><br><span class="line">	<span class="function">Counter <span class="title">getCounter</span><span class="params">(<span class="keyword">final</span> String name)</span></span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">LocalCounter</span> <span class="keyword">implements</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="title">LocalCounter</span><span class="params">()</span></span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"LocalCounter Constructor"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				System.out.println(name);</span><br><span class="line">				<span class="keyword">return</span> count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> LocalCounter();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//匿名类</span></span><br><span class="line">	<span class="function">Counter <span class="title">getCounter2</span><span class="params">(<span class="keyword">final</span> String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Counter()&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				System.out.println(<span class="string">"Counter Constructor"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				System.out.println(name);</span><br><span class="line">				<span class="keyword">return</span> count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		LocalInnerClass lc = <span class="keyword">new</span> LocalInnerClass();</span><br><span class="line">		Counter c1 = lc.getCounter(<span class="string">"Local Counter"</span>);</span><br><span class="line">		Counter c2 = lc.getCounter2(<span class="string">"Annoy Counter"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">			System.out.println(c1.next());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">			System.out.println(c2.next());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;我们分别使用局部内部类和匿名类实现了相同的计数功能。</p>
<p><img src="/2018/11/15/【Java编程思想】十一：内部类/png11.png" alt="png11"></p>
<p>&ensp;&ensp;&ensp;&ensp;它们具有相同的行为能力，那么既然局部类在方法体外部是看不见的，那么为什么不使用匿名类呢？唯一的理由是我们需要一个已命名的构造器，或者重载构造器，而匿名类只能用于实例初始化。也就是说因为没有名字，所以没有可见的构造器。所以使用局部内部类的另一个原因就是需要不止一个该内部类的对象。</p>
<h1 id="十二、内部类标识符"><a href="#十二、内部类标识符" class="headerlink" title="十二、内部类标识符"></a>十二、内部类标识符</h1><p>&ensp;&ensp;&ensp;&ensp;由于每个类都会产生一个.class文件，其中包含如何创建该类型的全部信息。（此信息产生一个“meta-class”,叫做class对象）所以内部类也一定会有个.class文件，它们有规范的命名规则，外围类加上“$”加上内部类的名字。</p>
<p>&ensp;&ensp;&ensp;&ensp;如果是匿名内部类，编译器会简单的产生一个数字作为标识符，如果内部类是嵌套在别的内部类里，那么就继续使用”$”符号。</p>
<h1 id="十三、总结"><a href="#十三、总结" class="headerlink" title="十三、总结"></a>十三、总结</h1><p>&ensp;&ensp;&ensp;&ensp;1.内部类是定义在一个类内部的类，这个类可以在方法中，也可以在方法外。内部类可以访问到其外部类的所有域。<br>&ensp;&ensp;&ensp;&ensp;2.内部类与外部类之间的关联关系是使用一个隐式的外部类引用，所以在创建内部类时，需要先创建一个外部类引用进行关联。这种形式出现在当内部类不是static修饰并且在static方法域中创建内部类对象引用的时候。<br>&ensp;&ensp;&ensp;&ensp;3.在内部类中，要使用外部类.this才可以返回外部类的对象引用，如果使用this只是返回了内部类的对象引用。当我们创建了一个外部类对象引用时，可以使用引用.new 内部类（）的形式创建内部类对象。<br>&ensp;&ensp;&ensp;&ensp;4.内部类可以用来向上转型实现接口，这种方式有效的建立了接口与实现的隔离，可以使实现完全不可见，不可修改。<br>&ensp;&ensp;&ensp;&ensp;5.在方法和作用域里的类，有两个作用，一个是如前所示用来实现接口并返回。另一个原因是我想创建一个类辅助我解决问题，但是不想这个类可见。<br>&ensp;&ensp;&ensp;&ensp;6.使用return new xx（）{} 在{}内部定义类的一些域可以创建一个实现或继承xx的匿名类，这个匿名类没有名字，也就没有构造函数。匿名类使用的外部方法引用需要被修饰为final。<br>&ensp;&ensp;&ensp;&ensp;7.如前所示，内部类的创建需要与外部类进行关联。如果我们不需要进行关联，那么可以将内部类修饰为static，这种称为嵌套类。嵌套类与外部类彼此独立。<br>&ensp;&ensp;&ensp;&ensp;8.内部类可以实现类似“多重继承”。<br>&ensp;&ensp;&ensp;&ensp;9.内部类与外部类的引用有关联，所以在继承内部类的时候需要显示的在构造函数中引用外部类的引用，以说明这种关联。<br>&ensp;&ensp;&ensp;&ensp;10.外部类被继承之后，内部类没有发生特别的变化，也就是它不会被覆盖，如果在子类中重新定义同名的内部类，这会被认为是第二个类，与之前的内部类彼此在不同的命名空间，没有关联。<br>&ensp;&ensp;&ensp;&ensp;11.局部内部类是定义在方法中的，作用与匿名类相同，但是有构造函数，可以进行构造函数重载。<br>&ensp;&ensp;&ensp;&ensp;12.所有的类都有标识符，内部类的标识符为外部类名字$内部类名字。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/15/【Java编程思想】1-10章总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crayon Cxy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ordinary Road">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/15/【Java编程思想】1-10章总结/" itemprop="url">【Java编程思想】1-10章总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-15T09:37:44+08:00">
                2018-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/15/【Java编程思想】1-10章总结/" class="leancloud_visitors" data-flag-title="【Java编程思想】1-10章总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、对象导论"><a href="#一、对象导论" class="headerlink" title="一、对象导论"></a>一、对象导论</h1><p>&ensp;&ensp;&ensp;&ensp;面向对象编程的思想主要针对的是对象，Java把一切待解决的事物都抽象了出来做为对象，每一个种类的对象都有一个特定的类别，它们有共同的属性和行为。程序是对象的集合，每个程序都由对象组成，每个对象都可以由其它对象组成。对象的特性规定了这个对象能接收什么样的消息，相同类型的对象可以接收相同的消息。消息在对象中的传递是通过接口进行的，并且每个接受消息的对象都可以提供一个特定的服务。<br>&ensp;&ensp;&ensp;&ensp;Java提供三种访问权限控制 public 包内可见包外需要引用、private 类可见、protected 类以及继承类可见。组合跟继承是创建新类的两种形式，组合就是在新类中引入其它对象的实例，表示一种has-a的关系，继承是在基类的基础上衍生出子类的概念，子类具有基类全部的成员跟方法并且子类可以有更多的成员跟方法，继承是一种is-a的关系。<br>&ensp;&ensp;&ensp;&ensp;不同子类继承了同一个基类的同一个方法可以有不同的实现，这是JAVA三大特性多态的一种表现，可以给应该传递父类参数的形参传递一个子类对象的引用，JAVA通过向上转型和动态绑定机制准确的找到子类应该实现的方法。<br>&ensp;&ensp;&ensp;&ensp;Java中所有的类都继承自Object，这种方式的好处是在某些不知道是什么类型的地方可以直接调用Object提供的方法。<br>&ensp;&ensp;&ensp;&ensp;Java中提供了Map、List、Set等集合，这种集合是对象的集合，不同的集合有不同的存储方式。<br>&ensp;&ensp;&ensp;&ensp;Java中的对象都是使用new创建在堆上的，这是一种动态的内存分配方式，Java使用垃圾回收机制自动回收不需要使用的内存。<br>&ensp;&ensp;&ensp;&ensp;Java中提供了异常处理机制，在程序发生异常时会执行另一条路线。<br>&ensp;&ensp;&ensp;&ensp;Java支持多线程的并发式编程以及网络Web程序应用开发。</p>
<h1 id="二、一切都是对象"><a href="#二、一切都是对象" class="headerlink" title="二、一切都是对象"></a>二、一切都是对象</h1><p>&ensp;&ensp;&ensp;&ensp;Java中的一切都是对象，但是我们操作的是对象的引用。String s；只是创建了一个引用没有进行初始化也就是这个引用没有绑定对象，String s = “abc”；创建了引用s，并进行了初始化绑定了一个字符串对象。<br>&ensp;&ensp;&ensp;&ensp;Java中的对象都是我们使用new关键字来创建的。对象的内存分配地址主要有寄存器：处理器内部的快速处理单元；堆栈：位于随机存储器RAM中，速度仅次于寄存器，堆栈使用堆栈指针操作分配内存，这种分配方式必须制定大小和生命周期，限制了灵活性。Java中对象的引用在堆栈中但是对象并不在堆栈中；堆：同样在RAM中的内存池，区别在于使用的时候不需要指定大小和生命周期，提高了灵活性，Java中使用new关键字创建的对象都在堆中；常量存储：程序代码的内部，在与程序本身分离的系统中，它存在ROM中（只读存储器）；非RAM区：如硬盘、数据库等外部存储。<br>&ensp;&ensp;&ensp;&ensp;Java具有较好的平台移植性，因为Java中的基本类型大小在所有平台都相同，Java中的基本类型存储在堆栈中。常见的大小：int 4字节 short 2字节 char 2字节 float 4字节 long 8字节 double 8字节。<br>&ensp;&ensp;&ensp;&ensp;Java中使用Class创建类，类是同一类型对象的集合。对象存在的意义是类的实例化。类中有两种域，一个是属性，一个是方法。<br>&ensp;&ensp;&ensp;&ensp;Java中方法的基本组成包括返回值、方法名、参数、方法体。String toString（Objecct obj）{//—}；调用形式使用对象引用.方法的形式，如s.toString（）。</p>
<h1 id="三、static关键字的用法"><a href="#三、static关键字的用法" class="headerlink" title="三、static关键字的用法"></a>三、static关键字的用法</h1><p>&ensp;&ensp;&ensp;&ensp;修饰成员变量：被修饰的成员变量为静态成员变量，这个变量不需要对象就可以通过类.变量的形式直接调用，这个变量只有在第一次使用的时候加载分配内存一次，后边再次用到时不进行加载内存分配。<br>&ensp;&ensp;&ensp;&ensp;修饰成员方法：被修饰的成员方法为静态方法，这个方法可以直接通过类.方法的形式调用。这个最直接的应用场景就是在使用单例模式的时候，我们想通过一个方法获取对象，而此时我们还没有对象可以调用这个方法，因此这个时候获取对象的方法设置成为static的最好不过了。<br>&ensp;&ensp;&ensp;&ensp;修饰代码块：修饰代码块的作用与前边相同，表示这个块的内部都是静态的。<br>&ensp;&ensp;&ensp;&ensp;静态导入：还有一种不太常用的形式就是在另外一个包的静态方法，可以使用import static导入，从而直接使用这个方法。</p>
<h1 id="四、操作符"><a href="#四、操作符" class="headerlink" title="四、操作符"></a>四、操作符</h1><p>&ensp;&ensp;&ensp;&ensp;Java跟其他语言一样支持+ - * / % 等操作符，同时优先级计算顺序也是先乘除后加减有括号先计算括号。<br>&ensp;&ensp;&ensp;&ensp;赋值操作符=将操作符右边的值赋给左边的变量，左边不能是常量。如果使用=连接两个对象的引用，那么=左边的对象会被释放。这种现象叫做“别名”现象，避免这种现象的赋值方式为使用引用.域赋值。<br>&ensp;&ensp;&ensp;&ensp;自增自减与其它语言一样，分为前缀式和后缀式，前缀式++a表示这个值先+1然后再进行例如赋值运算等操作，而后缀式a++则表示先取a的值做赋值或者其他操作，然后再+1<br>&ensp;&ensp;&ensp;&ensp;关系操作符==和！=在用于基本类型操作时与其它语言相同，而对于对象操作时，略有不同。==（！=）对于对象的操作是比较引用的地址是否相同。因为是两个不同的对象引用，所以地址肯定不同。Java中Obejct类提供equals（）方法，实际上也是比较引用的地址，而继承Obejct类的大多数如String类，都覆盖了这个方法，改为判断对象的类型是否相同以及值是否相同。          </p>
<p>&ensp;&ensp;&ensp;&ensp;Java中的逻辑操作符只能应用于布尔值之间，逻辑运算存在短路的可能，位运算符不存在短路的可能。左移（&lt;&lt;）位操作符低位补0，右移（&gt;&gt;）位操作符正数高位补0，负数高位补1，无符号右移（&gt;&gt;&gt;）不管正负高位都补0<br>&ensp;&ensp;&ensp;&ensp;三元运算符自带if-else判断分支，A?B:C如果A为真则表达式取B的值，否则取C的值，常用的地方就是给表达式赋值的时候判断是否为null，为null的时候赋值“”。<br>&ensp;&ensp;&ensp;&ensp;+=和+字符串操作符用来连接两个字符串，如果前边为String类型而后边不为String，后边会被尝试转为String。<br>&ensp;&ensp;&ensp;&ensp;Java支持使用（类型A）值的形式将值显示的转换成A类型。<br>&ensp;&ensp;&ensp;&ensp;Java支持全平台迁移，sizeof函数的意义在于计算值的字节长度，然后考虑平台迁移的问题。</p>
<h1 id="五、控制执行流程"><a href="#五、控制执行流程" class="headerlink" title="五、控制执行流程"></a>五、控制执行流程</h1><p>&ensp;&ensp;&ensp;&ensp;if-else、for、while这些与其它语言没有区别，for-each用来循环获取一个集合中的值。for（A a ：Array[A]）</p>
<h1 id="六、构造与清理"><a href="#六、构造与清理" class="headerlink" title="六、构造与清理"></a>六、构造与清理</h1><p>&ensp;&ensp;&ensp;&ensp;Java中使用与类名相同的无返回值的函数作为构造函数进行初始化。当使用new创建对象的时候，就调用了构造函数。类中如果没有显示的指明构造函数，那么默认为无参的构造函数。如果显示的提供了一个且仅有一个的带参数的构造器，那么该类的无参构造器将不可用。<br>&ensp;&ensp;&ensp;&ensp;Java中支持方法的重载，重载是指函数名相同，但是参数类型或者参数个数不同的形式，重载包括构造器重载和普通函数重载。返回值不同的这种重载容易使人疏忽。<br>&ensp;&ensp;&ensp;&ensp;Java中的this关键字有三种用法：一表示当前对象的引用，并返回当前对象，如在构造器中使用return this 返回该类的对象，二是表示该类中的成员变量，如在带有参数的构造器中，形参与成员变量相同，那么此时使用this.a=a 用来区分是把形参赋值给成员变量。三在一个构造器中调用另一个构造器的时候，使用this代替构造器的名称。<br>&ensp;&ensp;&ensp;&ensp;Java中的垃圾回收不一定会发生，一般如果不显示的调用GC，只有在资源快要枯竭的时候才会发生，因为垃圾回收也会占用资源。<br>&ensp;&ensp;&ensp;&ensp;Java会尽量保证每个变量都会被初始化，如果局部变量没有初始化就调用那么会报错，而成员变量没有显示的初始化，编译器会给赋默认值。<br>&ensp;&ensp;&ensp;&ensp;JavaSE5之前，可以使用Object类型的数组来做变参函数，因为所有类型都是Object的子类，SE5之后提供了 …的形式作为变参函数使用。<br>&ensp;&ensp;&ensp;&ensp;枚举在Java中实际上是一个类，枚举是一系列常量值的集合。枚举的另一个使用场景是使用一个只有单一常量值的枚举来实现单例模式。</p>
<h1 id="七、访问权限控制"><a href="#七、访问权限控制" class="headerlink" title="七、访问权限控制"></a>七、访问权限控制</h1><p>&ensp;&ensp;&ensp;&ensp;Java中提供了包的概念，包是一系列.java的集合，不同包中访问资源需要使用import关键字导入要使用的包。不同包中的类可以重名。<br>&ensp;&ensp;&ensp;&ensp;public：包可见权限，被public修饰的内容同一个包中都可见，当使用了import关键字导入新包的时候，新包中的public域也能被访问。<br>&ensp;&ensp;&ensp;&ensp;private：私有可见，除了当前类，其它都不可见，包括该类的实例化对象也不可访问该类的private域，比如在单例模式中，将类的构造函数私有化，可以有效的控制实例产生的个数。<br>&ensp;&ensp;&ensp;&ensp;protected：继承可见，与private类似，只有自己的类可见，同时支持该类的继承类访问。<br>一个文件中最多只能有一个被修饰为public的类。</p>
<h1 id="八、复用类"><a href="#八、复用类" class="headerlink" title="八、复用类"></a>八、复用类</h1><p>&ensp;&ensp;&ensp;&ensp;对象初始化有四种方式：1是在创建对象引用的时候使用new关键字，2是在构造器中进行初始化，3是延迟加载当用到的时候才进行初始化，4是使用实例进行初始化，即用一个确定的实例代替new关键字。<br>&ensp;&ensp;&ensp;&ensp;组合是产生新类的一种复用形式，组合的基本语法是在一个新类中创建旧类的对象，然后使用这个对象。<br>&ensp;&ensp;&ensp;&ensp;继承也是产生新类的一种复用形式，继承使用extends关键字，被继承的类称作基类，继承类称作导出类，导出类拥有基类的全部域跟方法，并且可以根据具体业务增加新的功能。导出类同时可以重载基类的方法。使用继承的主要场景是想使用基类的一部分方法。<br>&ensp;&ensp;&ensp;&ensp;Java中没有明确的提供对代理的直接支持，可以在A类中定义一个方法，然后在这个方法中使用另一个类的对象调用方法，在main函数中通过调用A中定义的方法来实现业务功能。<br>&ensp;&ensp;&ensp;&ensp;一个方法的形参为基类，传递的参数为子类，编译器会将子类转换成基类，这个过程称作向上转型。由于子类是父类的超集，所以向上转型是安全的。<br>&ensp;&ensp;&ensp;&ensp;final关键字用来修饰一个不可被改变的域。用来修饰变量，表示变量值不可被改变，用来修饰参数，表示这个参数指向的对象不可被改变，用来修饰方法，表示这个方法被锁定，不能被重写，用来修饰类，表示该类不能被继承。<br>&ensp;&ensp;&ensp;&ensp;类的资源加载过程：先查找main函数，然后确定这个类是否有基类，有基类向上加载，直到最顶层的基类。然后加载基类中的static域，然后是子类中的static域。这时候必要的资源都已经加载完成，开始对象的创建。先执行基类构造函数，然后按顺序初始化域，最后执行子类构造函数。</p>
<h1 id="九、多态"><a href="#九、多态" class="headerlink" title="九、多态"></a>九、多态</h1><p>&ensp;&ensp;&ensp;&ensp;直到运行的时候才确定对象引用调用哪个方法这个行为叫做后期绑定，Java中出了static和final修饰的域其它的都是动态绑定。子类跟基类都具有相同的方法但是实现不同这种称为方法的覆盖或者是重写。也就是因为向上转型和动态绑定，Java中传递不同的参数实现了相应的功能，这也就是多态的意义所在。<br>&ensp;&ensp;&ensp;&ensp;私有方法被重写会当做是新的方法。因为私有方法是不可见的。解决问题的方式是避免出现跟父类私有方法重名的方法。<br>&ensp;&ensp;&ensp;&ensp;只有普通的方法是多态的，域和静态方法都不是多态的。<br>&ensp;&ensp;&ensp;&ensp;一个方法的返回值为指定返回值的子类，这种形式称为协变返回类型。</p>
<h1 id="十、接口"><a href="#十、接口" class="headerlink" title="十、接口"></a>十、接口</h1><p>&ensp;&ensp;&ensp;&ensp;抽象方法，只有方法定义没有方法实现的被abstract修饰的方法称为抽象方法。<br>&ensp;&ensp;&ensp;&ensp;包含有抽象方法的被abstract修饰的类称作是抽象类。抽象类是不安全的，不能够创建对象，同时可以创建一个没有任何抽象方法的类，这个类存在的目的就是不想让这个类创建对象。继承abstract的类，必须实现基类的abstract方法，否则子类也要被定义为abstract类。<br>&ensp;&ensp;&ensp;&ensp;将class关键字替换成interface即创建了一个接口，接口中所有的方法都是只有定义没有具体实现的。所有的域都被隐式的修饰为static final。如果我们想实现一个接口的话使用implements关键字实现这个接口。<br>&ensp;&ensp;&ensp;&ensp;对于形参类型是类的参数，我们只能传递这个类或者是子类，而对于形参是接口类型的方法，则所有使用implements关键字实现了这个接口的类都可以作为参数传递。<br>&ensp;&ensp;&ensp;&ensp;Java不支持多重继承，但是可以实现多个接口。接口也可以继承接口，也可以继承多个接口。<br>&ensp;&ensp;&ensp;&ensp;适配器模式用来将两个不能一起工作的类，适配在一起。<br>&ensp;&ensp;&ensp;&ensp;接口中的域隐式的为static final 这是SE5之前可以用来实现枚举类型。<br>&ensp;&ensp;&ensp;&ensp;接口也支持嵌套接口，在实现一个接口的时候，不需要实现它内部嵌套的接口。并且private接口只能在定义它的类中使用。<br>&ensp;&ensp;&ensp;&ensp;工厂方法模式允许在不同的类型中复用同一段代码。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/14/【Java编程思想】十：接口/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crayon Cxy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ordinary Road">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/14/【Java编程思想】十：接口/" itemprop="url">【Java编程思想】十：接口</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-14T14:35:13+08:00">
                2018-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/14/【Java编程思想】十：接口/" class="leancloud_visitors" data-flag-title="【Java编程思想】十：接口">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、抽象类和抽象方法"><a href="#一、抽象类和抽象方法" class="headerlink" title="一、抽象类和抽象方法"></a>一、抽象类和抽象方法</h1><p>&ensp;&ensp;&ensp;&ensp;在前边关于多态的例子中，基类方法往往没有具体的实现，它存在的目的是为不同的子类提供统一的方法，通过动态绑定以及向上转型来完成子类需要的功能。为此，我们可以创建一个这样的类，只为子类提供接口，并且不允许这个类实例化对象，我们可以让这个类中的方法返回一个错误信息，但是这样存在一个问题，错误只能在运行时产生并且带来的影响不可预估。Java为我们提供了一个更加明确的方法，称为抽象方法，抽象方法顾名思义它是虚拟存在的，也就是它不能够被执行。这种方法是不完整的，它只有方法的声明，没有方法的实现，为了区分，使用abstract关键字表示一个方法是抽象方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;包含抽象方法的类叫做抽象类，如果一个类包含一个或多个抽象方法，那么这个类叫做抽象类，同样使用abstract关键字修饰。抽象类是不安全的，因为它不完整，所以当试图用它实例化一个对象时，编译器会报错。如果一个类继承自一个抽象类，那么它必须为基类中所有的抽象方法提供一个具体的实现，否则这个子类也必须被定义为抽象类。我们也可以定义一个没有任何方法（包括没有抽象方法）的抽象类，这样做的目的是，这个类没有什么实际的意义，同时也不想让它能够创建对象。</p>
<p>&ensp;&ensp;&ensp;&ensp;下面一个示例看下抽象类和抽象方法的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.test;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Instrumet"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String s)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Wind"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Wind.play"</span> + s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Percussion</span> <span class="keyword">extends</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Percussion"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Percussion.play"</span> + s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stringed</span> <span class="keyword">extends</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Stringed"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Stringed.play"</span> + s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass</span> <span class="keyword">extends</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Brass"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Brass.play"</span> + s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WoodWind</span> <span class="keyword">extends</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"WoodWind"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"WoodWind.play"</span> + s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i )</span></span>&#123;</span><br><span class="line">		i.play(<span class="string">"finish"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tuneAll</span><span class="params">(Instrument[] e)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(Instrument i:e)&#123;</span><br><span class="line">			tune(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Instrument[] iArray = &#123;</span><br><span class="line">				<span class="keyword">new</span> Wind(),<span class="keyword">new</span> Percussion(),<span class="keyword">new</span> Brass(),<span class="keyword">new</span> Stringed(),<span class="keyword">new</span> WoodWind()</span><br><span class="line">		&#125;;</span><br><span class="line">		tuneAll(iArray);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/14/【Java编程思想】十：接口/png1.png" alt="png1"></p>
<p>&ensp;&ensp;&ensp;&ensp;如上可见，创建抽象类和抽象方法非常的有用，因为他们使类的抽象性更加明确，并告诉用户和编译器打算怎么样使用他们。抽象类还是一个很有用的重构工具，因为他们使得我们可以很容易的将公共方法沿着继承的层次向上移动。</p>
<h1 id="二、接口"><a href="#二、接口" class="headerlink" title="二、接口"></a>二、接口</h1><p>&ensp;&ensp;&ensp;&ensp;关键字使抽象的概念更加深入了一步。抽象类中可以允许抽象方法和普通方法共存，普通方法存在的目的是为所有继承的子类提供一个相同实现的方法。而接口创建了一个完全抽象的概念，接口内部不存在任何方法具体的实现。所有的实现都交由到实现这个接口的类完成。</p>
<p>&ensp;&ensp;&ensp;&ensp;接口使用interface关键字代替class关键字，访问权限控制与一个class相同，接口中可以包含域，但是这些域被隐式的定义为static和final型。</p>
<p>&ensp;&ensp;&ensp;&ensp;要想实现一个接口，就需要使用implements关键字显示的指明要实现哪个接口。接口中的方法必须被定义为public方法。实现接口的类要显示的编写实现接口中的所有方法，即便有些方法不需要实现，那也要如同接口一样写一个空的方法体。</p>
<p>&ensp;&ensp;&ensp;&ensp;修改上边抽象类的示例为接口实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.test;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">implements</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Wind"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Wind.play"</span> + s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Percussion</span> <span class="keyword">implements</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Percussion"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Percussion.play"</span> + s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stringed</span> <span class="keyword">implements</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Stringed"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Stringed.play"</span> + s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass</span> <span class="keyword">implements</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Brass"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Brass.play"</span> + s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WoodWind</span> <span class="keyword">implements</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"WoodWind"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"WoodWind.play"</span> + s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i )</span></span>&#123;</span><br><span class="line">		i.play(<span class="string">"finish"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tuneAll</span><span class="params">(Instrument[] e)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(Instrument i:e)&#123;</span><br><span class="line">			tune(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Instrument[] iArray = &#123;</span><br><span class="line">				<span class="keyword">new</span> Wind(),<span class="keyword">new</span> Percussion(),<span class="keyword">new</span> Brass(),<span class="keyword">new</span> Stringed(),<span class="keyword">new</span> WoodWind()</span><br><span class="line">		&#125;;</span><br><span class="line">		tuneAll(iArray);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/14/【Java编程思想】十：接口/png2.png" alt="png2"></p>
<h1 id="三、完全解耦"><a href="#三、完全解耦" class="headerlink" title="三、完全解耦"></a>三、完全解耦</h1><p>&ensp;&ensp;&ensp;&ensp;只要一个方法操作的是类而非接口，那么你就只能使用这个类及其子类。如果你想将这个方法应用在不在此继承结构中的某个类，那么使用接口将很大程度的放宽这种限制。因此，它可以使我们编写可复用性更好的代码。<br>&ensp;&ensp;&ensp;&ensp;例如，有一个Processor类，它有一个name（）方法，还有一个process（）方法，该方法接受输入参数，修改输入的值然后进行输出。这个类作为基类被扩展，子类创建各种不同类型的Processor，在本例中，Processor子类通过process（）方法修改String对象的值，返回类型可以是协变类型，而非参数类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.test;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Object <span class="title">process</span><span class="params">(Object input)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> input;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpCase</span> <span class="keyword">extends</span> <span class="title">Processor</span></span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">process</span><span class="params">(Object input)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> input.toString().toUpperCase();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownCase</span> <span class="keyword">extends</span> <span class="title">Processor</span></span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">process</span><span class="params">(Object input)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> input.toString().toLowerCase();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Splitter</span> <span class="keyword">extends</span> <span class="title">Processor</span></span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">process</span><span class="params">(Object input)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Arrays.toString(input.toString().split(<span class="string">" "</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apply</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Processor p,Object s)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Using Processor:"</span> + p.name());</span><br><span class="line">		System.out.println(p.process(s));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String S = <span class="string">"Disagreement with beliefs is by definition incorrect"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		process(<span class="keyword">new</span> UpCase(), S);</span><br><span class="line">		process(<span class="keyword">new</span> DownCase(), S);</span><br><span class="line">		process(<span class="keyword">new</span> Splitter(), S);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/14/【Java编程思想】十：接口/png3.png" alt="png3"></p>
<p>&ensp;&ensp;&ensp;&ensp;前边学习多态的时候有过类似的例子，Apply.process()方法可以接收Processor类型跟它的子类，并将它应用到了Object对象，然后打印。像这种，根据继承关系，创建一个能够根据所传递的参数对象不同而具有不同行为的方法，称为策略设计模式。这类方法包含索要执行的方法中固定不变的部分（如本例的name（）方法），而“策略”包含变化的部分（如本例的process（））方法。策略就是传递的参数对象，它包含要执行的代码。这类Processor对象就是一个策略，在main（）方法中可以看到三种不同类型的策略应用到Obejct对象上。</p>
<p>&ensp;&ensp;&ensp;&ensp;下面有如下4个类，他们看起来也适用Apply.process()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> WaveForm <span class="title">process</span><span class="params">(WaveForm input)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> input;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;Filter类，看上去与Processor类似，都有name（）方法和process（）方法，区别在于方法的参数类型和返回类型不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighPass</span> <span class="keyword">extends</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> cutoff;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HighPass</span><span class="params">(<span class="keyword">double</span> cutoff)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cutoff = cutoff;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> WaveForm <span class="title">prcess</span><span class="params">(WaveForm input)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> input;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;HighPass类，继承自Filter类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BandPass</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> lowCutoff,highCutoff;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BandPass</span><span class="params">(<span class="keyword">double</span> lowCutoff,<span class="keyword">double</span> highCutoff)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.lowCutoff = lowCutoff;</span><br><span class="line">		<span class="keyword">this</span>.highCutoff = highCutoff;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> WaveForm <span class="title">process</span><span class="params">(WaveForm input)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> input;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;BandPass类，继承自Filter类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaveForm</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Wave Form"</span> + id;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;WaveForm类，前边方法的参数类型和返回类型。</p>
<p>&ensp;&ensp;&ensp;&ensp;Filter与Processor类具有相同的内部接口元素（两个类的方法名都相同），但是由于Filter类并非继承自Processor类，因此当Apply.process（）方法传入参数Filter的时候，由于Filter类的创建者并不知道要当做Processor类使用，并且它也不能通过向上转型的方式变成Processor类，因此不能将Filter类应用到Apply.process（）方法。这主要是因为Apply.process（）方法和Processor类的耦合度太高了，已经超出了所需要的程度。这就是Apply.process（）方法只能接收Processor类或者其子类，而面对新的类的时候，Apply.process（）方法就无能为力了，对其的复用也就被禁止了。</p>
<p>&ensp;&ensp;&ensp;&ensp;但是，正如前文所说，如果操作的是接口而不是类的时候，那么这些限制就会变得松动，使得你可以复用接口的Apply.process()方法，下面是修改为接口的版本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span></span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">Object <span class="title">process</span> <span class="params">(Object input)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;此时Processor类变成了一个接口，复用代码的形式就是之前继承它的类，可以改为实现它的接口，并且Filter类，也可以编程实现Processor类的接口，这样Apply.process（）方法的耦合度就降低了，并且支持了其它的类型。还有一种情况，假如一个类是被发现的，而不是被我们自己创建的，那么这个类就无法实现Processor接口，比如说，如果Filter类是在类库中的类，那么这个类就无法主动实现Processor接口，这时候可以使用适配器模式，在这个类的外部封装一层，作为适配器来实现要实现的接口。如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterAdapter</span> <span class="keyword">implements</span> <span class="title">Processor</span></span>&#123;</span><br><span class="line">	Filter filter;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FilterAdapter</span><span class="params">(Filter filter)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.filter = filter;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> filter.name();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> WaveForm <span class="title">process</span><span class="params">(Object input)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> filter.process((WaveForm)input)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterProcessor</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		WaveForm w = <span class="keyword">new</span> WaveForm();</span><br><span class="line">		Apply.process(<span class="keyword">new</span> FilterAdapter(<span class="keyword">new</span> LowPass(<span class="number">1.0</span>)),w);</span><br><span class="line">		Apply.process(<span class="keyword">new</span> FilterAdapter(<span class="keyword">new</span> HighPass(<span class="number">2.0</span>)),w);</span><br><span class="line">		Apply.process(<span class="keyword">new</span> FilterAdapter(<span class="keyword">new</span> BandPass(<span class="number">3.0</span>,<span class="number">4.0</span>)),w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;在这种使用适配器的方式中，FilterAdapter的构造器接受了Filter参数，然后生成对应接口Processor的对象。<br>本节主要的内容是使用接口的方式将只有基类和其子类的使用方法解耦出来，便于程序更好的进行复用。</p>
<h1 id="四、Java中的多重继承"><a href="#四、Java中的多重继承" class="headerlink" title="四、Java中的多重继承"></a>四、Java中的多重继承</h1><p>&ensp;&ensp;&ensp;&ensp;C++中允许多重继承，并且每一个继承的类都可以有一个实现，Java中是不允许的，Java中可以实现多个接口，每个接口名字在implements后边用逗号隔开，并且，Java中只能继承一个类。下面的例子说明一个具体的类组合实现多个接口产生一个新类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFight</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Fight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanSwim</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFly</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionChracter</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fight</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//---</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span> <span class="keyword">extends</span> <span class="title">ActionChracter</span> <span class="keyword">implements</span> <span class="title">CanFight</span>,<span class="title">CanSwim</span>,<span class="title">CanFly</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//---</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Swim</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//--</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adventure</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">t</span><span class="params">(CanFight x)</span></span>&#123;</span><br><span class="line">		x.Fight();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">u</span><span class="params">(CanSwim x)</span></span>&#123;</span><br><span class="line">		x.Swim();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">(CanFly x)</span></span>&#123;</span><br><span class="line">		x.Fly();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">(ActionChracter x)</span></span>&#123;</span><br><span class="line">		x.Fight();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Hero h = <span class="keyword">new</span> Hero();</span><br><span class="line">		t(h);</span><br><span class="line">		u(h);</span><br><span class="line">		v(h);</span><br><span class="line">		w(h);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;可以看到Hero类组合具体类ActionChracter和另外的三个接口，当通过这种方式将类和接口组合在一起时，这个类必须放在前边，接口放在后边，否则编译器会报错。同时我们注意到，CanFight接口与ActionChracter类中的Fight（）方法相同，而且Hero中并没有提供Fight（）的具体定义。可以扩展接口，当想要创建对象的时候，所有的定义必须都存在，即使Hero没有显示的定义Fight（）方法，由于其继承了ActionChracter类，所以定义随之而来，这使创建对象变成了可能。这里的意思是说，一个类实现了某些接口，这些接口中所有的定义在这个类中必须要有相关的实现（编译器会主动提示），然后因为这个类继承了一个类（ActionChracter），所以如果基类有实现了接口中的方法，那么子类就可以不显示的实现这个方法。（区别在于基类不是实现了这个方法，只是方法签名相同）</p>
<p>&ensp;&ensp;&ensp;&ensp;这个例子中，给出的四个方法分别使用接口作为了参数，所以在Hero作为参数传递的时候，它被依次进行了向上转型，Java中的接口设计，使得这项功能并不复杂。这个例子所展示的是使用接口的核心原因：为了能够向上转型为多个基本类型，提升程序的灵活性。使用接口的第二个原因与抽象类相同，防止程序员在使用的过程中创建该类的对象。当然关于这一点是使用抽象类还是接口，当要创建的类中没有任何方法定义和成员变量的定义是，选择接口是合适的，并且当知道某事物应当成为一个基类的时候，那么第一选择是应当使它成为接口。</p>
<h1 id="五、通过继承扩展接口"><a href="#五、通过继承扩展接口" class="headerlink" title="五、通过继承扩展接口"></a>五、通过继承扩展接口</h1><p>&ensp;&ensp;&ensp;&ensp;接口也可以继承！没错，通过继承可以很容易的在接口中添加新的方法声明，还可以通过继承在新接口中组合数个接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Monster</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">menace</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新接口继承原来的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DangerousMonster</span> <span class="keyword">extends</span> <span class="title">Monster</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Lethal</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现接口 要依次定义这个接口的方法以及它继承接口的方法  编译器自动补充</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DragonZill</span> <span class="keyword">implements</span> <span class="title">DangerousMonster</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">menace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口可以多重继承</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Vampire</span> <span class="keyword">extends</span> <span class="title">DangerousMonster</span> ,<span class="title">Lethal</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">drinkblood</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承多个接口 都要把定义实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VeryBadVampire</span> <span class="keyword">implements</span> <span class="title">Vampire</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">menace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drinkblood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中标注了，接口可以使用extends继承多个，但是这一形式不适用于普通的类。</p>
<p>&ensp;&ensp;&ensp;&ensp;这里说到了上边例子中的CanFight类和ActionChracter类都有一个相同的方法，如果方法只是名字相同，参数类型不同，返回类型不同，那么将带来逻辑上很大的问题。因此在继承、实现接口、覆盖或者重载的时候，应尽量避免重名的问题出现</p>
<h1 id="六、适配接口"><a href="#六、适配接口" class="headerlink" title="六、适配接口"></a>六、适配接口</h1><p>&ensp;&ensp;&ensp;&ensp;接口最吸引人的地方，就是允许同一个接口具有多个不同的实现。简单来说，就是一个接受接口类型的方法，而该接口的实现和向该接口传递的对象取决于方法的使用者。因此常用的方式就是前边的策略模式，此时你编写一个执行某些操作的方法，该方法接受一个同样是你指定的接口，你主要就是声明”你可以用任何你想要的对象来调用我的方法，只要你的对象遵循我的接口“这使你的方法更加灵活。</p>
<p>&ensp;&ensp;&ensp;&ensp;这里把我把上边适配接口的例子全部的代码撸了一遍，并分析了一下，具体的关于适配器模式后边会专门再学习一下，此处只是将书中的例子学习了一下</p>
<p>&ensp;&ensp;&ensp;&ensp;首先有个Processor接口，该接口有两个方法声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span></span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">Object <span class="title">process</span><span class="params">(Object input)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;然后是个Apply类，这个类有个静态方法process，为了解耦，传递的参数为接口类型，接口的方法作用于一个Object对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apply</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Processor p,Object s)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Using Processor"</span> + p.name());</span><br><span class="line">		System.out.println(p.process(s));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时我们发现了一个Filter类，因为这个类是发现的，所以看上去它跟Procesor接口有相同的方法，只是类型不同，所以可以直接实现该方法，但是由于这个类是已经写好了的。所以它不可以被修改了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Waveform input)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> input;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;然后是一个Waveform类，这个类作为Filter类process方法的返回值，定义了个toString方法，所以在打印的时候会调用这个toString方法并把输入的内容返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Waveform</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Waveform"</span> + id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;然后是Filter类的三个子类，分别实现了父类的process方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowPass</span> <span class="keyword">extends</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> cutoff;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LowPass</span><span class="params">(<span class="keyword">double</span> cutoff)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cutoff = cutoff;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Waveform input)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> input;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighPass</span> <span class="keyword">extends</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> cutoff;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HighPass</span><span class="params">(<span class="keyword">double</span> cutoff)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cutoff = cutoff;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Waveform input)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> input;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BandPass</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> lowCutoff,highCutoff;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BandPass</span><span class="params">(<span class="keyword">double</span> lowCutoff,<span class="keyword">double</span> highCutoff)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.lowCutoff = lowCutoff;</span><br><span class="line">		<span class="keyword">this</span>.highCutoff = highCutoff;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Waveform input)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> input;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;这个时候问题来了，因为Appply类的process方法传参数是接口，这时Filter类已经存在，想直接使用Apply的process方法行不通，想实现Processor接口已经来不及。那么就要使用适配器模式啦。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterAdapter</span> <span class="keyword">implements</span> <span class="title">Processor</span></span>&#123;</span><br><span class="line">	Filter filter = <span class="keyword">new</span> Filter();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FilterAdapter</span><span class="params">(Filter filter)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.filter = filter;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> filter.name();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> filter.process((Waveform)input);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterProcessor</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Waveform w = <span class="keyword">new</span> Waveform();</span><br><span class="line">		Apply.process(<span class="keyword">new</span> FilterAdapter(<span class="keyword">new</span> LowPass(<span class="number">1.0</span>)),w);</span><br><span class="line">		Apply.process(<span class="keyword">new</span> FilterAdapter(<span class="keyword">new</span> HighPass(<span class="number">2.0</span>)),w);</span><br><span class="line">		Apply.process(<span class="keyword">new</span> FilterAdapter(<span class="keyword">new</span> BandPass(<span class="number">3.0</span>,<span class="number">4.0</span>)),w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;这里我简单的理解了一下这里的适配器模式，就是写了一个适配器的类，这个类实现了Processor接口，内部接受了Filter对象参数，然后生成了你想要的Processor接口对象，达到了预期的目的。这里有关具体的设计模式分析，后边会继续学习。</p>
<h1 id="七、接口中的域"><a href="#七、接口中的域" class="headerlink" title="七、接口中的域"></a>七、接口中的域</h1><p>&ensp;&ensp;&ensp;&ensp;在接口中的域，会被自动的隐式转换为static final类型，所以接口就可以很便捷的创建一组常量值，也就是枚举。在JavaSE5之前，没有枚举的概念之前，可以使用接口来创建常量组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Months</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> JANUARY = <span class="number">1</span>,FEBRUARY=<span class="number">2</span>,MARCH=<span class="number">3</span>,APRIL=<span class="number">4</span>,</span><br><span class="line">			MAY=<span class="number">5</span>,JUNE=<span class="number">6</span>,JULY=<span class="number">7</span>,AUGUST=<span class="number">8</span>,SEPTEMBER=<span class="number">9</span>,OCTOBER=<span class="number">10</span>,</span><br><span class="line">			NOVEMBER=<span class="number">11</span>,DECEMBER=<span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;当然这种形式在后来已经被enum取代了。因为是final类型，所以必须显示的指定初始化的值，同时因为是static域，所以它们在第一次访问的时候被初始化，并且这些域不属于接口的一部分，它们的值存储在接口的静态存储区域。</p>
<h1 id="八、嵌套接口"><a href="#八、嵌套接口" class="headerlink" title="八、嵌套接口"></a>八、嵌套接口</h1><p>&ensp;&ensp;&ensp;&ensp;接口可以嵌套在类或者其它的接口中，个人觉得这种设计会使程序变得更加复杂不易读。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BImp</span> <span class="keyword">implements</span> <span class="title">B</span></span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BImp2</span> <span class="keyword">implements</span> <span class="title">B</span></span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">CImp</span> <span class="keyword">implements</span> <span class="title">C</span></span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CImp2</span> <span class="keyword">implements</span> <span class="title">C</span></span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">D</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DImp</span> <span class="keyword">implements</span> <span class="title">D</span></span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DImp2</span> <span class="keyword">implements</span> <span class="title">D</span></span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> D <span class="title">getD</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> DImp();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> D dRef;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reveiveD</span><span class="params">(D d)</span></span>&#123;</span><br><span class="line">		dRef = d;</span><br><span class="line">		dRef.f();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">E</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">G</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">H</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//强制必须为public</span></span><br><span class="line">	<span class="comment">//private interface I&#123;&#125;;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestingInterfaces</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BImp</span> <span class="keyword">implements</span> <span class="title">A</span>.<span class="title">B</span></span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">CImp</span> <span class="keyword">implements</span> <span class="title">A</span>.<span class="title">C</span></span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//因为接口D是私有的 所以不能被实现</span></span><br><span class="line">	<span class="comment">//class DImp implements A.D&#123;);</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">EImp</span> <span class="keyword">implements</span> <span class="title">E</span></span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">EGImp</span> <span class="keyword">implements</span> <span class="title">E</span>.<span class="title">G</span></span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">EImp2</span> <span class="keyword">implements</span> <span class="title">E</span></span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">EG</span> <span class="keyword">implements</span> <span class="title">E</span>.<span class="title">G</span></span>&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		A a = <span class="keyword">new</span> A();</span><br><span class="line">		<span class="comment">//D是private 不能实例化</span></span><br><span class="line">		<span class="comment">//A.D ad = new A.D();</span></span><br><span class="line">		<span class="comment">//getD()方法只能返回D</span></span><br><span class="line">		<span class="comment">//A.DImp2 di2 = a.getD();</span></span><br><span class="line">		<span class="comment">//private接口的域不能被访问</span></span><br><span class="line">		<span class="comment">//a.getD().f();</span></span><br><span class="line">		<span class="comment">//可以通过内部返回域的方法获取</span></span><br><span class="line">		A a2 = <span class="keyword">new</span> A();</span><br><span class="line">		a2.reveiveD(a.getD());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;这里主要要说明的就是private interface接口的作用，就像A.D接口一样，它能够被实现为DImp的一个内部类，也同样可以像DImp2一样实现为public类，但是正如main方法中倒数第4行代码一样，A.DImp2只能被自己使用，因为你无法说你实现了一个private接口D，因此这个实现只是一种形式而已，它可以强制该方法的定义不带有任何类型信息，即不可以向上转型。所以我们在get方法中return new DImp2 的时候并没有获取到预期的值，因为DImp2是一个实现了private接口的public类，最终我们还是通过receiveD方法获取到了相应的实例。<br>&ensp;&ensp;&ensp;&ensp;接口E说明了接口之间的嵌套关系，因为接口内部所有元素都是public的，所以不能指明嵌套在内部的接口为private。NestingInterfaces展示了嵌套接口的几种形式，特别注意的是，在实现一个接口的时候，不需要实现其内部嵌套接口的方法。而且private接口不能在定义它的类外部被实现，比如上述代码中的A.D</p>
<h1 id="九、接口与工厂"><a href="#九、接口与工厂" class="headerlink" title="九、接口与工厂"></a>九、接口与工厂</h1><p>&ensp;&ensp;&ensp;&ensp;接口是实现多重继承的重要途径，而生成遵循某个接口对象的典型方式就是工厂方法设计模式。由此可见设计模式的重要性，我自己最近也在学习这一块的内容。希望能够有所提高。<br>&ensp;&ensp;&ensp;&ensp;使用工厂方法与直接调用构造器不同，我们在工厂对象上调用的是创建方法，而该工厂对象将生成接口的某个实现的对象。理论上来说，我们通过这种方式可以将我们的代码与接口的实现完全分离，这就使我们可以透明的将某个实现替换成另一个实现。如下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">	<span class="function">Service <span class="title">getService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation1</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">	Implementation1() &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Implementation1 method1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Implementation1 method2"</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation1Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Implementation1();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation2</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">	Implementation2() &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Implementation2 method1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Implementation2 method2"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation2Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Implementation2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factories</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serviceConsumer</span><span class="params">(ServiceFactory fact)</span></span>&#123;</span><br><span class="line">		Service s = fact.getService();</span><br><span class="line">		s.method1();</span><br><span class="line">		s.method2();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		serviceConsumer(<span class="keyword">new</span> Implementation1Factory());</span><br><span class="line">		serviceConsumer(<span class="keyword">new</span> Implementation2Factory());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;这里如果不是使用工厂方法，代码中就要指定Service的确切类型，以便调用合适的构造器。使用工厂方法设计模式的原因是想要创建框架，提高代码的复用性。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GameFactory</span></span>&#123;</span><br><span class="line">	<span class="function">Game <span class="title">getGame</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checkers</span> <span class="keyword">implements</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> moves = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVES = <span class="number">3</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Checkers moves"</span> + moves);</span><br><span class="line">		<span class="keyword">return</span> ++moves != MOVES;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckersFactory</span> <span class="keyword">implements</span> <span class="title">GameFactory</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Game <span class="title">getGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Checkers();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chess</span> <span class="keyword">implements</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> moves = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVES = <span class="number">4</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Chess move"</span> + moves);</span><br><span class="line">		<span class="keyword">return</span> ++moves != MOVES;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChessFactory</span> <span class="keyword">implements</span> <span class="title">GameFactory</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Game <span class="title">getGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Chess();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Games</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PlayGame</span><span class="params">(GameFactory fact)</span></span>&#123;</span><br><span class="line">		Game s = fact.getGame();</span><br><span class="line">		<span class="keyword">while</span>(s.move())&#123;</span><br><span class="line">			<span class="comment">//--</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		PlayGame(<span class="keyword">new</span> CheckersFactory());</span><br><span class="line">		PlayGame(<span class="keyword">new</span> ChessFactory());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;如果Games类表示一段复杂的代码，那么这种方式就允许你在不同的游戏类型中复用这段代码。</p>
<h1 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h1><p>&ensp;&ensp;&ensp;&ensp;抽象类跟接口是将具体方法更加抽象的一种形式，这一章节主要讲了抽象类、抽象方法的形式以及使用场景，比较重要的一点是关于接口的使用，如何解耦，接口可以多重继承，接口可以嵌套等应用场景。关于这一章节中的设计模式，还要继续深入研究下去。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/13/【Java编程思想】九：多态/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Crayon Cxy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ordinary Road">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/13/【Java编程思想】九：多态/" itemprop="url">【Java编程思想】九：多态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-13T15:26:39+08:00">
                2018-11-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/13/【Java编程思想】九：多态/" class="leancloud_visitors" data-flag-title="【Java编程思想】九：多态">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、再讨论向上转型"><a href="#一、再讨论向上转型" class="headerlink" title="一、再讨论向上转型"></a>一、再讨论向上转型</h1><p>&ensp;&ensp;&ensp;&ensp;在第七章中我们说过，对象引用既可以作为它自己本身的类型使用，也可以作为它的基类型使用，这种把某个类型引用作为它的基类型使用的做法被称为向上转型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Instrument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//---</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Instrument-----:"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Wind-----:"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Instrument i)</span></span>&#123;</span><br><span class="line">		i.print();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Wind wind = <span class="keyword">new</span> Wind();</span><br><span class="line">		play(wind);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/13/【Java编程思想】九：多态/png1.png" alt="png1"></p>
<p>&ensp;&ensp;&ensp;&ensp;Main方法中play方法传递wind引用的时候，不需要做任何类型转换。这样做是允许的，因为Wind自Instrument类继承而来，所以Instrument类的接口必定存在于Wind类中。这种向上转型的特性，避免了重新编写方法带来的程序代码冗余问题。</p>
<h1 id="二、转机"><a href="#二、转机" class="headerlink" title="二、转机"></a>二、转机</h1><p>&ensp;&ensp;&ensp;&ensp;考虑一个新的问题，当我们有多个子类的时候，编译器是怎样知道我们传递给基类引用的参数是哪个子类呢？比如我们把刚才的程序做个修改，再增加一个子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Instrument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//---</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Instrument-----:"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Wind-----:"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rain</span> <span class="keyword">extends</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Rain-----"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Instrument i)</span></span>&#123;</span><br><span class="line">		i.print();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Rain rain = <span class="keyword">new</span> Rain();</span><br><span class="line">		play(rain);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="/2018/11/13/【Java编程思想】九：多态/png2.png" alt="png2"></p>
<p>&ensp;&ensp;&ensp;&ensp;在play方法中，既然做到了向上转型，那么编译器怎样知道类型从哪里转来的呢？即执行哪个对应的print（）方法呢？解决这个问题有一个新的概念叫后期绑定，就是程序运行时根据对象的类型来进行绑定，也叫做动态绑定。一种语言要想实现动态绑定，那么它必须具有某种特定的机制来支持它在运行时准确的找到对象引用对应的类型，随着语言的不同这种机制有所不同，但大体上都是在对象中增加了某种类型信息。<br>&ensp;&ensp;&ensp;&ensp;Java中除了static和final之外，其它所有的方法都是后期绑定，所以我们无需显示的去做什么操作，因为动态绑定会自动发生。而前期绑定并不会对性能造成什么影响，使用final修饰的意图是防止被覆盖，并且告诉编译器这个是前期绑定，那么编译器可以更好的为其分配资源。<br>&ensp;&ensp;&ensp;&ensp;上述代码中，不同的子类与基类都有相同的方法（返回值、方法名、参数列表都相同），但是方法体内部不相同，这种操作叫做方法的<strong>重写</strong>或者方法的覆盖，即子类覆盖了父类方法的实现，当参数传递为子类对象的引用时，虽然看似调用了父类的这个方法，但是实际上由于动态绑定调用了子类的方法，实现了不同的功能。这也就是面向对象编程中多态的意义所在。</p>
<p>方法的重写有如下几点缺陷：</p>
<p><strong>1.重写私有方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateOverride</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"private void f"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		PrivateOverride po = <span class="keyword">new</span> Derived();</span><br><span class="line">		po.f();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">PrivateOverride</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"public void f"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们期望重写了私有方法，但是实际结果并不会重写，编译器会当做一个新的方法执行。</p>
<p><img src="/2018/11/13/【Java编程思想】九：多态/png3.png" alt="png3"></p>
<p><strong>2.域与静态方法：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;实际上只有普通的方法调用可以是多态的，对于域和静态方法都不是多态的。域是在访问的时候编译期进行解析的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> field = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> field;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> field = <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> field;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSuperField</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.field;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fieldAccess</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Super sup = <span class="keyword">new</span> Sub();</span><br><span class="line">		System.out.println(<span class="string">"sup.field"</span> + sup.field + <span class="string">"---sup.GetField"</span> + sup.getField());</span><br><span class="line">		Sub sub = <span class="keyword">new</span> Sub();</span><br><span class="line">		System.out.println(<span class="string">"sub.field"</span> + sub.field + <span class="string">"---sub.GetField"</span> + sub.getField() + <span class="string">"---sub.GetSuperField"</span> + sub.getSuperField());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/13/【Java编程思想】九：多态/png4.png" alt="png4"></p>
<p>&ensp;&ensp;&ensp;&ensp;当Sub对象转型为Super引用时，任何域访问操作都将由对象编译器解析，因此不是多态的，所以第一行第一个值通过直接访问域的形式返回的是0，对于普通方法getField则是多态的，所以第一行第二个值返回1。第二行就比较好理解了，不涉及向上转型的问题，唯一使用了getSuperField方法显示的获取了基类的值。<br>在本例中为sub.field域和super.filed域分配了不同的内存空间，也就是对于sub来说他有两个field值，一个是它本身的field值，另一个是来自super继承的值，而在sub引用域field时使用的并非是来自super的值，而是它自己本身的默认值。在实际工作中，这种问题基本不会发生，避免问题出现的有效做法是将基类与子类的域分别起不同的名字。</p>
<p>&ensp;&ensp;&ensp;&ensp;静态方法由于只与类有关，而不与对象牵连，因此它不存在多态的形式。</p>
<h1 id="三、构造器和多态"><a href="#三、构造器和多态" class="headerlink" title="三、构造器和多态"></a>三、构造器和多态</h1><p>&ensp;&ensp;&ensp;&ensp;构造器属于类的，它是一个隐式的static方法，因此不存在多态。这里继续分析构造器的调用过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">First</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">First</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"First---"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Second</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Second</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Second---"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Third</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Third</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Third---"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fourty</span> <span class="keyword">extends</span> <span class="title">Third</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Fourty</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Fourty---"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fifty</span> <span class="keyword">extends</span> <span class="title">Fourty</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Fifty</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Fifty---"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sixty</span> <span class="keyword">extends</span> <span class="title">Fifty</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Sixty</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Sixty---"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	First first = <span class="keyword">new</span> First();</span><br><span class="line">	Second second = <span class="keyword">new</span> Second();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Sixty();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;类的加载过程是自上而下的，因此会先寻找基类进行加载，待所有继承类就加载完成之后，加载子类的成员变量以及构造函数。</p>
<p><img src="/2018/11/13/【Java编程思想】九：多态/png5.png" alt="png5"></p>
<p>根据前面的例子，总结程序中各部分内容初始化的顺序如下：</p>
<p><strong>1.初始化基类中用到的静态变量，静态方法；</strong><br><strong>2.初始化main（）方法中的常量，如果是有静态变量的对象，先初始化静态变量，然后加载其构造器；</strong><br><strong>3.加载基类构造器；</strong><br><strong>4.按顺序初始化成员变量；</strong><br><strong>5.加载子类构造器。</strong></p>
<h1 id="四、协变返回类型"><a href="#四、协变返回类型" class="headerlink" title="四、协变返回类型"></a>四、协变返回类型</h1><p>&ensp;&ensp;&ensp;&ensp;JavaSE5中新增了协变返回类型，在子类中的覆盖方法，可以返回其基类中该方法返回类型的某一个子类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenxyt.java.practice;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Father"</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Son"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mill</span></span>&#123;</span><br><span class="line">	<span class="function">Father <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Father();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">wheatMill</span> <span class="keyword">extends</span> <span class="title">Mill</span></span>&#123;</span><br><span class="line">	<span class="function">Son <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Son();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Mill m = <span class="keyword">new</span> Mill();</span><br><span class="line">		Father f = m.process();</span><br><span class="line">		System.out.println(f);</span><br><span class="line">		m = <span class="keyword">new</span> wheatMill();</span><br><span class="line">		f = <span class="keyword">new</span> Son();</span><br><span class="line">		System.out.println(f);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/11/13/【Java编程思想】九：多态/png6.png" alt="png6"></p>
<h1 id="五、用继承进行设计"><a href="#五、用继承进行设计" class="headerlink" title="五、用继承进行设计"></a>五、用继承进行设计</h1><p>&ensp;&ensp;&ensp;&ensp;从某些角度来看，继承会增加程序的复杂性，在程序设计过程中应优先使用组合。如果单纯的是想使用某一个类，让这个类的对象完成一些功能，那么使用组合会更好一些。此外， 对于继承中多态的实现，很大部分原因是由于向上转型与动态绑定，针对向上转型，与之相对的叫做向下转型，我们都知道向上转型是安全的，而由于扩展性的原因，向下转型并不是安全的。因为父类可能并没有子类中的一个方法。</p>
<h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>&ensp;&ensp;&ensp;&ensp;多态是面向对象“封装”、“继承”、“多态”三大特性之一，理解多态的特性能够更好的设计程序，同时，掌握程序初始化加载的过程能够更好的理解程序，这也是重中之重。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Crayon Cxy</p>
              <p class="site-description motion-element" itemprop="description">Go over the mountain, and they will hear your story.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.diosfun.com/" title="六脉神间" target="_blank">六脉神间</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/chenxyt" title="My CSDN" target="_blank">My CSDN</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Crayon Cxy</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("5L2kF0V7XFDR6a7wmWFyGC3Q-gzGzoHsz", "Cy1yzcQbLJV7TGUDEmRnvC9A");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
