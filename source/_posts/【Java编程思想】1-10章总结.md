---
title: 【Java编程思想】1-10章总结
date: 2018-11-15 09:37:44
tags:
- Java 
- Think in Java
categories: 学习笔记
---

# 一、对象导论

&ensp;&ensp;&ensp;&ensp;面向对象编程的思想主要针对的是对象，Java把一切待解决的事物都抽象了出来做为对象，每一个种类的对象都有一个特定的类别，它们有共同的属性和行为。程序是对象的集合，每个程序都由对象组成，每个对象都可以由其它对象组成。对象的特性规定了这个对象能接收什么样的消息，相同类型的对象可以接收相同的消息。消息在对象中的传递是通过接口进行的，并且每个接受消息的对象都可以提供一个特定的服务。
&ensp;&ensp;&ensp;&ensp;Java提供三种访问权限控制 public 包内可见包外需要引用、private 类可见、protected 类以及继承类可见。组合跟继承是创建新类的两种形式，组合就是在新类中引入其它对象的实例，表示一种has-a的关系，继承是在基类的基础上衍生出子类的概念，子类具有基类全部的成员跟方法并且子类可以有更多的成员跟方法，继承是一种is-a的关系。
&ensp;&ensp;&ensp;&ensp;不同子类继承了同一个基类的同一个方法可以有不同的实现，这是JAVA三大特性多态的一种表现，可以给应该传递父类参数的形参传递一个子类对象的引用，JAVA通过向上转型和动态绑定机制准确的找到子类应该实现的方法。
&ensp;&ensp;&ensp;&ensp;Java中所有的类都继承自Object，这种方式的好处是在某些不知道是什么类型的地方可以直接调用Object提供的方法。
&ensp;&ensp;&ensp;&ensp;Java中提供了Map、List、Set等集合，这种集合是对象的集合，不同的集合有不同的存储方式。
&ensp;&ensp;&ensp;&ensp;Java中的对象都是使用new创建在堆上的，这是一种动态的内存分配方式，Java使用垃圾回收机制自动回收不需要使用的内存。
&ensp;&ensp;&ensp;&ensp;Java中提供了异常处理机制，在程序发生异常时会执行另一条路线。
&ensp;&ensp;&ensp;&ensp;Java支持多线程的并发式编程以及网络Web程序应用开发。

# 二、一切都是对象

&ensp;&ensp;&ensp;&ensp;Java中的一切都是对象，但是我们操作的是对象的引用。String s；只是创建了一个引用没有进行初始化也就是这个引用没有绑定对象，String s = “abc”；创建了引用s，并进行了初始化绑定了一个字符串对象。
&ensp;&ensp;&ensp;&ensp;Java中的对象都是我们使用new关键字来创建的。对象的内存分配地址主要有寄存器：处理器内部的快速处理单元；堆栈：位于随机存储器RAM中，速度仅次于寄存器，堆栈使用堆栈指针操作分配内存，这种分配方式必须制定大小和生命周期，限制了灵活性。Java中对象的引用在堆栈中但是对象并不在堆栈中；堆：同样在RAM中的内存池，区别在于使用的时候不需要指定大小和生命周期，提高了灵活性，Java中使用new关键字创建的对象都在堆中；常量存储：程序代码的内部，在与程序本身分离的系统中，它存在ROM中（只读存储器）；非RAM区：如硬盘、数据库等外部存储。
&ensp;&ensp;&ensp;&ensp;Java具有较好的平台移植性，因为Java中的基本类型大小在所有平台都相同，Java中的基本类型存储在堆栈中。常见的大小：int 4字节 short 2字节 char 2字节 float 4字节 long 8字节 double 8字节。
&ensp;&ensp;&ensp;&ensp;Java中使用Class创建类，类是同一类型对象的集合。对象存在的意义是类的实例化。类中有两种域，一个是属性，一个是方法。
&ensp;&ensp;&ensp;&ensp;Java中方法的基本组成包括返回值、方法名、参数、方法体。String toString（Objecct obj）{//---}；调用形式使用对象引用.方法的形式，如s.toString（）。

# 三、static关键字的用法

&ensp;&ensp;&ensp;&ensp;修饰成员变量：被修饰的成员变量为静态成员变量，这个变量不需要对象就可以通过类.变量的形式直接调用，这个变量只有在第一次使用的时候加载分配内存一次，后边再次用到时不进行加载内存分配。
&ensp;&ensp;&ensp;&ensp;修饰成员方法：被修饰的成员方法为静态方法，这个方法可以直接通过类.方法的形式调用。这个最直接的应用场景就是在使用单例模式的时候，我们想通过一个方法获取对象，而此时我们还没有对象可以调用这个方法，因此这个时候获取对象的方法设置成为static的最好不过了。
&ensp;&ensp;&ensp;&ensp;修饰代码块：修饰代码块的作用与前边相同，表示这个块的内部都是静态的。
&ensp;&ensp;&ensp;&ensp;静态导入：还有一种不太常用的形式就是在另外一个包的静态方法，可以使用import static导入，从而直接使用这个方法。

# 四、操作符

&ensp;&ensp;&ensp;&ensp;Java跟其他语言一样支持+ - * / % 等操作符，同时优先级计算顺序也是先乘除后加减有括号先计算括号。
&ensp;&ensp;&ensp;&ensp;赋值操作符=将操作符右边的值赋给左边的变量，左边不能是常量。如果使用=连接两个对象的引用，那么=左边的对象会被释放。这种现象叫做“别名”现象，避免这种现象的赋值方式为使用引用.域赋值。
&ensp;&ensp;&ensp;&ensp;自增自减与其它语言一样，分为前缀式和后缀式，前缀式++a表示这个值先+1然后再进行例如赋值运算等操作，而后缀式a++则表示先取a的值做赋值或者其他操作，然后再+1
&ensp;&ensp;&ensp;&ensp;关系操作符==和！=在用于基本类型操作时与其它语言相同，而对于对象操作时，略有不同。==（！=）对于对象的操作是比较引用的地址是否相同。因为是两个不同的对象引用，所以地址肯定不同。Java中Obejct类提供equals（）方法，实际上也是比较引用的地址，而继承Obejct类的大多数如String类，都覆盖了这个方法，改为判断对象的类型是否相同以及值是否相同。          

&ensp;&ensp;&ensp;&ensp;Java中的逻辑操作符只能应用于布尔值之间，逻辑运算存在短路的可能，位运算符不存在短路的可能。左移（<<）位操作符低位补0，右移（>>）位操作符正数高位补0，负数高位补1，无符号右移（>>>）不管正负高位都补0
&ensp;&ensp;&ensp;&ensp;三元运算符自带if-else判断分支，A?B:C如果A为真则表达式取B的值，否则取C的值，常用的地方就是给表达式赋值的时候判断是否为null，为null的时候赋值“”。
&ensp;&ensp;&ensp;&ensp;+=和+字符串操作符用来连接两个字符串，如果前边为String类型而后边不为String，后边会被尝试转为String。
&ensp;&ensp;&ensp;&ensp;Java支持使用（类型A）值的形式将值显示的转换成A类型。
&ensp;&ensp;&ensp;&ensp;Java支持全平台迁移，sizeof函数的意义在于计算值的字节长度，然后考虑平台迁移的问题。

# 五、控制执行流程

&ensp;&ensp;&ensp;&ensp;if-else、for、while这些与其它语言没有区别，for-each用来循环获取一个集合中的值。for（A a ：Array[A]）

# 六、构造与清理

&ensp;&ensp;&ensp;&ensp;Java中使用与类名相同的无返回值的函数作为构造函数进行初始化。当使用new创建对象的时候，就调用了构造函数。类中如果没有显示的指明构造函数，那么默认为无参的构造函数。如果显示的提供了一个且仅有一个的带参数的构造器，那么该类的无参构造器将不可用。
&ensp;&ensp;&ensp;&ensp;Java中支持方法的重载，重载是指函数名相同，但是参数类型或者参数个数不同的形式，重载包括构造器重载和普通函数重载。返回值不同的这种重载容易使人疏忽。
&ensp;&ensp;&ensp;&ensp;Java中的this关键字有三种用法：一表示当前对象的引用，并返回当前对象，如在构造器中使用return this 返回该类的对象，二是表示该类中的成员变量，如在带有参数的构造器中，形参与成员变量相同，那么此时使用this.a=a 用来区分是把形参赋值给成员变量。三在一个构造器中调用另一个构造器的时候，使用this代替构造器的名称。
&ensp;&ensp;&ensp;&ensp;Java中的垃圾回收不一定会发生，一般如果不显示的调用GC，只有在资源快要枯竭的时候才会发生，因为垃圾回收也会占用资源。
&ensp;&ensp;&ensp;&ensp;Java会尽量保证每个变量都会被初始化，如果局部变量没有初始化就调用那么会报错，而成员变量没有显示的初始化，编译器会给赋默认值。
&ensp;&ensp;&ensp;&ensp;JavaSE5之前，可以使用Object类型的数组来做变参函数，因为所有类型都是Object的子类，SE5之后提供了 ...的形式作为变参函数使用。
&ensp;&ensp;&ensp;&ensp;枚举在Java中实际上是一个类，枚举是一系列常量值的集合。枚举的另一个使用场景是使用一个只有单一常量值的枚举来实现单例模式。

# 七、访问权限控制

&ensp;&ensp;&ensp;&ensp;Java中提供了包的概念，包是一系列.java的集合，不同包中访问资源需要使用import关键字导入要使用的包。不同包中的类可以重名。
&ensp;&ensp;&ensp;&ensp;public：包可见权限，被public修饰的内容同一个包中都可见，当使用了import关键字导入新包的时候，新包中的public域也能被访问。
&ensp;&ensp;&ensp;&ensp;private：私有可见，除了当前类，其它都不可见，包括该类的实例化对象也不可访问该类的private域，比如在单例模式中，将类的构造函数私有化，可以有效的控制实例产生的个数。
&ensp;&ensp;&ensp;&ensp;protected：继承可见，与private类似，只有自己的类可见，同时支持该类的继承类访问。
一个文件中最多只能有一个被修饰为public的类。

# 八、复用类

&ensp;&ensp;&ensp;&ensp;对象初始化有四种方式：1是在创建对象引用的时候使用new关键字，2是在构造器中进行初始化，3是延迟加载当用到的时候才进行初始化，4是使用实例进行初始化，即用一个确定的实例代替new关键字。
&ensp;&ensp;&ensp;&ensp;组合是产生新类的一种复用形式，组合的基本语法是在一个新类中创建旧类的对象，然后使用这个对象。
&ensp;&ensp;&ensp;&ensp;继承也是产生新类的一种复用形式，继承使用extends关键字，被继承的类称作基类，继承类称作导出类，导出类拥有基类的全部域跟方法，并且可以根据具体业务增加新的功能。导出类同时可以重载基类的方法。使用继承的主要场景是想使用基类的一部分方法。
&ensp;&ensp;&ensp;&ensp;Java中没有明确的提供对代理的直接支持，可以在A类中定义一个方法，然后在这个方法中使用另一个类的对象调用方法，在main函数中通过调用A中定义的方法来实现业务功能。
&ensp;&ensp;&ensp;&ensp;一个方法的形参为基类，传递的参数为子类，编译器会将子类转换成基类，这个过程称作向上转型。由于子类是父类的超集，所以向上转型是安全的。
&ensp;&ensp;&ensp;&ensp;final关键字用来修饰一个不可被改变的域。用来修饰变量，表示变量值不可被改变，用来修饰参数，表示这个参数指向的对象不可被改变，用来修饰方法，表示这个方法被锁定，不能被重写，用来修饰类，表示该类不能被继承。
&ensp;&ensp;&ensp;&ensp;类的资源加载过程：先查找main函数，然后确定这个类是否有基类，有基类向上加载，直到最顶层的基类。然后加载基类中的static域，然后是子类中的static域。这时候必要的资源都已经加载完成，开始对象的创建。先执行基类构造函数，然后按顺序初始化域，最后执行子类构造函数。

# 九、多态

&ensp;&ensp;&ensp;&ensp;直到运行的时候才确定对象引用调用哪个方法这个行为叫做后期绑定，Java中出了static和final修饰的域其它的都是动态绑定。子类跟基类都具有相同的方法但是实现不同这种称为方法的覆盖或者是重写。也就是因为向上转型和动态绑定，Java中传递不同的参数实现了相应的功能，这也就是多态的意义所在。
&ensp;&ensp;&ensp;&ensp;私有方法被重写会当做是新的方法。因为私有方法是不可见的。解决问题的方式是避免出现跟父类私有方法重名的方法。
&ensp;&ensp;&ensp;&ensp;只有普通的方法是多态的，域和静态方法都不是多态的。
&ensp;&ensp;&ensp;&ensp;一个方法的返回值为指定返回值的子类，这种形式称为协变返回类型。

# 十、接口

&ensp;&ensp;&ensp;&ensp;抽象方法，只有方法定义没有方法实现的被abstract修饰的方法称为抽象方法。
&ensp;&ensp;&ensp;&ensp;包含有抽象方法的被abstract修饰的类称作是抽象类。抽象类是不安全的，不能够创建对象，同时可以创建一个没有任何抽象方法的类，这个类存在的目的就是不想让这个类创建对象。继承abstract的类，必须实现基类的abstract方法，否则子类也要被定义为abstract类。
&ensp;&ensp;&ensp;&ensp;将class关键字替换成interface即创建了一个接口，接口中所有的方法都是只有定义没有具体实现的。所有的域都被隐式的修饰为static final。如果我们想实现一个接口的话使用implements关键字实现这个接口。
&ensp;&ensp;&ensp;&ensp;对于形参类型是类的参数，我们只能传递这个类或者是子类，而对于形参是接口类型的方法，则所有使用implements关键字实现了这个接口的类都可以作为参数传递。
&ensp;&ensp;&ensp;&ensp;Java不支持多重继承，但是可以实现多个接口。接口也可以继承接口，也可以继承多个接口。
&ensp;&ensp;&ensp;&ensp;适配器模式用来将两个不能一起工作的类，适配在一起。
&ensp;&ensp;&ensp;&ensp;接口中的域隐式的为static final 这是SE5之前可以用来实现枚举类型。
&ensp;&ensp;&ensp;&ensp;接口也支持嵌套接口，在实现一个接口的时候，不需要实现它内部嵌套的接口。并且private接口只能在定义它的类中使用。
&ensp;&ensp;&ensp;&ensp;工厂方法模式允许在不同的类型中复用同一段代码。